From 4096e6e0981fefd93a83594c69570a575c772582 Mon Sep 17 00:00:00 2001
From: LordPsyan <uppp@juno.com>
Date: Sat, 12 Nov 2011 14:20:48 -0600
Subject: [PATCH] 2011-11-12_Playerbots

---
 sql/extras/world_playerbots.sql                    |    9 +
 src/server/game/AI/CoreAI/PetAI.cpp                |    8 +
 src/server/game/AI/PlayerBots/PlayerbotAI.cpp      | 4353 ++++++++++++++++++++
 src/server/game/AI/PlayerBots/PlayerbotAI.h        |  284 ++
 src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp |  596 +++
 src/server/game/AI/PlayerBots/PlayerbotClassAI.h   |  162 +
 .../game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp  |  325 ++
 .../game/AI/PlayerBots/PlayerbotDeathKnightAI.h    |   61 +
 src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp |  676 +++
 src/server/game/AI/PlayerBots/PlayerbotDruidAI.h   |   70 +
 .../game/AI/PlayerBots/PlayerbotHunterAI.cpp       |  561 +++
 src/server/game/AI/PlayerBots/PlayerbotHunterAI.h  |   70 +
 src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp  |  384 ++
 src/server/game/AI/PlayerBots/PlayerbotMageAI.h    |   69 +
 .../game/AI/PlayerBots/PlayerbotPaladinAI.cpp      |  536 +++
 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h |   70 +
 .../game/AI/PlayerBots/PlayerbotPriestAI.cpp       |  400 ++
 src/server/game/AI/PlayerBots/PlayerbotPriestAI.h  |   59 +
 src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp |  266 ++
 src/server/game/AI/PlayerBots/PlayerbotRogueAI.h   |   41 +
 .../game/AI/PlayerBots/PlayerbotShamanAI.cpp       |  555 +++
 src/server/game/AI/PlayerBots/PlayerbotShamanAI.h  |   75 +
 .../game/AI/PlayerBots/PlayerbotWarlockAI.cpp      |  410 ++
 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h |   57 +
 .../game/AI/PlayerBots/PlayerbotWarriorAI.cpp      |  400 ++
 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h |   57 +
 src/server/game/CMakeLists.txt                     |    2 +
 src/server/game/Chat/Chat.cpp                      |   11 +
 src/server/game/Chat/Chat.h                        |    7 +
 src/server/game/Chat/Commands/Level0.cpp           |  180 +
 src/server/game/Chat/Commands/Level1.cpp           |    5 +-
 src/server/game/Chat/Commands/Level3.cpp           |  205 +-
 src/server/game/Entities/Creature/Creature.cpp     |    3 +
 src/server/game/Entities/Creature/Creature.h       |   13 +
 src/server/game/Entities/Creature/GossipDef.h      |    1 +
 .../game/Entities/Creature/TemporarySummon.cpp     |    8 +
 src/server/game/Entities/Object/Object.cpp         |   27 +-
 src/server/game/Entities/Player/Player.cpp         |  315 ++-
 src/server/game/Entities/Player/Player.h           |  112 +-
 src/server/game/Entities/Unit/Unit.cpp             |    2 +
 src/server/game/Groups/Group.cpp                   |   81 +-
 src/server/game/Groups/Group.h                     |   16 +
 src/server/game/Maps/Map.cpp                       |   15 +-
 src/server/game/Quests/QuestDef.h                  |    4 +-
 src/server/game/Scripting/ScriptLoader.cpp         |    2 +
 .../Server/Protocol/Handlers/CharacterHandler.cpp  |  163 +
 .../game/Server/Protocol/Handlers/ChatHandler.cpp  |   29 +-
 .../game/Server/Protocol/Handlers/GroupHandler.cpp |   33 +-
 .../game/Server/Protocol/Handlers/NPCHandler.cpp   |    3 +-
 src/server/game/Server/WorldSession.cpp            |  115 +-
 src/server/game/Server/WorldSession.h              |   12 +-
 src/server/game/Weather/Weather.cpp                |    2 +-
 src/server/game/World/World.cpp                    |    2 +
 src/server/game/World/World.h                      |    1 +
 src/server/scripts/Custom/CMakeLists.txt           |    1 +
 src/server/scripts/Custom/script_bot_giver.cpp     |  162 +
 src/server/shared/Common.h                         |    4 +
 src/server/worldserver/worldserver.conf.dist       |   52 +
 58 files changed, 12110 insertions(+), 32 deletions(-)
 create mode 100644 sql/extras/world_playerbots.sql
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotClassAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMageAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
 create mode 100644 src/server/scripts/Custom/script_bot_giver.cpp

diff --git a/sql/extras/world_playerbots.sql b/sql/extras/world_playerbots.sql
new file mode 100644
index 0000000..da229c8
--- /dev/null
+++ b/sql/extras/world_playerbots.sql
@@ -0,0 +1,9 @@
+-- Playerbots modified and fixed by LordPsyan
+
+DELETE FROM command where name='bot';
+INSERT INTO command (name, security, help) VALUES ('bot',0,'Syntax: .bot $subcommand $Name');
+
+delete from `creature_template` where entry = 60000;
+
+insert  into `creature_template`(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,`faction_A`,`faction_H`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`mindmg`,`maxdmg`,`dmgschool`,`attackpower`,`dmg_multiplier`,`baseattacktime`,`rangeattacktime`,`unit_class`,`unit_flags`,`dynamicflags`,`family`,`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`minrangedmg`,`maxrangedmg`,`rangedattackpower`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`Health_mod`,`Mana_mod`,`Armor_mod`,`RacialLeader`,`questItem1`,`questItem2`,`questItem3`,`questItem4`,`questItem5`,`questItem6`,`movementId`,`RegenHealth`,`equipment_id`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`WDBVerified`) values 
+(60000,0,0,0,0,0,169,0,169,0,'Recruitment Officer','','',0,80,80,0,35,35,1,1.4,1.14286,1,0,228,298,0,1837,1,2000,0,1,0,0,0,0,0,0,0,0,0,0,4,0,0,0,0,0,0,300,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,'script_bot_giver',0),
diff --git a/src/server/game/AI/CoreAI/PetAI.cpp b/src/server/game/AI/CoreAI/PetAI.cpp
index e009bf9..01e8531 100755
--- a/src/server/game/AI/CoreAI/PetAI.cpp
+++ b/src/server/game/AI/CoreAI/PetAI.cpp
@@ -47,6 +47,7 @@ PetAI::PetAI(Creature* c) : CreatureAI(c), i_tracker(TIME_INTERVAL_LOOK)
 
 void PetAI::EnterEvadeMode()
 {
+    if(me->GetIAmABot() && me->GetBotAI()) me->GetBotAI()->EnterEvadeMode();
 }
 
 bool PetAI::_needToStop()
@@ -84,6 +85,12 @@ void PetAI::UpdateAI(const uint32 diff)
     if (!me->isAlive())
         return;
 
+    if(me->GetIAmABot())
+    {
+        //don't do anything if eating or drinking, otherwise call UpdateAI
+        if(!me->HasAura(10256) && !me->HasAura(1137) && me->GetBotAI()) me->GetBotAI()->UpdateAI(diff);
+    }
+
     Unit* owner = me->GetCharmerOrOwner();
 
     if (m_updateAlliesTimer <= diff)
@@ -287,6 +294,7 @@ void PetAI::KilledUnit(Unit* victim)
 
 void PetAI::AttackStart(Unit* target)
 {
+    if (me->GetCharmInfo() == NULL) return;
     // Overrides Unit::AttackStart to correctly evaluate Pet states
 
     // Check all pet states to decide if we can attack this target
diff --git a/src/server/game/AI/PlayerBots/PlayerbotAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotAI.cpp
new file mode 100644
index 0000000..be38b5f
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotAI.cpp
@@ -0,0 +1,4353 @@
+#include "Common.h"
+#include "Database/DatabaseEnv.h"
+#include "DBCStores.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "WorldPacket.h"
+#include "Spell.h"
+#include "Unit.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "SharedDefines.h"
+#include "GossipDef.h"
+#include "Config.h"
+#include "GroupMgr.h"
+#include "Group.h"
+#include <ctime>
+
+
+
+/*
+* Packets often compress the GUID (global unique identifier)
+* This function extracts the guid from the packet and decompresses it.
+* The first word (8 bits) in the packet represents how many words in the following packet(s) are part of
+* the guid and what weight they hold. I call it the mask. For example) if mask is 01001001,
+* there will be only 3 words. The first word is shifted to the left 0 times,
+* the second is shifted 3 times, and the third is shifted 6.
+*/
+uint64 extractGuid(WorldPacket &packet)
+{
+    uint8 mask; packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while(true)
+    {
+        if(mask & testMask)
+        {
+            uint8 word; packet >> word;
+            guid += (word << bit);
+        }
+        if(bit == 7) break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+//ChatHandler already implements some useful commands the master can call on bots
+//These commands are protected inside the ChatHandler class so this class provides access to the commands
+//we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler
+{
+    public:
+        explicit PlayerbotChatHandler(Player *pMasterPlayer) : ChatHandler(pMasterPlayer){}
+
+        bool revive(const Player &botPlayer){ return HandleReviveCommand(botPlayer.GetName()); }
+        bool teleport(const Player &botPlayer){ return HandleSummonCommand(botPlayer.GetName()); }
+        bool teleport(Player &botPlayer, const WorldLocation &loc){ return botPlayer.TeleportTo(loc,TELE_TO_GM_MODE); }
+        bool uninvite(const char *str){ return HandlePlayerbotCommand(str); }
+        void sysmessage(const char *str){ SendSysMessage(str); }
+        bool acceptQuest(const char *str){ return HandleQuestAdd(str); }
+        bool abandonQuest(const char *str) { return HandleQuestRemove(str); }
+};
+
+PlayerbotAI::PlayerbotAI(Player *const master, Player *const bot): m_master(master), m_bot(bot),
+m_ignoreAIUpdatesUntilTime(0), m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVEEASY),
+m_TimeDoneEating(0), m_TimeDoneDrinking(0), m_CurrentlyCastingSpellId(0), m_IsFollowingMaster(true),
+m_spellIdCommand(0), m_targetGuidCommand(0), m_classAI(0), isLooting(false), m_TimeRessurect(0),
+m_FeastSpamTimer(0)
+{
+
+    //If the player have a group, it's possible to add the bot.
+    if(master->GetGroup())
+    {
+        Group *m_group = master->GetGroup();
+        bool inGroup = false;
+        Group::MemberSlotList members = m_group->GetMemberSlots();
+
+        if(!m_group->IsFull() ||
+            m_group->IsMember(bot->GetGUID()) )
+        {
+            //check that bot is not already in the group, ie from a server crash
+            Group::MemberSlotList const &groupSlot = master->GetGroup()->GetMemberSlots();
+            for(Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player *tPlayer = master->GetObjPlayer(itr->guid);
+                if(itr->guid == bot->GetGUID()) inGroup = true;
+            }
+            if(!inGroup) m_group->AddMember(bot);
+        } else {
+            //group is full so can't add bot
+            bot->Say("Group is full!", LANG_UNIVERSAL);
+        }
+    } else {
+        Group *m_group = new Group;
+       if(!m_group->Create(master))
+        {
+            return;
+        }
+        sGroupMgr->AddGroup(m_group);
+        if(!m_group->IsFull()) m_group->AddMember(bot);
+    }
+
+    //get class specific AI
+    switch(m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotPriestAI(master, m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotWarriorAI(master, m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotShamanAI(master, m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotRogueAI(master, m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotPaladinAI(master, m_bot, this);
+            break;
+        case CLASS_MAGE:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotMageAI(master, m_bot, this);
+            break;
+        case CLASS_DRUID:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotDruidAI(master, m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotWarlockAI(master, m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotHunterAI(master, m_bot, this);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotDeathKnightAI(master, m_bot, this);
+            break;
+    }
+
+    //load config variables
+    m_followDistanceMin = ConfigMgr::GetFloatDefault("Bot.FollowDistanceMin", 0.5f);
+    m_followDistanceMax = ConfigMgr::GetFloatDefault("Bot.FollowDistanceMax", 3.0f);
+    m_playerBotsFly = ConfigMgr::GetIntDefault("Bot.PlayerBotsFly", 0);
+
+    SetQuestNeedItems();
+    m_needEmblemList.clear();
+    m_needEmblemList[29434] = 200; // Badge of Justice
+    m_needEmblemList[40752] = 200; // Emblem of Heroism
+    m_needEmblemList[40753] = 200; // Emblem of Valor
+    m_needEmblemList[45624] = 200; // Emblem of Conquest
+    m_needEmblemList[47241] = 200; // Emblem of Triumph
+    m_needEmblemList[49426] = 200; // Emblem of Frost
+    m_needEmblemList[44990] = 200; // Champion's Seal
+    HandleCommand("help", *m_master);
+}
+PlayerbotAI::~PlayerbotAI(){}
+
+//finds spell ID for matching substring args
+//in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char *args, bool master) const
+{
+    if(!*args) return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if(!Utf8toWStr(namepart, wnamepart)) return 0;
+
+    //converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = 0;
+    if(master) loc = m_master->GetSession()->GetSessionDbcLocale();
+    else loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || SPELL_ATTR0_PASSIVE) continue;
+
+        const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if(!pSpellInfo) continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if(name.empty() || !Utf8FitTo(name, wnamepart)) continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <=  0) ? true : false;
+
+        //if we already found a spell
+        bool useThisSpell = true;
+        if(foundSpellId > 0)
+        {
+            if(isExactMatch && !foundExactMatch){}
+            else if(usesNoReagents && !foundMatchUsesNoReagents){}
+            else if(spellId > foundSpellId){}
+            else useThisSpell = false;
+        }
+        if(useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+    return foundSpellId;
+}
+
+uint32 PlayerbotAI::getSpellIdExact(const char *args, bool includePassive, bool master)
+{
+    if(!*args) return 0;
+    std::string namepart = args;
+    int loc = 0;
+    if(master) loc = m_master->GetSession()->GetSessionDbcLocale();
+    else loc = m_bot->GetSession()->GetSessionDbcLocale();
+    uint32 foundSpellId = (uint32) 0;
+    bool foundMatchUsesNoReagents = false;
+
+    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || ( !includePassive && SPELL_ATTR0_PASSIVE)) continue;
+        const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+        if(!pSpellInfo) continue;
+        if(pSpellInfo->Effect[0] == SPELL_EFFECT_LEARN_SPELL) continue; //This is a learn spell
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if(name.empty()) continue;
+        if(strcmp(name.c_str(),namepart.c_str())) continue;
+        if(pSpellInfo->Reagent[0] <=  0 && !foundMatchUsesNoReagents){ foundSpellId = spellId; foundMatchUsesNoReagents = true; }
+        else if(spellId > foundSpellId) { foundSpellId = spellId; }
+    }
+    //sLog->outDebug(LOG_FILTER_NETWORKIO, "PBot Class %u - Found in Search - [%u/%s]", m_bot->getClass(), foundSpellId, namepart.c_str());
+    if (foundSpellId > 70000) { sLog->outDebug(LOG_FILTER_NETWORKIO, "CRITICAL: PBot Class %u - Weird Spell in Search - [%u/%s]", m_bot->getClass(), foundSpellId, namepart.c_str()); }
+    return foundSpellId;
+}
+
+// finds quest ID for matching substring args
+uint32 PlayerbotAI::getQuestId(const char* args, bool remove) const
+{
+    if (!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart,wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+    uint32 questId = 0;
+    uint32 foundQuestId = 0;
+    bool foundExactMatch = false;
+    if (!m_questsSeen.empty() && !remove)
+    {
+        for (BotQuestsSeen::const_iterator iter = m_questsSeen.begin(); iter != m_questsSeen.end(); ++iter)
+        {
+            uint32 questId = iter->first;
+            const std::string name = iter->second;
+            if (name.empty() || !Utf8FitTo(name, wnamepart))
+                continue;
+            bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+            // if we already found a quest
+            bool useThisQuest = true;
+            if (foundQuestId > 0)
+            {
+                if (isExactMatch && ! foundExactMatch)
+                {
+                }
+                else if (questId > foundQuestId)
+                {
+                }
+                else
+                    useThisQuest = false;
+            }
+            if (useThisQuest)
+            {
+                foundQuestId = questId;
+                foundExactMatch = isExactMatch;
+            }
+        }
+    }
+    else if (remove)
+    {
+        for (QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+        {
+            const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+            if (!qInfo) continue;
+
+            uint32 questId = qInfo->GetQuestId();
+            const std::string name = qInfo->GetTitle();
+            if (name.empty() || !Utf8FitTo(name, wnamepart))
+                continue;
+
+            bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+            // if we already found a quest
+            bool useThisQuest = true;
+            if (foundQuestId > 0)
+            {
+                if (isExactMatch && ! foundExactMatch)
+                {
+                }
+                else if (questId > foundQuestId)
+                {
+                }
+                else
+                    useThisQuest = false;
+            }
+            if (useThisQuest)
+            {
+                foundQuestId = questId;
+                foundExactMatch = isExactMatch;
+            }
+        }
+    }
+    return foundQuestId;
+}
+
+
+/*
+* Send a list of equipment that is in bot's inventor that is currently unequipped.
+* This is called when the master is inspecting the bot.
+*/
+void PlayerbotAI::SendNotEquipList(Player &player)
+{
+    //find all unequipped items and put them in
+    //a vector of dynamically created lists where the vector index is from 0-18
+    //and the list contains Item *that can be equipped to that slot
+    //Note: each dynamically created list in the vector must be deleted at end
+    //so NO EARLY RETURNS!
+    //see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    //is assigned to. (The first is EQUIPMENT_SLOT_HEAD = 0, and last is EQUIPMENT_SLOT_TABARD = 18)
+
+    std::list<Item *> *equip[19];
+    for(uint8 i = 0; i < 19; ++i) equip[i] = NULL;
+
+    //list out items in main backpack
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem)
+            continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if(msg != EQUIP_ERR_OK) continue;
+
+        //the dest looks like it includes the old loc in the 8 higher bits
+        //so casting it to a uint8 strips them
+        uint8 equipSlot = uint8(dest);
+        if(!(equipSlot >= 0 && equipSlot < 19)) continue;
+
+        //create a list if one doesn't already exist
+        if(equip[equipSlot] == NULL)
+            equip[equipSlot] = new std::list<Item *>;
+
+        std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag)
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(!pItem)
+                    continue;
+
+                uint16 equipSlot;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, equipSlot, pItem, !pItem->IsBag());
+                if(msg != EQUIP_ERR_OK)
+                    continue;
+                if(!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+
+                //create a list if one doesn't already exist
+                if(equip[equipSlot] == NULL)
+                    equip[equipSlot] = new std::list<Item *>;
+
+                std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+                itemListForEqSlot->push_back(pItem);
+            }
+        }
+    }
+
+    TellMaster("Here's all the items in my inventory that I can equip:");
+    ChatHandler ch(m_master);
+
+    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
+    "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
+    "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged", "tabard" };
+
+    //now send client all items that can be equipped by slot
+    for(uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
+    {
+        if(equip[equipSlot] == NULL) continue;
+        std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for(std::list<Item *>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it)
+        {
+            const ItemTemplate *const pItemTemplate = (*it)->GetTemplate();
+            out << " |cffffffff|Hitem:" << pItemTemplate->ItemId
+            << ":0:0:0:0:0:0:0" << "|h[" << pItemTemplate->Name1
+            << "]|h|r";
+        }
+        ch.SendSysMessage(out.str().c_str());
+        delete itemListForEqSlot; //delete list of Item *
+    }
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket &packet, WorldSession &masterSession)
+{
+    /* Testing
+    const char *oc = LookupOpcodeName(packet.GetOpcode());
+
+    std::ostringstream out;
+    out << "HandleMasterOutgoingPacket: " << oc;
+    //sLog->outError(out.str().c_str());
+    // Testing*/
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket &packet, WorldSession &masterSession)
+{
+    switch(packet.GetOpcode())
+    {
+		case CMSG_SET_SELECTION:
+		{
+			//sLog->outError("cmsg_set_selection");
+			return;
+		}
+
+        //If master inspects one of his bots, give the master useful info in chat window
+        //such as inventory that can be equipped
+        case CMSG_INSPECT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint64 guid; p >> guid;
+            Player *const bot = masterSession.GetPlayerBot(guid);
+            if(!bot) return;
+            bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+        }
+
+        case CMSG_PUSHQUESTTOPARTY:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 quest; p >> quest;
+            Player *pPlayer = masterSession.GetPlayer();
+            Quest const *pQuest = sObjectMgr->GetQuestTemplate(quest);
+
+            if(pQuest)
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player *const bot = it->second;
+                    uint64 guid = it->first;
+                    uint32 unk1 = 0;
+
+                    WorldPacket data(MSG_QUEST_PUSH_RESULT, (8+4+4));
+                    //data << guid;
+                    data << pPlayer->GetGUID();
+                    data << quest;
+                    data << unk1;
+
+                    bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(data);
+                    bot->GetPlayerbotAI()->SetQuestNeedItems();
+                }
+            return;
+        }
+
+        //handle emotes from the master
+        //case CMSG_EMOTE:
+        case CMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 emoteNum;
+//            uint64 guid;
+            p >> emoteNum;
+
+            switch(emoteNum)
+            {
+                case TEXT_EMOTE_BONK:
+                {
+                    Player *const pPlayer = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(!pPlayer || !pPlayer->GetPlayerbotAI()) return;
+                    PlayerbotAI *const pBot = pPlayer->GetPlayerbotAI();
+
+                    ChatHandler ch(masterSession.GetPlayer());
+
+                    {
+                    std::ostringstream out;
+                    out << "clock(): " << (getMSTime())
+                    << " m_ignoreAIUpdatesUntilTime: " << (pBot->m_ignoreAIUpdatesUntilTime);
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                    << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_IsFollowingMaster: " << pBot->m_IsFollowingMaster;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsBeingTeleported(): " << pBot->m_bot->IsBeingTeleported();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    bool tradeActive = (pBot->m_bot->GetTrader()) ? true : false;
+                    out << "tradeActive: " << tradeActive;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsCharmed(): " << pBot->m_bot->isCharmed();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsInCombat(): " << pBot->m_bot->isInCombat();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "isLooting: " << pBot->isLooting;
+                    ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                    std::ostringstream out;
+                    out << "isPulling: " << pBot->GetClassAI()->isPulling();
+                    ch.SendSysMessage(out.str().c_str());
+                    }
+                    return;
+                }
+
+                case TEXT_EMOTE_EAT:
+                case TEXT_EMOTE_DRINK:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot) bot->GetPlayerbotAI()->Stay();
+                    else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Feast();
+                        }
+                    }
+                    return;
+                }
+
+                //emote to stay
+                case TEXT_EMOTE_STAND:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot) bot->GetPlayerbotAI()->Stay();
+                    else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Stay();
+                        }
+                    }
+                    return;
+                }
+
+                //324 is the followme emote (not defined in enum)
+                //if master has bot selected then only bot follows, else all bots follow
+                case 324:
+                case TEXT_EMOTE_WAVE:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot)
+                    {
+                        bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                        bot->GetPlayerbotAI()->SetLooting(false);
+                    } else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                            bot->GetPlayerbotAI()->SetLooting(false);
+                        }
+                    }
+                    return;
+                }
+
+                default: return;
+            }
+        } //end CMSG_TEXT_EMOTE
+
+        case CMSG_GROUP_UNINVITE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            std::string member; p >> member;
+            p.clear();
+
+            WorldPacket data(CMSG_GROUP_UNINVITE, 1);
+            PlayerbotChatHandler ch(masterSession.GetPlayer());
+            std::ostringstream out;
+            out << "remove " << member;
+            ch.uninvite(out.str().c_str());
+            return;
+        }
+
+        case CMSG_REPAIR_ITEM:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint64 npcGUID;
+            p >> npcGUID;
+
+            Object *const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT);
+            if(!pNpc)
+                return;
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+                if(!bot->IsInMap((WorldObject*) pNpc))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to repair items!");
+                    continue;
+                } else {
+                    bot->GetPlayerbotAI()->TellMaster("Repairing my items.");
+                    bot->DurabilityRepairAll(false, 0.0, false);
+                }
+
+            }
+            return;
+        }
+
+        case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            WorldPacket incP(packet);
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+
+                Player *const bot = it->second;
+                if (!bot->GetPlayerbotAI()->CanBotsFly()) return;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to fly!");
+                    continue;
+                } else {
+                    WorldPacket p;
+                   // p << guid << _totalcost << node_count;
+                    bot->GetPlayerbotAI()->Stay();  // clear any movement
+                    incP.rpos(0);
+                    bot->GetSession()->HandleActivateTaxiExpressOpcode(incP);
+                }
+
+            }
+            return;
+        }
+
+        case CMSG_ACTIVATETAXI:
+        {
+            WorldPacket incP(packet);
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+                if (!bot->GetPlayerbotAI()->CanBotsFly()) return;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to fly!");
+                    continue;
+                } else {
+                    WorldPacket p;
+                   // p << guid << nodes[0] << nodes[1];
+                    bot->GetPlayerbotAI()->Stay();  // clear any movement
+                    incP.rpos(0);
+                    bot->GetSession()->HandleActivateTaxiOpcode(incP);
+                }
+
+            }
+            return;
+        }
+
+        // when landing from a flight path
+        case CMSG_MOVE_SPLINE_DONE:
+        {
+            WorldPacket p(packet);
+            //p.rpos(0);  // reset reader
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to land!");
+                    continue;
+                } else {
+                    p.rpos(0);  // reset reader
+                    p.appendPackGUID(bot->GetGUID());
+                    bot->GetSession()->HandleMoveSplineDoneOpcode(p);
+                    uint32 sourcenode = bot->m_taxi.GetTaxiSource();
+                    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourcenode, bot->GetTeam());
+
+                    if (mountDisplayId==0) {
+                        bot->CleanupAfterTaxiFlight();
+                        bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                    }
+                }
+
+            }
+            return;
+        }
+        case CMSG_LOOT:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 cGUID;
+                p >> cGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                Creature *cToLoot = m_master->GetMap()->GetCreature(cGUID);
+                if (!cToLoot)
+                    return;
+                /* for all master's bots */
+                for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                    it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    if (!bot->IsInMap((WorldObject*) cToLoot))
+                    {
+                        bot->GetPlayerbotAI()->TellMaster("I'm too far away to check for needed Quest Items!");
+                        continue;
+                    }
+                    else
+                    {
+                        //bot->GetPlayerbotAI()->TellMaster("Checking for needed Quest Items.");
+                        bot->GetPlayerbotAI()->AddLootGUID(cGUID);
+                        bot->GetPlayerbotAI()->DoLoot();
+                    }
+                }
+                return;
+
+            }
+            break;
+
+        case CMSG_GAMEOBJ_USE:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 objGUID;
+                p >> objGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                GameObject *obj = m_master->GetMap()->GetGameObject( objGUID );
+                if( !obj )
+                    return;
+
+               for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+//sLog->outError ("gameobject type = %u", obj->GetGoType());
+                    if( obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER )
+                    {
+                        bot->GetPlayerbotAI()->TurnInQuests( obj );
+                    }
+                    // add other go types here, i.e.:
+                    // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                }
+            }
+            break;
+
+        case CMSG_GAMEOBJ_REPORT_USE:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 objGUID;
+                p >> objGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                GameObject *obj = m_master->GetMap()->GetGameObject( objGUID );
+                if( !obj )
+                    return;
+
+                //Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+                //if (!pNpc) return;
+            /* For all master's bots */
+            for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot->IsInMap((WorldObject*) obj))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to check for needed Quest Items!");
+                    continue;
+                }
+                else
+                {
+                    //bot->GetPlayerbotAI()->TellMaster("Checking for needed Quest Items.");
+                    bot->GetPlayerbotAI()->AddLootGUID(objGUID);
+                    bot->GetPlayerbotAI()->DoLoot();
+                }
+            }
+            return;
+        }
+
+        //if master talks to an NPC
+        case CMSG_GOSSIP_HELLO:
+        case CMSG_QUESTGIVER_HELLO:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); //reset reader
+                uint64 npcGUID;
+                p >> npcGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                //Object *const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT);
+                WorldObject* pNpc = ObjectAccessor::GetWorldObject( *m_master, npcGUID );
+                if(!pNpc)
+                    return;
+
+                // if its a flight master
+                if(pNpc->HasFlag( UNIT_NPC_FLAGS, UNIT_NPC_FLAG_FLIGHTMASTER ))
+                {
+                    for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                    {
+                        Player *const bot = it->second;
+                        if (bot->GetSession()->SendLearnNewTaxiNode((Creature*)pNpc))
+                            bot->GetPlayerbotAI()->TellMaster("Learned a new path.");
+                    }
+                    return;
+                }
+
+                // for all master's bots
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    bot->GetPlayerbotAI()->TurnInQuests( pNpc );
+                    bot->GetPlayerbotAI()->SetQuestNeedItems();
+
+                    bot->TalkedToCreature(pNpc->GetEntry(), pNpc->GetGUID());
+                }
+
+                return;
+        }
+
+        case CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+           if (!masterSession.GetPlayer()->GetSelection()) return;
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                p.rpos(0); // reset reader
+                bot->GetSession()->HandleQuestgiverStatusMultipleQuery(p);
+            }
+
+
+        return;
+        }
+
+        // if master accepts a quest, bots should also try to accept quest
+        case CMSG_QUESTGIVER_ACCEPT_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint64 guid;
+            uint32 quest;
+            p >> guid >> quest;
+            Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+            if (qInfo)
+            {
+                //for all master's bots
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+
+                    if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+                        bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
+                    else if (! bot->CanTakeQuest(qInfo, false))
+                    {
+                        if (! bot->SatisfyQuestStatus(qInfo, false))
+                            bot->GetPlayerbotAI()->TellMaster("I already have that quest.");
+                        else
+                            bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
+                    }
+                    else if (! bot->SatisfyQuestLog(false))
+                        bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
+                    else if (! bot->CanAddQuest(qInfo, false))
+                        bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+
+                    else
+                    {
+                        p.rpos(0); // reset reader
+                        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                        bot->GetPlayerbotAI()->TellMaster("Got the quest.");
+                        bot->GetPlayerbotAI()->SetQuestNeedItems();
+                    }
+                }
+            }
+
+            return;
+        }
+
+        case CMSG_LIST_INVENTORY:
+            {
+                uint64 npcGUID;
+                WorldPacket p1(packet);
+                p1.rpos(0); /* reset reader */
+                p1 >> npcGUID;
+
+                Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+                if (!pNpc) return;
+
+                /* for all master's bots */
+                for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                    it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    if (!bot->IsInMap((WorldObject*) pNpc))
+                    {
+                        bot->GetPlayerbotAI()->TellMaster("I'm too far away to sell items!");
+                        continue;
+                    }
+                    else
+                    {
+                        uint32 TotalCost = 0;
+                        uint32 TotalSold = 0;
+                        std::ostringstream report;
+                        std::ostringstream canSell;
+                        canSell << "Items that are not trash and can be sold: ";
+                        // list out items in main backpack
+                        for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                        {
+                            Item* const item = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                            if (!item)
+                                continue;
+
+                            if (item->CanBeTraded() && item->GetTemplate()->Quality == ITEM_QUALITY_POOR)
+                            {
+                                int32 cost = item->GetCount() * item->GetTemplate()->SellPrice;
+                                bot->ModifyMoney(cost);
+                                bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+                                bot->AddItemToBuyBackSlot(item);
+
+                                TotalSold = TotalSold + 1;
+                                TotalCost = TotalCost + cost;
+
+                                report << "Sold " << item->GetCount() << "x";
+                                report << " |cffffffff|Hitem:" << item->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetTemplate()->Name1 << "]|h|r";
+                                report << " for ";
+
+                                uint32 gold = uint32(cost / 10000);
+                                cost -= (gold * 10000);
+                                uint32 silver = uint32(cost / 100);
+                                cost -= (silver * 100);
+
+                                if (gold > 0)
+                                {
+                                    report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                                }
+                                if (silver > 0)
+                                {
+                                    report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                                }
+                                report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                            }
+                            else if (item->GetTemplate()->SellPrice > 0)
+                            {
+                                canSell << "|cffffffff|Hitem:" << item->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetTemplate()->Name1 << "]|h|r ";
+                            }
+                        }
+
+                        for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END;++bag)
+                        {
+                            const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                            if (pBag)
+                            {
+                                for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                                {
+                                    Item* const item = bot->GetItemByPos(bag, slot);
+                                    if (!item)
+                                        continue;
+
+                                    if (item->CanBeTraded() && item->GetTemplate()->Quality == ITEM_QUALITY_POOR)
+                                    {
+                                        int32 cost = item->GetCount() * item->GetTemplate()->SellPrice;
+                                        bot->ModifyMoney(cost);
+                                        bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+                                        bot->AddItemToBuyBackSlot(item);
+
+                                        TotalSold = TotalSold + 1;
+                                        TotalCost = TotalCost + cost;
+
+                                        report << "Sold " << item->GetCount() << "x";
+                                        report << " |cffffffff|Hitem:" << item->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetTemplate()->Name1 << "]|h|r";
+                                        report << " for ";
+
+                                        uint32 gold = uint32(cost / 10000);
+                                        cost -= (gold * 10000);
+                                        uint32 silver = uint32(cost / 100);
+                                        cost -= (silver * 100);
+                                        if (gold > 0)
+                                        {
+                                            report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                                        }
+                                        if (silver > 0)
+                                        {
+                                            report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                                        }
+                                        report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                                    }
+                                    else if (item->GetTemplate()->SellPrice > 0)
+                                    {
+                                        canSell << "|cffffffff|Hitem:" << item->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetTemplate()->Name1 << "]|h|r ";
+                                    }
+                                }
+                            }
+                        }
+                        if (TotalSold > 0) {
+                            report << "Sold total " << TotalSold << " item(s) for ";
+                            uint32 gold = uint32(TotalCost / 10000);
+                            TotalCost -= (gold * 10000);
+                            uint32 silver = uint32(TotalCost / 100);
+                            TotalCost -= (silver * 100);
+                            if (gold > 0)
+                            {
+                                report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                            }
+                            if (silver > 0)
+                            {
+                                report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                            }
+                            report << TotalCost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t";
+                            bot->GetPlayerbotAI()->TellMaster(report.str());
+                        }
+                        bot->GetPlayerbotAI()->TellMaster(canSell.str());
+                    }
+                }
+                return;
+
+            }
+
+        case CMSG_AREATRIGGER:
+        {
+            uint32 Trigger_ID;
+            WorldPacket p1(packet);
+            p1.rpos(0); /* reset reader */
+            p1 >> Trigger_ID;
+
+            /* for all master's bots */
+            for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+
+                uint32 quest_id = sObjectMgr->GetQuestForAreaTrigger( Trigger_ID );
+                // The conditions that intentionally left unchecked are:
+                // Bot is alive or not
+                // Bot is in the trigger area or not
+                if( quest_id && bot->IsActiveQuest(quest_id) )
+                {
+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+                    if( pQuest )
+                    {
+                        if(bot->GetQuestStatus(quest_id) == QUEST_STATUS_INCOMPLETE)
+                        {
+                            bot->AreaExploredOrEventHappens( quest_id );
+                            bot->GetPlayerbotAI()->TellMaster("Quest area explored");
+                        }
+                    }
+                }
+
+                if(sObjectMgr->IsTavernAreaTrigger(Trigger_ID))
+                {
+                    // set resting flag we are in the inn
+                    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
+                    bot->InnEnter(time(NULL), bot->GetMapId() , bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ());
+                    bot->SetRestType(REST_TYPE_IN_TAVERN);
+
+                    if(sWorld->IsFFAPvPRealm())
+                        bot->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+                }
+            }
+            return;
+        }
+
+
+        default:
+        {
+			/*const char *oc = LookupOpcodeName(packet.GetOpcode());
+            ChatHandler ch(masterSession.GetPlayer());
+            ch.SendSysMessage(oc);
+
+            std::ostringstream out;
+            out << "HandleMasterIncomingPacket: " << oc;
+            //sLog->outError(out.str().c_str());
+
+            return;*/
+        }
+
+    }
+}
+
+//handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket &packet)
+{
+    switch(packet.GetOpcode())
+    {
+         case SMSG_TRADE_STATUS_EXTENDED:
+         {
+             //m_bot->GetSession()->SendTradeStatus(TRADE_STATUS_TRADE_ACCEPT);
+             return;
+         }
+
+
+        case SMSG_DUEL_WINNER:
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+            return;
+
+        case SMSG_DUEL_COMPLETE:
+            SetIgnoreUpdateTime(4);
+            m_combatOrder = ORDERS_NONE;
+            m_ScenarioType = SCENARIO_PVEEASY;
+            m_bot->GetMotionMaster()->Clear(true);
+            return;
+
+        case SMSG_DUEL_OUTOFBOUNDS:
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+            return;
+
+        case SMSG_DUEL_REQUESTED:
+        {
+            SetIgnoreUpdateTime(0);
+            WorldPacket p(packet);
+            uint64 flagGuid; p >> flagGuid;
+            uint64 playerGuid; p >> playerGuid;
+            Player *const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+            if(canObeyCommandFrom(*pPlayer))
+            {
+                m_bot->GetMotionMaster()->Clear(true);
+                WorldPacket *const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+                *packet << flagGuid;
+                m_bot->GetSession()->QueuePacket(packet); //queue the packet to get around race condition
+
+                //follow target in casting range
+                float angle = rand_norm()*M_PI; //Generates random float between 0 and 3.14
+                float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10); //Using urand to get a random float is stupid. It takes uint32, not float.
+                m_bot->GetMotionMaster()->Clear(true);
+                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+                m_bot->SetSelection(playerGuid);
+                SetIgnoreUpdateTime(4);
+                m_combatOrder = ORDERS_KILL;
+                m_ScenarioType = SCENARIO_DUEL;
+            }
+            return;
+        }
+
+        case SMSG_INVENTORY_CHANGE_FAILURE:
+            TellMaster("I can't use that.");
+            return;
+
+        case SMSG_SPELL_DELAYED:
+        {
+            //sLog->outDebug(LOG_FILTER_NETWORKIO, "Bot [%u] SMSG_SPELL_DELAYED",m_bot->GetGUIDLow());
+            WorldPacket p(packet);
+            //uint64 casterGuid = extractGuid(p); //somehow the caster guid is corrupt
+            //if(casterGuid != m_bot->GetGUID()) return;
+            //uint32 delayTime; p >> delayTime;
+            //sLog->outDebug(LOG_FILTER_NETWORKIO, "Bot [%u] caster [%u] Spell Delayed [%u]",m_bot->GetGUIDLow(), casterGuid, delayTime);
+            //m_ignoreAIUpdatesUntilTime +=  ((((float)delayTime) / 1000.0f ) + 0.1f) * CLOCKS_PER_SEC;
+            if(m_CurrentlyCastingSpellId > 0)
+            {
+                m_ignoreAIUpdatesUntilTime += 0.5f * 1000; //Until this is handled correctly, assume, delay is the default 0.5 secs
+            }
+            return;
+        }
+
+        case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint64 casterGuid = extractGuid(p);
+            if(casterGuid != m_bot->GetGUID()) return;
+            uint32 spellId; p >> spellId;
+            if(m_CurrentlyCastingSpellId == spellId)
+            {
+                SetIgnoreUpdateTime(1);
+                m_CurrentlyCastingSpellId = 0;
+            }
+            return;
+        }
+
+        //if a change in speed was detected for the master
+        //make sure we have the same mount status
+        case SMSG_FORCE_RUN_SPEED_CHANGE:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            //uint64 guid; p >> guid;
+            Player *tPlayer = ObjectAccessor::FindPlayer(guid);
+            if(!tPlayer) return;
+            if (!m_master || !m_bot) return;
+            if(guid == m_bot->GetGUID()) return;
+            if(guid == m_master->GetGUID()) {
+                m_bot->GetPlayerbotAI()->UseMount();
+                SetIgnoreUpdateTime(2);
+            }
+            return;
+        }
+
+        //handle flying acknowledgement
+        case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if(guid != m_bot->GetGUID()) return;
+            m_bot->AddUnitMovementFlag(MOVEMENTFLAG_FLYING);
+            //SetSpeed(MOVE_RUN, m_master->GetSpeed(MOVE_FLIGHT) + 0.1f, true);
+            return;
+        }
+
+        //handle dismount flying acknowledgement
+        case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if(guid != m_bot->GetGUID()) return;
+            m_bot->RemoveUnitMovementFlag(MOVEMENTFLAG_FLYING);
+            //SetSpeed(MOVE_RUN, m_master->GetSpeedRate(MOVE_RUN), true);
+            return;
+        }
+
+        //If the leader role was given to the bot automatically give it to the master
+        //if the master is in the group, otherwise leave group
+        case SMSG_GROUP_SET_LEADER:
+        {
+            WorldPacket p(packet);
+            std::string name; p >> name;
+            if(m_bot->GetGroup() && name == m_bot->GetName())
+            {
+                if(m_bot->GetGroup()->IsMember(m_master->GetGUID()))
+                {
+                    p.resize(8);
+                    p << m_master->GetGUID();
+                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                } else {
+                    p.clear(); //not really needed
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); //packet not used
+                }
+            }
+            return;
+        }
+
+        //If the master leaves the group, then the bot leaves too
+        case SMSG_PARTY_COMMAND_RESULT:
+        {
+            WorldPacket p(packet);
+            uint32 operation; p >> operation;
+            std::string member; p >> member;
+            uint32 result; p >> result;
+            p.clear();
+            if(operation == PARTY_OP_LEAVE && member == m_master->GetName()) m_bot->GetSession()->HandleGroupDisbandOpcode(p); //packet not used
+            return;
+        }
+
+        //Automatically accept rez. Useful when bot dies, and a druid does a battle rez.
+        case SMSG_RESURRECT_REQUEST:
+        {
+            WorldPacket p, incP(packet);
+            uint8 status = 1;
+            uint64 rezzer; incP >> rezzer;
+            p << rezzer;
+            p << status;
+            m_bot->GetPlayerbotAI()->SetLooting(false);
+            m_bot->GetSession()->HandleResurrectResponseOpcode(p);
+            m_IsFollowingMaster = true;
+            m_TimeRessurect = 0;
+            return;
+        }
+
+        //Handle Group invites (auto accept if master is in group, otherwise decline & send message)
+        case SMSG_GROUP_INVITE:
+        {
+            if(m_bot->GetGroupInvite())
+            {
+                const Group *const grp = m_bot->GetGroupInvite();
+                if(!grp) return;
+                Player *const inviter = ObjectAccessor::FindPlayer(grp->GetLeaderGUID());
+                if(!inviter) return;
+                WorldPacket p;
+                if(!canObeyCommandFrom(*inviter))
+                {
+                    std::string buf = "I can't accept your invite unless you first invite my master ";
+                    buf += m_master->GetName();
+                    buf += ".";
+                    SendWhisper(buf, *inviter);
+                    m_bot->GetSession()->HandleGroupDeclineOpcode(p); //packet not used
+                } else
+                    m_bot->GetSession()->HandleGroupAcceptOpcode(p); //packet not used
+            }
+            return;
+        }
+
+        //Handle when another player opens the trade window with the bot
+        //also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS:
+        {
+            if(m_bot->GetTrader() == NULL) break;
+            WorldPacket p(packet);
+            uint32 status; p >> status;
+            p.clear();
+
+            if(status == 4) { // TRADE_STATUS_TRADE_ACCEPT
+				if (!m_bot->GetTradeData()->IsAccepted() || !m_bot->GetTrader()->GetTradeData()->IsAccepted()) {
+                    m_bot->GetSession()->HandleAcceptTradeOpcode(p); //packet not used
+                }
+
+            } else if(status == 1) // TRADE_STATUS_BEGIN_TRADE
+            {
+                m_bot->GetSession()->HandleBeginTradeOpcode(p); //packet not used
+
+                //if(!canObeyCommandFrom(*(m_bot->GetTrader())))
+                //{
+                    //SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                    //return;
+                //}
+
+                //list out items available for trade
+                std::ostringstream out;
+
+                //list out items in main backpack
+                for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                {
+                    const Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    if(pItem && pItem->CanBeTraded())
+                    {
+                        const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                        std::string name = pItemTemplate->Name1;
+
+                        out << " |cffffffff|Hitem:" << pItemTemplate->ItemId << ":0:0:0:0:0:0:0" << "|h[" << name << "]|h|r";
+                        if(pItem->GetCount() > 1)
+                            out << "x" << pItem->GetCount() << ' ';
+                    }
+                }
+                //list out items in other removable backpacks
+                for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+                    const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                    if(pBag)
+                    {
+                        for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+                            const Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                            if(pItem && pItem->CanBeTraded())
+                            {
+                                const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                                const std::string name = pItemTemplate->Name1;
+
+                                //item link format: http://www.wowwiki.com/ItemString
+                                //itemId, enchantId, jewelId1, jewelId2, jewelId3, jewelId4, suffixId, uniqueId
+                                out << " |cffffffff|Hitem:" << pItemTemplate->ItemId << ":0:0:0:0:0:0:0" << "|h[" << name << "]|h|r";
+                                if(pItem->GetCount() > 1)
+                                    out << "x" << pItem->GetCount() << ' ';
+                            }
+                        }
+                    }
+                }
+
+                //calculate how much money bot has
+                uint32 copper = m_bot->GetMoney();
+                uint32 gold = uint32(copper / 10000);
+                copper -= (gold * 10000);
+                uint32 silver = uint32(copper / 100);
+                copper -= (silver * 100);
+
+                //send bot the message
+                std::ostringstream whisper;
+                whisper << "I have |cff00ff00" << gold
+                << "|r|cfffffc00g|r|cff00ff00" << silver
+                << "|r|cffcdcdcds|r|cff00ff00" << copper
+                << "|r|cffffd333c|r" << " and the following items:";
+                m_bot->GetPlayerbotAI()->SendWhisper(whisper.str(), *(m_bot->GetTrader()));
+                ChatHandler ch(m_bot->GetTrader());
+                ch.SendSysMessage(out.str().c_str());
+            }
+            return;
+        }
+
+        case SMSG_SPELL_GO:
+        {
+            WorldPacket p(packet);
+            uint64 castItemGuid = extractGuid(p);
+            uint64 casterGuid = extractGuid(p);
+            if(casterGuid != m_bot->GetGUID()) return;
+
+            uint32 spellId; p >> spellId;
+            uint16 castFlags; p >> castFlags;
+            uint32 msTime; p >> msTime;
+            uint8 numHit; p >> numHit;
+            if(m_CurrentlyCastingSpellId == spellId)
+            {
+                Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+                if(!pSpell) return;
+                if(pSpell->IsChannelActive() || pSpell->IsAutoRepeat())
+                    SetIgnoreUpdateTime(6);
+                else if(pSpell->IsAutoRepeat())
+                    SetIgnoreUpdateTime(6);
+                else {
+                    SetIgnoreUpdateTime(0.5f);
+                    m_CurrentlyCastingSpellId = 0;
+                }
+            }
+            return;
+        }
+
+        case SMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 text_emote;
+            uint64 guid;
+            p >> guid;
+            p >> text_emote;
+
+            switch(text_emote)
+            {
+                case TEXT_EMOTE_BOW:
+                {
+                    //Buff anyone who bows before me. Useful for players not in bot's group
+                    Player *pPlayer = ObjectAccessor::FindPlayer(guid);
+
+                    Player *const bot = ObjectAccessor::FindPlayer(pPlayer->GetSelection());
+
+                    if(bot && bot->GetGUID()==m_bot->GetGUID() &&
+                       bot->GetPlayerbotAI()->GetClassAI())
+                    {
+                        bot->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+                    }
+                    return;
+                }
+
+                default:
+                    m_bot->HandleEmoteCommand(text_emote);
+                    return;
+            }
+            return;
+        }
+
+        case MSG_MOVE_TELEPORT_ACK:
+            HandleTeleportAck();
+            return;
+
+        case SMSG_QUESTGIVER_STATUS_MULTIPLE:
+        {
+            return;
+        }
+
+        // used to communicate between bots
+        case SMSG_MESSAGECHAT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint8 msgtype;
+            uint32 language;
+            uint64 guid;
+            uint32 language2;
+            uint64 guid2;
+            uint32 textlen;
+            std::string msg;
+
+            p>>msgtype; p>>language; p>>guid; p>>language2; p>>guid2; p>>textlen;
+            p>>msg;
+
+            Player * fromPlayer = ObjectAccessor::FindPlayer(guid);
+            if (fromPlayer == NULL) break;
+            const std::string text = msg;
+            HandleCommand(text, *fromPlayer);
+        }
+
+        case SMSG_MONSTER_MOVE:
+        case SMSG_UPDATE_WORLD_STATE:
+        case SMSG_COMPRESSED_UPDATE_OBJECT:
+        case MSG_MOVE_SET_FACING:
+        case MSG_MOVE_STOP:
+        case MSG_MOVE_HEARTBEAT:
+        case MSG_MOVE_STOP_STRAFE:
+        case MSG_MOVE_START_STRAFE_LEFT:
+        case SMSG_UPDATE_OBJECT:
+        case MSG_MOVE_START_FORWARD:
+        case SMSG_WEATHER:
+        case SMSG_POWER_UPDATE:
+        case SMSG_TIME_SYNC_REQ:
+        case SMSG_STANDSTATE_UPDATE:
+        case SMSG_PERIODICAURALOG:
+        case SMSG_AURA_UPDATE:
+        return;
+
+/*TESTING
+        default:
+        const char *oc = LookupOpcodeName(packet.GetOpcode());
+        TellMaster(oc);
+        //sLog->outError("SMSG opcode: %s", oc);
+  // TESTING*/
+    }
+}
+void PlayerbotAI::HandleTeleportAck()
+{
+    SetIgnoreUpdateTime(6);
+    m_bot->GetMotionMaster()->Clear(true);
+    if(m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+        p.appendPackGUID(m_bot->GetGUID());
+        p << (uint32) 0; //supposed to be flags? not used currently
+        p << (uint32) time(0); //time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAck(p);
+    }
+    else if(m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit &target) const
+{
+    return(static_cast<float>(target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit &target) const
+{
+    if(target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return(100);
+    else
+        return(static_cast<float>(target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRunicPower(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+
+uint8 PlayerbotAI::GetRunicPower() const
+{
+    return GetRunicPower(*m_bot);
+}
+
+
+typedef std::pair<uint32, uint8> spellEffectPair;
+typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit *player) const
+{
+    for(Unit::AuraMap::const_iterator iter = player->GetOwnedAuras().begin(); iter != player->GetOwnedAuras().end(); ++iter)
+    {
+        if(iter->second->GetId() == spellId) return true;
+    }
+    return false;
+}
+bool PlayerbotAI::HasAura(const char *spellName) const
+{
+    return HasAura(spellName, m_bot);
+}
+bool PlayerbotAI::HasAura(const char *spellName, const Unit *player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return(spellId) ? HasAura(spellId, player) : false;
+}
+
+void PlayerbotAI::UseMount() const
+{
+
+    if(m_master->IsMounted() && ! m_bot->IsMounted())
+    {
+// sLog->outError ("PlayerbotAI::UseMount: %s is mounted but %s is not", m_master->GetName(), m_bot->GetName());
+        //Player Part
+        int32 master_speed1 = 0;
+        int32 master_speed2 = 0;
+        if(!m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).empty())
+        {
+            master_speed1 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellInfo()->Effects[1].CalcValue();
+            master_speed2 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellInfo()->Effects[2].CalcValue();
+        }
+//sLog->outError ("master_speed1 = %d", master_speed1);
+//sLog->outError ("master_speed2 = %d", master_speed2);
+        //Bot Part
+        uint32 spellMount = 0;
+        for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            uint32 spellId = itr->first;
+            if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || SPELL_ATTR0_PASSIVE)
+                continue;
+            const SpellEntry *pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if(!pSpellInfo)
+                continue;
+            if(pSpellInfo->EffectApplyAuraName[0] == SPELL_AURA_MOUNTED)
+            {
+                if((pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                    && (pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                {
+                    if((pSpellInfo->EffectBasePoints[1] == master_speed1)
+                        && (pSpellInfo->EffectBasePoints[2] == master_speed2))
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                else if((pSpellInfo->EffectApplyAuraName[2] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                    && (pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                {
+                    if((pSpellInfo->EffectBasePoints[2] == master_speed2)
+                        && (pSpellInfo->EffectBasePoints[1] == master_speed1))
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                else if(pSpellInfo->EffectApplyAuraName[1] == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                {
+                    if(pSpellInfo->EffectBasePoints[1] == master_speed1 && master_speed2 <= 0) { spellMount = spellId; break; } //Has no secondary mount aura
+                    else if (spellMount == 0) { spellMount = spellId; } // default to first mount in case it doesnt have correct version
+                }
+            }
+        }
+//sLog->outError ("spellMount = %u", spellMount);
+        if(spellMount > 0) m_bot->GetPlayerbotAI()->CastSpell(spellMount, m_bot);
+
+    }
+    else if(!m_master->IsMounted() && m_bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+    }
+} //end UseMount
+
+Item *PlayerbotAI::FindFood() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+            if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if (pItemTemplate->Class==ITEM_CLASS_CONSUMABLE &&
+                (pItemTemplate->SubClass==ITEM_SUBCLASS_FOOD ||
+                pItemTemplate->SubClass==ITEM_SUBCLASS_POTION ||
+                pItemTemplate->SubClass==ITEM_SUBCLASS_ELIXIR))
+            {
+                // if is FOOD
+                if (pItemTemplate->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+                    if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if (pItemTemplate->Class==ITEM_CLASS_CONSUMABLE &&
+                        (pItemTemplate->SubClass==ITEM_SUBCLASS_FOOD ||
+                        pItemTemplate->SubClass==ITEM_SUBCLASS_POTION ||
+                        pItemTemplate->SubClass==ITEM_SUBCLASS_ELIXIR))
+                    {
+                        // if is FOOD
+                        if (pItemTemplate->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+Item *PlayerbotAI::FindDrink() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+            if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if (pItemTemplate->Class==ITEM_CLASS_CONSUMABLE &&
+                (pItemTemplate->SubClass==ITEM_SUBCLASS_FOOD ||
+                pItemTemplate->SubClass==ITEM_SUBCLASS_POTION ||
+                pItemTemplate->SubClass==ITEM_SUBCLASS_ELIXIR))
+            {
+                if (pItemTemplate->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+                    pItemTemplate->Spells[0].SpellCategory == 4)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+
+                    if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if (pItemTemplate->Class==ITEM_CLASS_CONSUMABLE &&
+                        (pItemTemplate->SubClass==ITEM_SUBCLASS_FOOD ||
+                        pItemTemplate->SubClass==ITEM_SUBCLASS_POTION ||
+                        pItemTemplate->SubClass==ITEM_SUBCLASS_ELIXIR))
+                    {
+                        // if is WATER
+                        if (pItemTemplate->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+                            pItemTemplate->Spells[0].SpellCategory == 4)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+
+Item *PlayerbotAI::FindPotion() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+            if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if (pItemTemplate->IsPotion())
+            {
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+                    if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if (pItemTemplate->IsPotion())
+                    {
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+
+
+Item *PlayerbotAI::FindBandage() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+            if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_BANDAGE) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag)
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                    if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_BANDAGE) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+// finds poison starting from the front
+Item *PlayerbotAI::FindPoisonForward() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+            if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag && pBag->IsBag())
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                    if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+// finds poison starting from the back
+Item *PlayerbotAI::FindPoisonBackward() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_END; slot > INVENTORY_SLOT_ITEM_START; slot--)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+            if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if(pItemTemplate->Class == ITEM_CLASS_GLYPH) continue;
+            if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_END; bag > INVENTORY_SLOT_BAG_START; --bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag && pBag->IsBag())
+        {
+            for(uint8 slot = pBag->GetBagSize(); slot > 0  ; --slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                    if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if(pItemTemplate->Class == ITEM_CLASS_GLYPH) continue;
+                    if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket *const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);
+    uint8 counter = 1;
+    *packet << counter;
+    *packet << m_CurrentlyCastingSpellId;
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast()
+{
+    //stand up if we are done feasting
+    if(!(m_bot->GetHealth() < m_bot->GetMaxHealth() || (m_bot->getPowerType() == POWER_MANA && m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA))))
+    {
+        m_TimeDoneDrinking = time(0) - 1;
+        m_TimeDoneEating = time(0) - 1;
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+
+    //wait 3 seconds before checking if we need to drink more or eat more
+    time_t currentTime = time(0);
+    SetIgnoreUpdateTime(3);
+
+    //should we drink another
+    if(m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking && ((static_cast<float>(m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8))
+    {
+        Item *pItem = FindDrink();
+        if(pItem != NULL && !m_bot->HasSpellCooldown(pItem->GetSpell()))
+        {
+            UseItem(*pItem);
+            m_TimeDoneDrinking = currentTime + 30;
+            return;
+        } else {
+
+            // find a mage
+            if (m_FeastSpamTimer > 0) --m_FeastSpamTimer;
+            else {
+                Player *mage = GetClassAI()->FindMage(m_bot);
+                if (mage != NULL) {
+                    SendWhisper("I could use a drink.", *mage);
+                }
+                TellMaster("I need water.");
+                m_FeastSpamTimer=100;
+            }
+        }
+    }
+
+    //should we eat another
+    if(currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking  && ((static_cast<float>(m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8))
+    {
+        Item *pItem = FindFood();
+        if(pItem != NULL && !m_bot->HasSpellCooldown(pItem->GetSpell()))
+        {
+            UseItem(*pItem);
+            m_TimeDoneEating = currentTime + 30;
+            return;
+        }
+        //TellMaster("I need food."); //Disabled, tends to be horribly spammy.
+    }
+
+    //if we are no longer eating or drinking
+    //because we are out of items or we are above 80% in both stats
+    if(currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking)
+    {
+        //TellMaster("I'm ready, let's go.");
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+}
+
+Unit *PlayerbotAI::getNextTarget(Unit *victim)
+{
+    Unit *target = NULL;
+    AttackerSet m_attackers = victim->getAttackers();
+    if(!m_attackers.empty())
+    {
+        for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+        {
+            if(*iter && m_bot->GetDistance((*iter)) < 30)
+            {
+                target = *iter;
+                break;
+            } //end if
+        } //end for
+    }
+    return target;
+} //end getNextTarget
+
+//intelligently sets a reasonable combat order for this bot
+//based on its class / level / etc
+void PlayerbotAI::GetCombatOrders()
+{
+    if(m_bot->isDead() || isLooting) return;
+    Unit *thingToAttack=0;
+
+    // check raid targets icons
+   if (!thingToAttack)
+    {
+        Group *group = m_bot->GetGroup();
+        uint64 targetGUID = group->GetTargetWithIconByGroup (m_bot->GetGUID());
+        if (targetGUID>0)
+        {
+            thingToAttack = ObjectAccessor::GetUnit(*m_master, targetGUID);
+            if (!thingToAttack || thingToAttack->isDead() || !m_bot->IsHostileTo(thingToAttack)) thingToAttack=0;
+//else sLog->outError ("%s is attacking %s", m_bot->GetName(), thingToAttack->GetName());
+        }
+    }
+
+    //check if someone wants to attack master or me
+    if (!thingToAttack) thingToAttack = getNextTarget(m_master);
+
+    if(!thingToAttack)
+        thingToAttack = getNextTarget(m_bot);
+
+    //check master's target
+    if(!thingToAttack)
+    {
+        Unit *const pTarget = ObjectAccessor::GetUnit(*m_master, m_master->GetSelection());
+        if(pTarget && pTarget->isInCombat() && pTarget->IsHostileTo(m_master))
+            thingToAttack = pTarget;
+    }
+
+    //last try to find something to attack
+    if(!thingToAttack)
+    {
+        Unit *pUnit = NULL;
+        Trinity::NearestHostileUnitInAttackDistanceCheck u_check((Creature*)m_bot, 30.0);
+        Trinity::UnitLastSearcher<Trinity::NearestHostileUnitInAttackDistanceCheck> searcher(m_bot, pUnit, u_check);
+        m_bot->VisitNearbyObject(30, searcher);
+        if(pUnit != NULL && pUnit->isAlive() && pUnit->IsHostileToPlayers()) thingToAttack = pUnit;
+    }
+
+
+    //if the thing to attack is a world invisible trigger, ex Glyph in UBRS,
+    //default to master's current victim
+    if(!thingToAttack || thingToAttack->GetUInt32Value(UNIT_FIELD_DISPLAYID) == 11686) thingToAttack = m_master->getVictim();
+
+    //if the thing to attack is an invisible trigger ex vazruden in Hellfire Ramparts,
+    //default to master's current victim
+    if(!thingToAttack || !thingToAttack->IsVisible()) thingToAttack = m_master->getVictim();
+    // if the thing to attack is not attackable
+    if (!thingToAttack || thingToAttack->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE)) thingToAttack = NULL;
+
+    // override all others if ordered to pull
+    if (m_bot->GetPlayerbotAI()->GetClassAI()->isPulling()) {
+        thingToAttack = ObjectAccessor::GetUnit(*m_master,m_master->GetSelection());
+    }
+
+    if(!thingToAttack)
+    {
+        if(GetClassAI() && !m_bot->isInCombat()) (GetClassAI())->DoNonCombatActions();
+        return;
+    }
+
+    //wait till it gets closer
+    //if(m_bot->GetDistance(thingToAttack) > 30) return;
+
+    //if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    //this method never gets called when the bot is in a duel and this code
+    //prevents bot from helping
+    if(thingToAttack->GetTypeId() == TYPEID_PLAYER && ((Player*)(thingToAttack))->duel)
+    {
+       SetIgnoreUpdateTime(6);
+        return;
+    }
+
+    m_bot->SetSelection(thingToAttack->GetGUID());
+    SetIgnoreUpdateTime(1);
+    m_combatOrder = ORDERS_KILL;
+
+    if(m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    m_bot->Attack(thingToAttack, true);
+
+    if(thingToAttack->GetTypeId() != TYPEID_PLAYER)
+    {
+        //add thingToAttack to loot list
+        CreatureTemplate const *creatureInfo = ((Creature *)thingToAttack)->GetCreatureInfo();
+        if(creatureInfo && creatureInfo->lootid) m_lootCreature.push_back(thingToAttack->GetGUID());
+    }
+
+    return;
+}
+
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    if(isLooting) return;
+
+    Unit *const pTarget = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+
+    //if current order doesn't make sense anymore
+    //clear our orders so we can get orders in next update
+    if((!pTarget || pTarget->isDead() || !pTarget->IsInWorld() ||
+        !m_bot->IsHostileTo(pTarget) || pTarget->IsPolymorphed() || m_bot->isDead()
+        || ( !m_master->isInCombat() && !m_bot->isInCombat() && !pTarget->isInCombat()) // The mob probably is in evade mode, stop combat..
+        //|| pTarget->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE)
+        ) &&
+        !m_bot->GetPlayerbotAI()->GetClassAI()->isPulling() )
+    {
+        m_combatOrder = ORDERS_NONE;
+        m_bot->SetSelection(0);
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->InterruptNonMeleeSpells(true);
+//sLog->outError ("current target doesn't make sense so following");
+        Follow(*m_master);
+        return;
+    }
+
+    if(GetClassAI())
+    {
+        if(m_bot->HasUnitState(UNIT_STAT_CASTING))
+        {
+            return;
+        }
+
+        GetClassAI()->DoNextCombatManeuver(pTarget);
+    }
+}
+
+//this is where the AI should go
+//GetRandomContactPoint
+//GetPower, GetMaxPower
+//HasSpellCooldown
+//IsAffectedBySpellmod
+//isMoving
+//HasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
+//hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 p_time)
+{
+    time_t currentTime = time(0);
+    uint32 currentClock = getMSTime();
+    m_bot->UpdateZone(m_bot->GetZoneId(), m_bot->GetAreaId());
+
+    if (m_playerBotsFly==0 && m_master->isInFlight())
+    {
+        if (m_IsFollowingMaster)
+        {
+            const WorldLocation fakeloc = WorldLocation(35, -0.873190f, 52.920242f, -27.550674f, 1.655620f);
+            PlayerbotChatHandler ch(m_master);
+            if (! ch.teleport(*m_bot, fakeloc))
+            {
+                ch.sysmessage(".. could not be teleported ..");
+                return;
+            }
+            m_bot->SendUpdateToPlayer(m_master);
+       }
+        Stay();
+        return;
+    }
+
+    if(m_TimeRessurect == 0 && m_bot->isDead())
+    {
+        m_IsFollowingMaster = false;
+        m_TimeRessurect = currentTime + 30;
+        return;
+    }
+    else if(m_TimeRessurect > currentTime && m_bot->isDead())
+    {
+        return;
+    }
+    else if((!m_TimeRessurect == 0) && m_TimeRessurect <= currentTime && m_bot->isDead())
+    {
+        m_IsFollowingMaster = true;
+        m_TimeRessurect = 0;
+    }
+    if(((int64)m_ignoreAIUpdatesUntilTime - (int64)currentClock) > (int64) 30000) { SetIgnoreUpdateTime(2); return; } // Fix Timer overflow and AI freeze (max limit 30 secs)
+    if(currentClock < m_ignoreAIUpdatesUntilTime || m_bot->IsBeingTeleported() || m_bot->GetTrader()) return;
+
+
+    //default updates occur every 1.5 seconds
+    SetIgnoreUpdateTime(1.5);
+
+    // prevent cheating
+    if (!m_bot->GetGroup())
+    {
+        m_master->GetSession()->LogoutPlayerBot(m_bot->GetGUID(), false);
+        return;
+    }
+
+    if(m_bot->isDead()) isLooting = false;
+
+    /*
+     * combat checks
+     */
+    if(m_master <= 0 || ((m_master->isInCombat() || m_bot->isInCombat()) && m_bot->isDead())) return; //You're DEAD, stop thinking.
+
+    //if we are casting a spell then interrupt it
+    //make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+    Spell *const pSpell = GetCurrentSpell();
+    if(pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat())) InterruptCurrentCastingSpell();
+
+    //direct cast command from master
+    else if(m_spellIdCommand != 0)
+    {
+        Unit *pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+        if(pTarget != NULL) CastSpell(m_spellIdCommand, pTarget);
+        m_spellIdCommand = 0;
+        m_targetGuidCommand = 0;
+    }
+
+    else if(m_combatOrder != ORDERS_NONE) DoNextCombatManeuver(); //handle combat
+
+    else if (m_bot->GetPlayerbotAI()->GetClassAI()->isPulling())
+    {
+        GetCombatOrders();
+        return;
+    }
+
+    //if master is in combat and bot is not, automatically assist master
+    //NOTE: combat orders are also set via incoming packets to bot or outgoing packets from master
+    else if(m_master->isInCombat() && (!m_bot->isInCombat() || m_combatOrder == ORDERS_NONE) || m_master->isDead()) GetCombatOrders();
+
+    //if bot is in combat but master is not, attack
+    else if(m_bot->isInCombat()) GetCombatOrders();
+
+    // if bot is not in combat, but main tank is
+    else if (!m_bot->isInCombat()) {
+       Unit *tank=m_classAI->FindMainTankInRaid(m_bot);
+       if (tank!=NULL && tank->isInCombat()) GetCombatOrders();
+
+    }
+
+    /*
+     * Non combat checks
+     */
+
+    //are we sitting, if so feast if possible
+/* TESTING */    if(m_bot->getStandState() == UNIT_STAND_STATE_SIT) {
+/* TESTING */sLog->outError ("%s - sitting so feast", m_bot->GetName());
+//
+/* TESTING */    }
+
+    //if commanded to follow master and not already following master then follow master
+    if(!m_bot->isInCombat() && m_IsFollowingMaster && m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE)
+    {
+        Follow(*m_master);
+
+    //do class specific non combat actions
+	} else if(!m_bot->isInCombat() && GetClassAI()) {
+        (GetClassAI())->DoNonCombatActions();
+    } if(!m_master->isInCombat())
+        DoLoot();
+
+
+    if (m_master->getStandState() == UNIT_STAND_STATE_SIT)
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_SIT);
+        m_bot->SendUpdateToPlayer(m_master);
+        Feast();
+    }
+    else if (m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0)) //Do no interrupt if bot is eating/drinking
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+
+
+    //try to catch if he is falling through the world.  This happens
+    //when zoning in/out of an instance
+    if(m_IsFollowingMaster && m_bot->GetMapId() != m_master->GetMapId() ||
+    //m_bot->GetZoneId() != m_master->GetZoneId() ||
+    (abs(abs(m_bot->GetPositionX()) - abs(m_master->GetPositionX())) > 90) ||
+    (abs(abs(m_bot->GetPositionY()) - abs(m_master->GetPositionY())) > 90) ||
+    (abs(abs(m_bot->GetPositionZ()) - abs(m_master->GetPositionZ())) > 50))
+    {
+//sLog->outError ("%s: %s is too far away so following", m_bot->GetName(), m_master->GetName());
+        Follow(*m_master);
+    }
+}
+
+
+void PlayerbotAI::KilledMonster(uint32 entry, uint64 guid)
+{
+   // isLooting = true;
+
+    if(m_master->isAlive() && m_IsFollowingMaster && !m_master->isInCombat())
+    {
+        if(!DoLoot())
+        {
+            float angle = rand_norm()*M_PI; //Generates random float between 0 and 3.14
+            float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10);
+
+            m_bot->GetMotionMaster()->Clear(true);
+            m_bot->GetMotionMaster()->MoveFollow(m_master, dist, angle);
+        }
+    }
+
+    // reset main tank every time we finish combat, just in case the
+    // original main tank died and got set to next tank.
+    //m_classAI->SetMainTank(NULL);
+}
+
+Spell *PlayerbotAI::GetCurrentSpell() const
+{
+    if(m_CurrentlyCastingSpellId == 0) return NULL;
+    Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+    return pSpell;
+}
+
+void PlayerbotAI::TellMaster(const std::string &text)
+{
+    SendWhisper(text, *m_master);
+}
+
+bool PlayerbotAI::CanBotsFly()
+{
+    if (m_playerBotsFly==0) return false;
+    else return true;
+}
+
+void PlayerbotAI::SendWhisper(const std::string &text, Player &player)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    m_bot->BuildPlayerChat(&data, CHAT_MSG_WHISPER_INFORM, text, LANG_UNIVERSAL);
+    player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player &player) const
+{
+    return player.GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId();
+}
+
+void PlayerbotAI::SetInFront(const Unit *obj)
+{
+    if(!m_bot->HasInArc(M_PI, obj))
+    {
+        m_bot->SetInFront(obj);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+}
+
+bool PlayerbotAI::CastSpell(const char *args)
+{
+    uint32 spellId = getSpellId(args);
+    return(spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{
+    if (!spellId) return false;
+
+    if (!m_bot->HasSpell(spellId)) {
+        return false;
+    }
+
+    const SpellEntry * pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CRITICAL: PBot Class %u - Non-existing Spell in Cast - [%u]", m_bot->getClass(), spellId);
+        std::stringstream ss;
+        ss << "Missing spell entry in CastSpell - ";
+        ss << spellId;
+        TellMaster(ss.str());
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    return CastSpell(pSpellInfo, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered);
+}
+
+bool PlayerbotAI::CastSpell(const SpellEntry * pSpellInfo, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{
+    if(!m_bot->isAlive()) return false;
+    if(!pSpellInfo)
+    {
+        sLog->outError ("%s: Missing spell entry in CastSpell Direct", m_bot->GetName());
+        TellMaster("Missing spell entry in CastSpell");
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    uint32 spellId = pSpellInfo->Id;
+    uint64 oldSel = m_bot->GetSelection();
+
+    // Auto Targeting
+    if (!target)
+    {
+        //NEGATIVE SPELL
+        if (SPELL_CUSTOM_ERROR_NONE & SPELL_ATTR0_CU_NEGATIVE)
+        {
+            if (m_bot->GetSelection() <= 0) return false;
+            else
+            {
+                target = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+                if (!target) return false;
+            }
+        }
+        else { target = m_bot; }
+    }
+
+    //Make the Checks
+
+    if (!triggered && checkFirst && !CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck) ) { return false; }
+    if ( m_bot->GetSelection() != target->GetGUID() ) { m_bot->SetSelection(target->GetGUID()); } //if target is different than selection apply it
+
+    m_bot->CastSpell(target, uint32(spellId), triggered); //CAST THE SPELL
+    if ( m_bot->GetSelection() != oldSel ) { m_bot->SetSelection(oldSel); } // Restore if target changed to cast
+
+    // Check if the casting started..
+    Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+    if(!pSpell) return false;
+
+    // Trigger Pseudo Global Cooldown and consider casttime
+    float GCD = 1.5f;
+    if (m_bot->getPowerType() == POWER_ENERGY) GCD = 1;
+    float psCastTime = ((float)pSpell->GetCastTime()) / 1000.0f;
+    if (psCastTime - GCD > -0.3f) GCD = 0.3f; //Global cooldown won't be an issiue for casts (0.3 secs is for safe next cast)
+    else { GCD -= psCastTime; } //Remaining GCD after cast..
+    //float psRecoveryTime = GetSpellRecoveryTime(pSpellInfo) / 1000;
+    //sLog->outDebug(LOG_FILTER_NETWORKIO, "Bot [%u] Start Spell [%u] Cast Time [%f]", m_bot->GetGUIDLow(), pSpellInfo->Id, psCastTime);
+    m_CurrentlyCastingSpellId = spellId;
+    //SetIgnoreUpdateTime(psCastTime + GCD);
+    SetIgnoreUpdateTime(psCastTime > GCD ? psCastTime : GCD);
+    return true;
+}
+
+bool PlayerbotAI::CanCast(uint32 spellId, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+     //if spellId == 0, it means that the bot is not high enough level to
+    //have learned the spell
+    if (!spellId) return false;
+    const SpellEntry * pSpellInfo = sSpellStore.LookupEntry(spellId);
+    if (!pSpellInfo)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CRITICAL: PBot Class %u - Non-existing Spell in Cast - [%u]", m_bot->getClass(), spellId);
+        std::stringstream ss;
+        ss << "Missing spell entry in CastSpell - ";
+        ss << spellId;
+        TellMaster(ss.str());
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    return CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);
+}
+
+bool PlayerbotAI::CanCast(const SpellEntry * pSpellInfo, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+    if (!pSpellInfo)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CRITICAL: PBot Class %u - Non-existing Spell in CastCheck - Direct SpellEntry", m_bot->getClass());
+        TellMaster("Missing spell entry in CastSpell");
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    uint32 spellId = pSpellInfo->Id;
+
+    // Auto Targeting
+    if (!target)
+    {
+        //NEGATIVE SPELL
+        if (SPELL_CUSTOM_ERROR_NONE & SPELL_ATTR0_CU_NEGATIVE)
+        {
+            if (m_bot->GetSelection() <= 0) return false;
+            else
+            {
+                target = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+                if (!target) return false;
+            }
+        }
+        else { target = m_bot; }
+    }
+
+    if (!m_bot->isAlive()) return false;
+    if (m_bot->HasSpellCooldown(spellId)) return false;
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) return false;
+    if (m_bot->IsMounted()) return false;
+
+    //cast existing aura over again?
+    if (!castExistingAura && target->HasAura(spellId, m_bot->GetGUID())) return false;
+
+    //Stances-forms and equipment REQs
+    if (!skipEquipStanceCheck)
+    {
+        uint32 formMask = (GetForm() ? 1 << (GetPlayerBot()->GetShapeshiftForm() - 1) : 0);
+        //sLog->outDebug(LOG_FILTER_NETWORKIO, "DEBUG: Spell [%u] - Form [%X] - Need Form [%X] - Not Form [%X]", pSpellInfo->Id, formMask, pSpellInfo->Stances, pSpellInfo->StancesNot );
+        if (pSpellInfo->Stances & formMask) { return true; }
+        if (pSpellInfo->StancesNot && pSpellInfo->StancesNot & formMask) { return false; }
+        //if (!m_bot->HasItemFitToSpellRequirements(pSpellInfo)) return false;
+    }
+/*
+    //Power Costs
+    const SpellSchoolMask pSpellSchool = GetSpellSchoolMask(pSpellInfo);
+    uint32 pPowerCost = CalculatePowerCost(pSpellInfo, m_bot, pSpellSchool);
+
+    if (skipEquipStanceCheck) { if (m_bot->GetPower((Powers)pSpellInfo->powerType) < pPowerCost) return false; } //Power check for Required PowerType (After changind stance, powertype may change, for druids)
+    else { if (m_bot->GetPower(m_bot->getPowerType()) < pPowerCost) return false; } //Power check for Current m_bot Power Type
+
+    //Distance / movement checks
+    const SpellRangeEntry * pSpellRange = sSpellRangeStore.LookupEntry(pSpellInfo->rangeIndex);
+    float curDistance = m_bot->GetDistance(target);
+    if (GetSpellCastTime(pSpellInfo) > 0 && m_bot->isMoving()) return false; //Cannot cast while moving
+
+    //The target is immune or not?
+    if (target->GetTypeId() != TYPEID_PLAYER) { if ( ((Creature*)target)->IsImmunedToSpell(pSpellInfo)) { return false; } }
+    else { if (target->IsImmunedToSpell(pSpellInfo)) { return false; } }
+
+    //target reaction checks (Has problems with dual effect spells like death coil/holy shock)
+    if (skipFriendlyCheck)
+    {
+        if (pSpellRange->maxRangeHostile != 0) { if ( pSpellRange->maxRangeHostile < curDistance || pSpellRange->minRangeHostile > curDistance ) { return false; } } //Assume hostile spell
+    }
+    else if (IsPositiveSpell(spellId))
+    {
+        if(! m_bot->IsFriendlyTo(target)) { return false; }
+        else if (pSpellRange->maxRangeFriend != 0) { if (pSpellRange->maxRangeFriend < curDistance || pSpellRange->minRangeFriend > curDistance) { return false; } }
+        else if (curDistance > MELEE_RANGE) return false;
+    }
+    else
+    {
+        if (m_bot->IsFriendlyTo(target))  return false;
+        if (!m_bot->HasInArc(M_PI,target)) return false; //target is not in front
+        if (pSpellRange->maxRangeHostile != 0) { if ( pSpellRange->maxRangeHostile < curDistance || pSpellRange->minRangeHostile > curDistance ) { return false; } }
+        else if (curDistance > MELEE_RANGE) return false; //Out of range - Melee Range
+    }*/
+
+    return true;
+}
+
+uint8 PlayerbotAI::GetForm(Unit *pPlayer)
+{
+    if (!pPlayer) pPlayer = m_bot;
+    return (pPlayer->GetUInt32Value(UNIT_FIELD_BYTES_2) & 0xFF000000) >> (4 * 6);
+}
+
+//extracts all item ids in format below
+//I decided to roll my own extractor rather then use the one in ChatHandler
+//because this one works on a const string, and it handles multiple links
+//|color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string &text, std::list<uint32> &itemIds) const
+{
+    uint8 pos = 0;
+    while(true)
+    {
+        int i = text.find("Hitem:", pos);
+        if(i == -1) break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if(endPos == -1) break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if(id) itemIds.push_back(id);
+    }
+}
+
+bool PlayerbotAI::extractGOinfo(const std::string& text, uint32 &guid, uint32 &entry, int &mapid, float &x, float &y, float &z) const
+{
+
+   //    Link format
+   //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':' << x << ':' << y << ':' << z  << ':' << mapid << ':' <<  "|h[" << gInfo->name << "]|h|r";
+
+     //    |cFFFFFF00|Hfound:5093:1731:-9295:-270:81.874:0:|h[Copper Vein]|h|r
+  uint8 pos = 0;
+      // extract GO guid
+       int i = text.find("Hfound:", pos); // base H = 11
+       if (i == -1) // break if error
+            return false;
+
+       pos = i + 7; //start of window in text 11 + 7 = 18
+      int endPos = text.find(':', pos); // end of window in text 22
+      if (endPos == -1) //break if error
+           return false;
+       std::string guidC = text.substr(pos, endPos - pos); // get string within window i.e guid 22 - 18 =  4
+       guid = atol(guidC.c_str()); // convert ascii to long int
+     // extract GO entry
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string entryC = text.substr(pos, endPos - pos); // get string within window i.e entry
+        entry = atol(entryC.c_str()); // convert ascii to float
+     // extract GO x
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+       std::string xC = text.substr(pos, endPos - pos); // get string within window i.e x
+
+        x = atof(xC.c_str()); // convert ascii to float
+      // extract GO y
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string yC = text.substr(pos, endPos - pos); // get string within window i.e y
+      y = atof(yC.c_str()); // convert ascii to float
+     // extract GO z
+
+        pos = endPos + 1;
+       endPos = text.find(':', pos); // end of window in text
+        if (endPos == -1) //break if error
+           return false;
+
+       std::string zC = text.substr(pos, endPos - pos); // get string within window i.e z
+
+        z = atof(zC.c_str()); // convert ascii to float
+
+      //extract GO mapid
+       pos = endPos + 1;
+       endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string mapidC = text.substr(pos, endPos - pos); // get string within window i.e mapid
+       mapid = atoi(mapidC.c_str()); // convert ascii to int
+        pos = endPos; // end
+      return true;
+}
+
+//extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string &text) const
+{
+    //if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for(uint8 i = 0; i < text.length(); i++)
+    {
+        if(text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if(text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if(text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if(text[i] == ' ')
+        {
+            break;
+        }
+        else if(text[i] >= 48 && text[i] <= 57)
+        {
+            acum += text[i];
+        } else {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for( uint8 slot=EQUIPMENT_SLOT_START; itemIdSearchList.size()>0 && slot<EQUIPMENT_SLOT_END; slot++ ) {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if( !pItem )
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetTemplate()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+
+//finds items in inventory and adds Item *to foundItemList
+//also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    //look for items in main bag
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem) continue;
+        for(std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if(pItem->GetTemplate()->ItemId != *it) continue;
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    //for all for items in other bags
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(!pBag) continue;
+        for(uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item *const pItem = m_bot->GetItemByPos(bag, slot);
+            if(!pItem) continue;
+            for(std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if(pItem->GetTemplate()->ItemId != *it) continue;
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+bool PlayerbotAI::HasPick()
+{
+    QueryResult result;
+
+    // list out equiped items
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if (pItem )
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+
+                if (!pItemTemplate )
+                    continue;
+
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemTemplate->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "[%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot); // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+            if (!pItemTemplate )
+                continue;
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemTemplate->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag); // 255, 20 to 23
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "[%s's]bag[%u] slot = %u",m_bot->GetName(),bag,slot); // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+
+                    if (!pItemTemplate )
+                        continue;
+
+                    result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemTemplate->ItemId);
+                    if (result)
+                    {
+
+                        Field *fields = result->Fetch();
+                        uint32 tc = fields[0].GetUInt32();
+                        // sLog->outDebug(LOG_FILTER_NETWORKIO, "HasPick %u",tc);
+                        if(tc ==  165 || tc == 167)
+                            return true;
+                    }
+                }
+            }
+        }
+    }
+    std::ostringstream out;
+    out << "|cffffffffI do not have a pick!";
+    TellMaster( out.str().c_str() );
+    return false;
+}
+
+
+//submits packet to use an item
+void PlayerbotAI::PoisonWeapon(Item &item, uint32 _spellId, uint32 _target, EquipmentSlots weaponSlot)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = _spellId;
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; //??
+    uint8 unk_flags = 0; //not 0x02
+
+    uint32 target = _target;
+    uint32 targetItemGUID = 0;
+    uint8 x = 0;
+    Item *weapon=NULL;
+    if (_spellId>0){
+
+        targetItemGUID = 16;
+        x = 135;
+        cast_count = 7;
+        weapon = GetPlayerBot()->GetItemByPos( INVENTORY_SLOT_BAG_0, weaponSlot );
+
+    }
+
+    WorldPacket *const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1 + 4);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+    if (weapon) packet->appendPackGUID(weapon->GetGUID());
+
+    m_bot->GetSession()->QueuePacket(packet); //queue the packet to get around race condition
+
+} // end PoisonWeapon
+
+
+
+//submits packet to use an item
+void PlayerbotAI::UseItem(Item &item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = 0; //only used in combat
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; //??
+    uint8 unk_flags = 0; //not 0x02
+
+    //create target data
+    //note other targets are possible but not supported at the moment
+    //see SpellCastTargets::read in Spell.cpp to see other options
+    //for setting target
+
+    uint32 target = CAST_FLAG_NONE;
+
+    WorldPacket *const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+    m_bot->GetSession()->QueuePacket(packet); //queue the packet to get aroundrace condition
+
+} // end UseItem
+
+
+//submits packet to use an item
+void PlayerbotAI::EquipItem(Item &item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+
+    WorldPacket *const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+    *packet << bagIndex << slot;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI::TradeItem]: slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+        slot,
+        (m_bot->GetTrader()?1:0),
+        (item.IsInTrade()?1:0),
+        (item.CanBeTraded()?1:0)
+        );
+
+    if (!m_bot->GetTrader() || item.IsInTrade())
+        return false;
+
+    int8 tradeSlot = -1;
+
+    if( (slot>=0 && slot<TRADE_SLOT_COUNT) /* && m_bot->GetItem(trade slot)==NULL_SLOT */) {
+        tradeSlot = slot;
+    } else if (!item.CanBeTraded())
+    {
+        tradeSlot = (uint8) TRADE_SLOT_NONTRADED;
+    }
+    else
+    {
+        for( uint8 i=0; i<TRADE_SLOT_TRADED_COUNT; ++i )
+        {
+			if (m_bot->GetTradeData()->GetItem(TradeSlots(i)) == NULL){
+                tradeSlot = (uint8)i;
+                break;
+			}
+        }
+    }
+
+    if( tradeSlot == -1 ) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+            << (uint8) item.GetSlot();
+    m_bot->GetSession()->QueuePacket(packet);
+
+    return true;
+}
+
+
+//submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if(copper > 0)
+    {
+        WorldPacket *const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+void PlayerbotAI::Stay()
+{
+    if (!m_IsFollowingMaster)
+        return;
+
+    m_IsFollowingMaster = false;
+    m_bot->GetMotionMaster()->Clear(true);
+    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+}
+
+
+bool PlayerbotAI::Follow(Player &player)
+{
+    if(m_master <= 0 || ((m_master->isInCombat() || m_bot->isInCombat()) && m_bot->isDead())) return false; //You're DEAD, stop thinking.
+    if(m_master->isDead()) return false;
+    if(m_master->IsBeingTeleported() || m_master->isInFlight()) return false;
+
+    if(m_bot->getStandState() == UNIT_STAND_STATE_SIT && (m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0))) return false; //Do no interrupt if bot is eating/drinking
+
+    m_IsFollowingMaster = true;
+
+    if(!m_bot->IsStandState()) {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+
+    if(!m_bot->isInCombat())
+    {
+        //if bot is dead and master is alive, revive bot
+        if(m_master->isAlive() && !m_bot->isAlive())
+        {
+            SetIgnoreUpdateTime(6);
+            isLooting = false;
+            PlayerbotChatHandler ch(m_master);
+            if(!ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return false;
+            }
+        }
+
+        if(!m_bot->isDead() && !m_bot->IsBeingTeleported() && !player.isDead() &&
+            (m_bot->GetMapId() != player.GetMapId()
+            || m_bot->GetZoneId() != player.GetZoneId()
+            || m_bot->GetAreaId() != player.GetAreaId()
+            || m_bot->GetPhaseMask() != player.GetPhaseMask())
+            || m_bot->GetDistance(player) > 255)
+            {
+                SetIgnoreUpdateTime(6);
+                isLooting = false;
+                PlayerbotChatHandler ch(m_master);
+                if(!ch.teleport(*m_bot))
+                {
+                    ch.sysmessage(".. could not be teleported ..");
+                    return false;
+                }
+        }
+    }
+
+    if(m_bot->isAlive() && !isLooting)
+    {
+        float angle = M_PI/2 + rand_norm()*M_PI ; //Generates random float between 90 and 270 degrees
+        float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10); // Using urand to get a random float is stupid.
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->GetMotionMaster()->MoveFollow(&player, dist, angle);
+
+        return true;
+    }
+    return false;
+}
+
+//handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string &text, Player &fromPlayer)
+{
+    //ignore any messages from Addons
+    if(text.empty() ||
+        text.find("X-Perl") != std::wstring::npos ||
+        text.find("HealBot") != std::wstring::npos ||
+        text.find("LOOT_OPENED") != std::wstring::npos ||
+        text.find("CTRA") != std::wstring::npos)
+        return;
+
+    //if message is not from a player in the masters account auto reply and ignore
+    if(!canObeyCommandFrom(fromPlayer))
+    {
+        std::string msg = "I can't talk to you. Please speak to my master ";
+        msg += m_master->GetName();
+        msg += ".";
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+        SendWhisper(msg, fromPlayer);
+    }
+
+
+    else if (text == "I could use a drink." &&
+             m_bot->getClass() == CLASS_MAGE)
+    {
+            Item const*pItem = FindDrink();
+            if (pItem != NULL) {
+                WorldPacket *p = new WorldPacket(CMSG_INITIATE_TRADE, 8);
+                *p << fromPlayer.GetGUID();
+                m_bot->GetSession()-> HandleInitiateTradeOpcode(*p);
+                SendWhisper ("Here is a tasty treat for you", fromPlayer);
+
+            }
+    }
+    // accept food/drink from mage
+    else if (text == "Here is a tasty treat for you")
+    {
+        m_bot->Say ("Thank you for this treat", LANG_UNIVERSAL);
+        SendWhisper ("Thank you for this treat.", fromPlayer);
+    }
+    // trade opened so send items over
+    else if (text == "Thank you for this treat")
+    {
+        if (m_bot->getClass()!=CLASS_MAGE) return;
+
+        Item const*pItem = FindDrink();
+        if (pItem==NULL) return;
+
+        bool trade = TradeItem (*pItem,2);
+        if (trade) {
+            m_bot->Say("Enjoy the refreshing drink.", LANG_UNIVERSAL);
+
+			WorldPacket* const packet = new WorldPacket(CMSG_ACCEPT_TRADE, 3);
+			m_bot->GetSession()->QueuePacket(packet);  // packet is not used
+        } else {
+            m_bot->Say ("I cannot trade with you.", LANG_UNIVERSAL);
+        }
+    }
+
+    // if in the middle of a trade, and player asks for an item/money
+    else if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID() &&
+        fromPlayer.GetPlayerbotAI() == NULL)
+    {
+        uint32 copper = extractMoney(text);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            findItemsInEquip(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+                TradeItem(**it);
+        }
+    }
+
+
+
+    else if(text == "follow" || text == "come")
+        Follow(*m_master);
+
+    else if(text == "stay" || text == "stop")
+        Stay();
+
+    //handle cast command
+    else if(text.size() > 2 && text.substr(0, 2) == "c " ||
+        text.size() > 5 && text.substr(0, 5) == "cast ")
+        {
+            uint32 spellId = 0;
+            std::string spellStr = text.substr(text.find(" ") + 1);
+
+            if(spellStr.find("Hspell:"))
+            {
+                spellStr = spellStr.substr(spellStr.find("|h[") + 3);
+                spellStr = spellStr.substr(0, spellStr.find("]"));
+            } else
+                spellId = (uint32)atol(spellStr.c_str());
+
+            //try and get spell ID by name
+            if(spellId == 0) spellId = getSpellId(spellStr.c_str(), true);
+
+            uint64 castOnGuid = fromPlayer.GetSelection();
+            if(castOnGuid == 0) castOnGuid = m_bot->GetGUID();
+            if(spellId != 0)
+            {
+                m_spellIdCommand = spellId;
+                m_targetGuidCommand = castOnGuid;
+            }
+    }
+
+    //use items
+    else if(text.size() > 2 && text.substr(0, 2) == "u " ||
+    text.size() > 4 && text.substr(0, 4) == "use ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it) UseItem(**it);
+    }
+
+    // poison mainhand weapon
+    else if(text.size() > 2 && text.substr(0, 2) == "p " ||
+    text.size() >= 8 && text.substr(0, 8) == "poison m")
+    {
+
+        Item *poison = FindPoisonForward();
+        if(poison == NULL) {
+            std::string msg = "No poison found for mainhand.";
+            SendWhisper(msg, fromPlayer);
+            return;
+        }
+
+        PoisonWeapon(*poison, poison->GetTemplate()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_MAINHAND);
+    }
+
+    // poison offhand weapon
+    else if(text.size() >= 8 && text.substr(0, 8) == "poison o")
+    {
+
+        Item *poison = FindPoisonBackward();
+        if(poison == NULL) {
+            std::string msg = "No poison found for offhand.";
+            SendWhisper(msg, fromPlayer);
+            return;
+        }
+
+        PoisonWeapon(*poison, poison->GetTemplate()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_OFFHAND);
+    }
+
+    //equip items
+    else if(text.size() > 2 && text.substr(0, 2) == "e " ||
+    text.size() > 6 && text.substr(0, 6) == "equip ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+         for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it) EquipItem(**it);
+    }
+
+    else if(text == "spells")
+    {
+        int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+        std::string alreadySeenList = ",";
+
+        for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            const uint32 spellId = itr->first;
+
+            if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || SPELL_ATTR0_PASSIVE)
+                continue;
+
+            const SpellEntry *const pSpellInfo = sSpellStore.LookupEntry(spellId);
+            if(!pSpellInfo)
+                continue;
+
+            //|| name.find("Teleport") != -1
+
+            std::string comp = ",";
+            comp.append(pSpellInfo->SpellName[loc]);
+            comp.append(",");
+
+            if(!(ignoreList.find(comp) == std::string::npos &&
+                alreadySeenList.find(comp) == std::string::npos))
+                continue;
+
+            alreadySeenList += pSpellInfo->SpellName[loc];
+            alreadySeenList += ",";
+
+            /*if(IsPositiveSpell(spellId))
+                posOut << " |cffffffff|Hspell:" << spellId << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+            else
+                negOut << " |cffffffff|Hspell:" << spellId << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";*/
+        }
+
+        ChatHandler ch(&fromPlayer);
+        SendWhisper("Here's my non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("Here's my attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+
+    else if (text.size() > 13 && text.substr(0,13) == "accept quest ")
+    {
+        uint32 questId = 0;
+        std::string questStr = text.substr(text.find(" ") + 1);
+        questStr = questStr.substr(questStr.find(" ") + 1);
+        std::string questStrLink = questStr;
+        if (questStr.find("Hquest:"))
+        {
+            questStr = questStr.substr(questStr.find("|h[") + 3);
+            questStr = questStr.substr(0, questStr.find("]"));
+        }
+        else
+            questId = (uint32)atol(questStr.c_str());
+
+        // try and get quest ID by name
+        if (questId == 0)
+            questId = getQuestId(questStr.c_str(), 0);
+        std::ostringstream out;
+        out << "Quest " << questId << " " << questStr.c_str();
+
+        PlayerbotChatHandler ch(m_master);
+        uint64 oldSel = 0;
+        if (m_master->GetSelection())
+            oldSel = m_master->GetSelection();
+        m_master->SetSelection(m_bot->GetGUID());
+        if (questId != 0 && ch.acceptQuest(questStrLink.c_str()))
+        {
+            out << " accepted.";
+            TellMaster(out.str());
+        }
+        else
+        {
+            out << " not accepted.";
+            TellMaster(out.str());
+        }
+        if (oldSel > 0)
+            m_master->SetSelection(oldSel);
+    }
+
+    else if (text.size() > 14 && text.substr(0,14) == "abandon quest ")
+    {
+        uint32 questId = 0;
+        std::string questStr = text.substr(text.find(" ") + 1);
+        questStr = questStr.substr(questStr.find(" ") + 1);
+        std::string questStrLink = questStr;
+        if (questStr.find("Hquest:"))
+        {
+            questStr = questStr.substr(questStr.find("|h[") + 3);
+            questStr = questStr.substr(0, questStr.find("]"));
+        }
+        else
+            questId = (uint32)atol(questStr.c_str());
+
+        // try and get quest ID by name
+        if (questId == 0)
+            questId = getQuestId(questStr.c_str(), 1);
+        std::ostringstream out;
+        out << "Quest " << questId << " " << questStr.c_str();
+
+        PlayerbotChatHandler ch(m_master);
+        uint64 oldSel = 0;
+        if (m_master->GetSelection())
+            oldSel = m_master->GetSelection();
+        m_master->SetSelection(m_bot->GetGUID());
+        if (questId != 0 && ch.abandonQuest(questStrLink.c_str()))
+        {
+            out << " abandoned.";
+            TellMaster(out.str());
+        }
+               else
+        {
+            out << " not abandoned.";
+            TellMaster(out.str());
+        }
+        if (oldSel > 0)
+            m_master->SetSelection(oldSel);
+    }
+
+    else if (text.size() == 1 && text.substr(0,1) == "q" ||
+        text == "quests")
+    {
+        std::ostringstream out;
+        for (QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+        {
+            const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+            if (!qInfo)
+                continue;
+            QuestStatusData *qData = &iter->second;
+
+            uint32 questId = qInfo->GetQuestId();
+            const std::string name = qInfo->GetTitle();
+            if (name.empty())
+                continue;
+            //out << qData->m_status << " ";
+            if (qData->m_status == QUEST_STATUS_NONE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " no status" << "\n";
+                continue;
+            }
+            else if (qData->m_status == QUEST_STATUS_COMPLETE)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " complete" << "\n";
+            }
+            else if (qData->m_status == QUEST_STATUS_UNAVAILABLE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " unavailable" << "\n";
+                continue;
+            }
+            else if (qData->m_status == QUEST_STATUS_INCOMPLETE)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " incomplete" << "\n";
+            }
+            else if (qData->m_status == QUEST_STATUS_AVAILABLE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " available" << "\n";
+                continue;
+            }
+            else if (qData->m_status == QUEST_STATUS_FAILED)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " failed" << "\n";
+            }
+            else
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " unknown" << "\n";
+                continue;
+            }
+        }
+        if (!out.str().empty())
+            TellMaster(out.str());
+    }
+
+    else if (text == "train")
+    {
+         Unit *unit = m_master->GetSelectedUnit();
+
+         if (!unit)
+         {
+             TellMaster("Please select the trainer which I should learn  from!");
+             return;
+         }
+         if (!unit->isTrainer())
+         {
+             TellMaster("This is not a trainer!");
+             return;
+         }
+
+         Creature *creature =  m_bot->GetMap()->GetCreature(m_master->GetSelection());
+         if(!creature->isCanTrainingOf(m_bot, false))
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         CreatureTemplate const *creatureInfo = creature->GetCreatureInfo();
+
+         if (!creatureInfo)
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         TrainerSpellData const* trainer_spells =  creature->GetTrainerSpells();
+         if(!trainer_spells)
+         {
+             TellMaster("No training spells can be found from this  trainer");
+             return;
+         }
+         // reputation discount
+         float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+         bool can_learn_primary_prof =  m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+         std::ostringstream msg;
+         msg << "I had learnt the following spells:\n";
+         uint32 totalCost = 0;
+         uint32 totalSpellLearnt = 0;
+         int loc = m_master->GetSession()->GetSessionDbcLocale();
+         for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+         {
+             TrainerSpell const* tSpell = &itr->second;
+
+             bool valid = true;
+             bool primary_prof_first_rank = false;
+             for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+             {
+                 if (!tSpell->learnedSpell[i])
+                     continue;
+                  if(!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+                 {
+                     valid = false;
+                     break;
+                 }
+                 //if  (sSpellMgr->IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell[i]))
+                     primary_prof_first_rank = true;
+             }
+             if (!valid)
+                 continue;
+
+             TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+             if (state != TRAINER_SPELL_GREEN)
+             {
+                 continue;
+             }
+             //data << uint32(primary_prof_first_rank &&  can_learn_primary_prof ? 1 : 0);
+             uint32 spellId = tSpell->spell;
+             const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+             if (!pSpellInfo)
+             {
+                 continue;
+             }
+             uint32 cost = (uint32) (floor(tSpell->spellCost *  fDiscountMod));
+
+             // check money requirement
+             if(m_bot->GetMoney() < cost )
+                 continue;
+
+             m_bot->ModifyMoney( -int32(cost) );
+
+             // learn explicitly or cast explicitly
+             if(tSpell->IsCastable())
+                 //FIXME: prof. spell entry in trainer list not marked  gray until list re-open.
+                 m_bot->CastSpell(m_bot,tSpell->spell,true);
+             else
+                 m_bot->learnSpell(spellId,false);
+             totalSpellLearnt++;
+             totalCost = totalCost + cost;
+
+             msg << " |cffffffff|Hspell:" << spellId <<  "|h[" << pSpellInfo->SpellName[loc] << "]|h|r" <<  ", ";
+             uint32 gold = uint32(cost / 10000);
+             cost -= (gold * 10000);
+             uint32 silver = uint32(cost / 100);
+             cost -= (silver * 100);
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << cost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+         }
+
+         uint32 gold = uint32(totalCost / 10000);
+         totalCost -= (gold * 10000);
+         uint32 silver = uint32(totalCost / 100);
+         totalCost -= (silver * 100);
+         msg << "Total of " << totalSpellLearnt << "  spell(s) learnt, ";
+         if (gold > 0)
+         {
+             msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+         }
+         if (silver > 0)
+         {
+             msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+         }
+         msg << totalCost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t spent.";
+
+         TellMaster(msg.str());
+
+         m_bot->GetPlayerbotAI()->GetClassAI()->LoadSpells();
+
+    }
+    else if (text == "train list")
+    {
+         Unit *unit = m_master->GetSelectedUnit();
+
+         if (!unit)
+         {
+             TellMaster("Please select the trainer which I should learn  from!");
+             return;
+         }
+         if (!unit->isTrainer())
+         {
+             TellMaster("This is not a trainer!");
+             return;
+         }
+
+         Creature *creature =  m_bot->GetMap()->GetCreature(m_master->GetSelection());
+         if(!creature->isCanTrainingOf(m_bot, false))
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         CreatureTemplate const *creatureInfo = creature->GetCreatureInfo();
+
+         if (!creatureInfo)
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         TrainerSpellData const* trainer_spells =  creature->GetTrainerSpells();
+         if(!trainer_spells)
+         {
+             TellMaster("No training spells can be found from this  trainer");
+             return;
+         }
+         // reputation discount
+         float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+         bool can_learn_primary_prof =  m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+         std::ostringstream msg;
+         msg << "The spells I can learn and their costs are:\n";
+         uint32 totalCost = 0;
+         int loc = m_master->GetSession()->GetSessionDbcLocale();
+         for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+         {
+             TrainerSpell const* tSpell = &itr->second;
+
+             bool valid = true;
+             bool primary_prof_first_rank = false;
+             for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+             {
+                 if (!tSpell->learnedSpell[i])
+                     continue;
+                  if(!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+                 {
+                     valid = false;
+                     break;
+                 }
+                 //if  (sSpellMgr->IsPrimaryProfessionFirstRankSpell(tSpell->learnedSpell[i]))
+                     primary_prof_first_rank = true;
+             }
+             if (!valid)
+                 continue;
+
+             TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+             if (state != TRAINER_SPELL_GREEN)
+             {
+                 continue;
+             }
+             //data << uint32(primary_prof_first_rank &&  can_learn_primary_prof ? 1 : 0);
+             uint32 spellId = tSpell->spell;
+             const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+             if (!pSpellInfo)
+             {
+                 continue;
+             }
+             uint32 cost = (uint32) (floor(tSpell->spellCost *  fDiscountMod));
+             totalCost = totalCost + cost;
+
+             uint32 gold = uint32(cost / 10000);
+             cost -= (gold * 10000);
+             uint32 silver = uint32(cost / 100);
+             cost -= (silver * 100);
+             msg << " |cffffffff|Hspell:" << spellId <<  "|h[" << pSpellInfo->SpellName[loc] << "]|h|r" <<  ", ";
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << cost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+         }
+         uint32 moneyDiff = m_bot->GetMoney() - totalCost;
+         if (moneyDiff >= 0)
+         {
+             uint32 gold = uint32(moneyDiff / 10000);
+             moneyDiff -= (gold * 10000);
+             uint32 silver = uint32(moneyDiff / 100);
+             moneyDiff -= (silver * 100);
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << moneyDiff <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t left.";
+             }
+         else
+         {
+             moneyDiff = moneyDiff * (-1);
+             uint32 gold = uint32(moneyDiff / 10000);
+             moneyDiff -= (gold * 10000);
+             uint32 silver = uint32(moneyDiff / 100);
+             moneyDiff -= (silver * 100);
+             msg << "I need ";
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << moneyDiff <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t more to learn all the  spells!";
+         }
+         TellMaster(msg.str());
+
+    }
+ else if(text.size() >= 4 && text.substr(0, 4) == "sell")
+    {
+        Unit *unit = m_master->GetSelectedUnit();
+
+        if (!unit)
+        {
+            TellMaster("Please show me who I should trade with!");
+            return;
+        }
+        if (!unit->isVendor())
+        {
+            TellMaster("This person does not want to trade with me!");
+            return;
+        }
+        if (!m_bot->IsInMap((WorldObject*) unit))
+        {
+            TellMaster("I'm too far away to sell items!");
+            return;
+        }
+        uint32 TotalCost = 0;
+        uint32 TotalSold = 0;
+        std::ostringstream report;
+
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+        {
+            if ((**it).GetTemplate()->SellPrice > 0)
+            {
+                int32 cost = (**it).GetCount() * (**it).GetTemplate()->SellPrice;
+                m_bot->ModifyMoney(cost);
+                m_bot->MoveItemFromInventory((**it).GetBagSlot(), (**it).GetSlot(), true);
+
+                TotalSold = TotalSold + 1;
+                TotalCost = TotalCost + cost;
+
+                if ((**it).GetCount() > 0) {
+                    report << "Sold " << (**it).GetCount() << "x";
+                    report << " |cffffffff|Hitem:" << (**it).GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << (**it).GetTemplate()->Name1 << "]|h|r";
+                    report << " for ";
+
+                    uint32 gold = uint32(cost / 10000);
+                    cost -= (gold * 10000);
+                    uint32 silver = uint32(cost / 100);
+                    cost -= (silver * 100);
+
+                    if (gold > 0)
+                    {
+                        report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                    }
+                    if (silver > 0)
+                    {
+                        report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                    }
+                    report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                }
+            }
+        }
+        if (TotalSold > 0) {
+            report << "Sold total " << TotalSold << " item(s) for ";
+
+            uint32 gold = uint32(TotalCost / 10000);
+            TotalCost -= (gold * 10000);
+            uint32 silver = uint32(TotalCost / 100);
+            TotalCost -= (silver * 100);
+
+            if (gold > 0)
+            {
+                report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+            }
+            if (silver > 0)
+            {
+                report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+            }
+            report << TotalCost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t.";
+            TellMaster(report.str());
+        }
+    }
+
+ else if (text.size() > 2 && text.substr(0, 2) == "g " || text.size() > 4 && text.substr(0, 4) == "get ")
+ {
+     uint32 guid;
+     float x,y,z;
+     uint32 entry;
+     int mapid;
+     if (extractGOinfo(text, guid, entry, mapid, x, y, z))
+     {
+         sLog->outDebug(LOG_FILTER_NETWORKIO, "find: guid : %u entry : %u x : (%f) y : (%f) z : (%f) mapid : %d",guid, entry, x, y, z, mapid);
+         m_lootCurrent = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+         GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+         if (!go)
+         {
+             m_bot->Say("I can't find it.", LANG_UNIVERSAL);
+             m_lootCurrent = 0;
+             return;
+         }
+
+         if ( !go->isSpawned() ) {
+             m_bot->Say("It is not there anymore.", LANG_UNIVERSAL);
+             return;
+         }
+
+         m_bot->UpdateGroundPositionZ(x,y,z);
+         m_bot->GetMotionMaster()->MovePoint( mapid, x, y, z );
+         m_bot->UpdatePosition(x, y, z, m_bot->GetOrientation());
+         m_bot->SendLoot( m_lootCurrent, LOOT_CORPSE );
+         Loot *loot = &go->loot;
+         uint32 lootNum = loot->GetMaxSlotInLootFor( m_bot );
+
+         sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: GetGOType %u - %s looting: '%s' got %d items", go->GetGoType(), m_bot->GetName(), go->GetGOInfo()->name, loot->GetMaxSlotInLootFor( m_bot ));
+         for ( uint32 l=0; l<lootNum; l++ )
+         {
+             QuestItem *qitem=0, *ffaitem=0, *conditem=0;
+             LootItem *item = loot->LootItemInSlot( l, m_bot, &qitem, &ffaitem, &conditem );
+             if ( !item )
+                 continue;
+
+             if ( !qitem && item->is_blocked )
+             {
+                 m_bot->SendLootRelease( m_lootCurrent );
+                 continue;
+             }
+
+             if ( m_needItemList[item->itemid]>0 )
+             {
+                 ItemPosCountVec dest;
+                 if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count ) == EQUIP_ERR_OK )
+                 {
+                     Item * newitem = m_bot->StoreNewItem( dest, item->itemid, true, item->randomPropertyId);
+                     if ( qitem )
+                     {
+                         qitem->is_looted = true;
+                         if ( item->freeforall || loot->GetPlayerQuestItems().size() == 1 )
+                             m_bot->SendNotifyLootItemRemoved( l );
+                         else
+                             loot->NotifyQuestItemRemoved( qitem->index );
+                     }
+                     else
+                     {
+                         if ( ffaitem )
+                         {
+                             ffaitem->is_looted=true;
+                             m_bot->SendNotifyLootItemRemoved( l );
+                         }
+                         else
+                         {
+                             if ( conditem )
+                                 conditem->is_looted=true;
+                             loot->NotifyItemRemoved( l );
+                         }
+                     }
+                     if (!item->freeforall)
+                         item->is_looted = true;
+                     --loot->unlootedCount;
+                     m_bot->SendNewItem( newitem, uint32(item->count), false, false, true );
+
+                     m_bot->GetAchievementMgr().UpdateAchievementCriteria( ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count );
+                 }
+             }
+             uint32 lockId = go->GetGOInfo()->GetLockId();
+             LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+             if(lockInfo)
+             {
+                 uint32 skillId = SkillByLockType(LockType(lockInfo->Index[0]));
+                 switch(skillId)
+                 {
+                 case SKILL_MINING:
+                     if (m_bot->HasSkill(SKILL_MINING) && HasPick()) // Has skill & suitable pick
+                     {
+                         ItemPosCountVec dest;
+                         if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK )
+                         {
+                             Item* pItem = m_bot->StoreNewItem (dest,item->itemid,true,item->randomPropertyId);
+                             uint32 reqSkillValue = lockInfo->Skill[0];
+                             uint32 SkillValue = m_bot->GetPureSkillValue(SKILL_MINING);
+                             if (SkillValue >= reqSkillValue)
+                             {
+                                 m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+                                 m_bot->UpdateGatherSkill(SKILL_MINING, SkillValue, reqSkillValue);
+                                 --loot->unlootedCount;
+                             }
+                         }
+                     }
+                     break;
+                 case SKILL_HERBALISM:
+                     if (m_bot->HasSkill(SKILL_HERBALISM)) // Has skill
+                     {
+                         ItemPosCountVec dest;
+                         if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK )
+
+                         {
+                             Item* pItem = m_bot->StoreNewItem (dest,item->itemid,true,item->randomPropertyId);
+                             uint32 reqSkillValue = lockInfo->Skill[0];
+                             uint32 SkillValue = m_bot->GetPureSkillValue(SKILL_HERBALISM);
+                             if (SkillValue >= reqSkillValue)
+                             {
+                                 m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+                                 m_bot->UpdateGatherSkill(SKILL_HERBALISM, SkillValue, reqSkillValue);
+                                 --loot->unlootedCount;
+                             }
+                         }
+                     }
+                     break;
+                 }
+             }
+         }
+         // release loot
+         m_bot->GetSession()->DoLootRelease( m_lootCurrent );
+
+         // clear movement target, take next target on next update
+         m_bot->GetMotionMaster()->Clear();
+         m_bot->GetMotionMaster()->MoveIdle();
+         sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent );
+         SetQuestNeedItems();
+     }
+     else
+         SendWhisper("I have no info on that object", fromPlayer);
+ }
+
+ else if (text == "survey")
+ {
+      float distance = 100.0f;
+      uint32 count = 0;
+      std::ostringstream detectout;
+
+      QueryResult result = WorldDatabase.PQuery("SELECT guid, id, position_x, position_y, position_z, map, "
+        "(POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) AS order_ "
+        "FROM gameobject WHERE map='%u' AND (POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) <= '%f' ORDER BY order_",
+         m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(),
+         m_bot->GetMapId(), m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), distance*distance);
+
+      if (result)
+      {
+         do
+         {
+             Field *fields = result->Fetch();
+             uint32 guid = fields[0].GetUInt32();
+             uint32 entry = fields[1].GetUInt32();
+             float x = fields[2].GetFloat();
+             float y = fields[3].GetFloat();
+             float z = fields[4].GetFloat();
+             int mapid = fields[5].GetUInt16();
+
+             GameObjectTemplate const * goinfo = sObjectMgr->GetGameObjectTemplate(entry);
+
+             if(!goinfo)
+                 continue;
+
+             uint64 objGuid = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+             GameObject *go = m_bot->GetMap()->GetGameObject(objGuid);
+             if ( !go || (go && !go->isSpawned()) ) continue;
+
+             if(count < 12) // count, limits number of links
+                  detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry << ":" << x << ":" << y << ":" << z  << ":" << mapid  << ":" <<  "|h[" << goinfo->name << "]|h|r";
+             ++count;
+         } while (result->NextRow());
+
+      }
+      SendWhisper(detectout.str().c_str(), fromPlayer);
+    }
+
+    else if (text == "pull")
+    {
+        m_bot->GetPlayerbotAI()->GetClassAI()->Pull();
+    }
+    else if(text == "help")
+    {
+        std::string msg;
+        if (m_bot->getClass() == CLASS_ROGUE)
+            msg = "The commands I respond to are \n follow, stay, (c)ast <spellname>, spells, (e)quip, (u)se,\n(q)uests, accept quest <hlink>, abandon quest <hlink>\npoison [main | off].\ntrain list";
+        else
+            msg = "The commands I respond to are \n follow, stay, (c)ast <spellname>, spells, (e)quip, (u)se,\n(q)uests, accept quest <hlink>, abandon quest <hlink>\ntrain list.";
+
+        SendWhisper(msg, fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+      else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            uint64 questRewarderGUID = m_bot->GetSelection();
+            Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*m_bot, questRewarderGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.GetMenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.QuestId;
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    ! m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                {
+                    for (uint8 rewardIdx=0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                            std::string questTitle  = pQuest->GetTitle();
+                            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            std::ostringstream out;
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
+
+void PlayerbotAI::SetLooting(bool looting)
+{
+    isLooting = looting;
+}
+
+void PlayerbotAI::AddLootGUID(uint64 guid) {
+    m_lootCreature.push_back(guid);
+}
+
+bool PlayerbotAI::DoLoot()
+{
+    if(!m_lootCurrent && m_lootCreature.empty())
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s reset loot list / go back to idle", m_bot->GetName());
+//        SetQuestNeedItems();
+        isLooting = false;
+        return false;
+    }
+
+    if(m_bot->isDead())
+    {
+        isLooting = false;
+        return false;
+    }
+
+    if(!m_lootCurrent)
+    {
+        m_lootCurrent = m_lootCreature.front();
+
+        if(!m_lootCurrent)
+        {
+            //sLog->outError("PlayerbotAI::DoLoot() error location #1, please report this error immediately!");
+            return false;
+        }
+
+        Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+        GameObject *o = m_bot->GetMap()->GetGameObject( m_lootCurrent );
+
+        if(!c && !o)
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false;
+        }
+        if(c && c->isAlive())
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false; //not dead yet
+        }
+
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s got loot target 0x%08X", m_bot->GetName(), m_lootCurrent);
+        Position pos;
+
+        WorldObject *object;
+        if (c) object = c;
+        else object = o;
+
+        if(m_bot->IsWithinDistInMap(object, INTERACTION_DISTANCE * 3)){ //Verify if the bot it close to a loot.
+
+            m_lootCreature.pop_front();
+            object->GetPosition(&pos);
+            m_bot->GetMotionMaster()->MovePoint(object->GetMapId(), (const Position &)(pos));
+
+        } else { //Rotate the loot to very if one is not near the bot.
+
+            m_lootobjtemp = m_lootCreature.front();
+            m_lootCreature.pop_front();
+            m_lootCreature.push_back(m_lootobjtemp);
+            m_lootCurrent = 0;
+        }
+        return true;
+
+    } else {
+
+        Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+        GameObject *o = m_bot->GetMap()->GetGameObject( m_lootCurrent );
+        if(!c && !o)
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false;
+        }
+        if(c && c->isAlive())
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false; //not dead yet
+        }
+
+        WorldObject *object;
+        if (c) object = c;
+        else object = o;
+
+        if(m_bot->IsWithinDistInMap(object, INTERACTION_DISTANCE))
+        {
+            //check for needed items
+            m_bot->SendLoot(m_lootCurrent, LOOT_CORPSE);
+
+            Loot *loot;
+            if (c)
+                loot = &c->loot;
+            else
+                loot = &o->loot;
+
+            assert(loot);
+
+            uint32 lootNum = loot->GetMaxSlotInLootFor(m_bot);
+//sLog->outError("[PlayerbotAI]: %s loot target 0x%08X got %d items", m_bot->GetName(), m_lootCurrent, loot->GetMaxSlotInLootFor(m_bot));
+
+            for(uint32 l = 0; l < lootNum; ++l)
+            {
+                QuestItem *qitem = 0, *ffaitem = 0, *conditem = 0;
+                LootItem *item = loot->LootItemInSlot(l, m_bot, &qitem, &ffaitem, &conditem);
+                if(!item) continue;
+                if(!qitem && item->is_blocked)
+                {
+                    m_bot->SendLootRelease(m_bot->GetLootGUID());
+                    continue;
+                }
+
+                if(m_needItemList[item->itemid] > 0)
+                {
+//sLog->outError("[PlayerbotAI]: %s LOOT needed item 0x%04X", m_bot->GetName(), item->itemid);
+                    ItemPosCountVec dest;
+                    if(m_bot->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK)
+                    {
+                        Item *newitem = m_bot->StoreNewItem(dest, item->itemid,true, item->randomPropertyId);
+                        if(qitem)
+                        {
+                            qitem->is_looted = true;
+                            if(item->freeforall ||loot->GetPlayerQuestItems().size() == 1)
+                                m_bot->SendNotifyLootItemRemoved(l);
+                            else
+                                loot->NotifyQuestItemRemoved(qitem->index);
+                        }
+                        else if(ffaitem)
+                        {
+                            ffaitem->is_looted = true;
+                            m_bot->SendNotifyLootItemRemoved(l);
+                        } else {
+                            if(conditem) conditem->is_looted = true;
+                            loot->NotifyItemRemoved(l);
+                        }
+                        if(!item->freeforall) item->is_looted = true;
+                        --(loot->unlootedCount);
+                        m_bot->SendNewItem(newitem, uint32(item->count), false,false, true);
+                        m_bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
+
+                        std::ostringstream out;
+                        PlayerbotChatHandler ch(m_master);
+                        out << m_bot->GetName() << " needs " << m_needItemList[item->itemid]-1 << " more.";
+                        ch.sysmessage(out.str().c_str());
+                        m_ignoreAIUpdatesUntilTime = time(0);
+                    }
+                }
+            }
+            //release loot
+            if(uint64 lguid = m_bot->GetLootGUID() && m_bot->GetSession())
+                m_bot->GetSession()->DoLootRelease(lguid);
+            else if(!m_bot->GetSession())
+                sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s has no session. Cannot releaseloot!", m_bot->GetName());
+
+            //clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent);
+            m_lootCurrent = 0;
+            m_ignoreAIUpdatesUntilTime = time(0);
+            isLooting = false;
+        } else { //keep moving till we get there
+            Position pos;
+
+            if (c) {
+                c->GetPosition(&pos);
+                m_bot->GetMotionMaster()->MovePoint(c->GetMapId(), (const Position &)(pos));
+            } else {
+                o->GetPosition(&pos);
+                m_bot->GetMotionMaster()->MovePoint(o->GetMapId(), (const Position &)(pos));
+            }
+
+        }
+    }
+    return false;
+} //end DoLoot
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    //reset values first
+    m_needItemList.clear();
+    m_lootCreature.clear();
+    m_lootCurrent = 0;
+
+    //run through accepted quests, get quest infoand data
+    for(QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+    {
+        const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+        if(!qInfo) continue;
+        QuestStatusData *qData = &iter->second;
+
+        //only check quest if it is incomplete
+        if(qData->m_status != QUEST_STATUS_INCOMPLETE) continue;
+
+        //check for items we not have enough of
+        for(uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+        {
+            if(!qInfo->ReqItemCount[i] || (qInfo->ReqItemCount[i]-qData->m_itemcount[i]) <= 0) continue;
+            m_needItemList[qInfo->ReqItemId[i]] = (qInfo->ReqItemCount[i]-qData->m_itemcount[i]);
+        }
+    }
+}//end SetQuestNeedItems
+
+//Localization support
+void PlayerbotAI::ItemLocalization(std::string &itemName, const uint32 itemID) const
+{
+    int loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+    ItemLocale const *pItemInfo = sObjectMgr->GetItemLocale(itemID);
+    if(pItemInfo)
+    {
+        if(pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if(Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::QuestLocalization(std::string &questTitle, const uint32 questID) const
+{
+    int loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+    QuestLocale const *pQuestInfo = sObjectMgr->GetQuestLocale(questID);
+    if(pQuestInfo)
+    {
+        if(pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if(Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::TurnInQuests( WorldObject *pNpc )
+{
+
+    uint64 npcGUID = pNpc->GetGUID();
+    if (!m_bot->IsInMap((WorldObject*) pNpc))
+        m_bot->GetPlayerbotAI()->TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelection(npcGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(npcGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.QuestId;
+            Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+            std::ostringstream out;
+            std::string questTitle  = pQuest->GetTitle();
+            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+            // if quest is complete, turn it in
+            if (status == QUEST_STATUS_COMPLETE)
+            {
+                // if bot hasn't already turned quest in
+                if (! m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, pNpc, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemTemplate const *pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+
+                    // else multiple rewards - let master pick
+                    else {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i=0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewChoiceItemId[i]);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE) {
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+            }
+
+//            else if (status == QUEST_STATUS_AVAILABLE){
+  //              out << "|cff00ff00Quest available:|r "
+//                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+//            }
+
+            if (! out.str().empty())
+                m_bot->GetPlayerbotAI()->TellMaster(out.str());
+        }
+    }
+} // TurnInQuests
+
+
+ void PlayerbotAI::SetCombatOrder (CombatOrderType orders)
+ {
+    m_combatOrder = orders;
+ }
diff --git a/src/server/game/AI/PlayerBots/PlayerbotAI.h b/src/server/game/AI/PlayerBots/PlayerbotAI.h
new file mode 100644
index 0000000..e40d6ad
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotAI.h
@@ -0,0 +1,284 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Common.h"
+
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+
+enum ScenarioType
+{
+    SCENARIO_PVEEASY,
+    SCENARIO_PVEHARD,
+    SCENARIO_DUEL,
+    SCENARIO_PVPEASY,
+    SCENARIO_PVPHARD
+};
+
+//masters orders that should be obeyed by the AI during the updteAI routine
+//the master will auto set the target of the bot
+enum CombatOrderType
+{
+    ORDERS_NONE,
+    ORDERS_KILL,
+    ORDERS_CC,
+    ORDERS_HEAL,
+    ORDERS_TANK,
+    ORDERS_PROTECT,
+    ORDERS_REGEN
+};
+
+typedef std::set<Unit *> AttackerInfoList;
+
+class PlayerbotAI
+{
+public:
+    //******* Stuff the outside world calls ****************************
+    PlayerbotAI(Player *const master, Player *const bot);
+    virtual ~PlayerbotAI();
+
+    //This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    //This is called from ChatHandler.cpp when there is an incoming message to the bot
+    //from a whisper or from the party channel
+    void HandleCommand(const std::string &text, Player &fromPlayer);
+
+    //This is called by WorldSession.pm
+    //It provides a view of packets normally sent to the client.
+    //Since there is no client at the other end, the packets are dropped of course.
+    //For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+    void HandleBotOutgoingPacket(const WorldPacket &packet);
+
+    //This is called whenever the master sends a packet to the server.
+    //These packets can be viewed, but not edited.
+    //It allows bot creators to craft AI in response to a master's actions.
+    //For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
+    //Notice: that this is static which means it is called once for all bots of the master.
+    static void HandleMasterIncomingPacket(const WorldPacket &packet, WorldSession &masterSession);
+    static void HandleMasterOutgoingPacket(const WorldPacket &packet, WorldSession &masterSession);
+
+    //Returns what kind of situation we are in so the AI can react accordingly
+    ScenarioType GetScenarioType(){ return m_ScenarioType; }
+
+    PlayerbotClassAI *GetClassAI(){ return m_classAI; }
+
+    //protected:
+
+    //******* Utilities ***************************************************
+
+    //finds spell ID for matching substring args
+    //in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char *args, bool master=false) const;
+    //Main PlayerBot spell finding function Returns ONLY exact matches including Upper/Lower case differentiation.
+    uint32 getSpellIdExact(const char *args, bool includePassive=false, bool master=false);
+
+    // finds quest ID for matching substring args
+    uint32 getQuestId(const char* args, bool remove) const;
+
+    //extracts item ids from links
+    void extractItemIds(const std::string &text, std::list<uint32> &itemIds) const;
+
+    //extracts currency from a string as #g#s#c and returns the total in copper
+    uint32 extractMoney(const std::string &text) const;
+
+    // extracts gameobject info from link
+    bool extractGOinfo(const std::string& text, uint32 &guid,  uint32 &entry, int &mapid, float &x, float &y, float &z) const;
+
+    // finds items in equipment and adds Item* to foundItemList
+    // also removes found item IDs from itemIdSearchList when found
+    void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+    //finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+    //currently bots only obey commands from the master
+    bool canObeyCommandFrom(const Player &player) const;
+
+    //get current casting spell (will return NULL if no spell!)
+    Spell *GetCurrentSpell() const;
+
+    bool HasAura(uint32 spellId, const Unit *player) const;
+    bool HasAura(const char *spellName, const Unit *player) const;
+    bool HasAura(const char *spellName) const;
+    void HandleTeleportAck();
+
+    bool HasPick();
+
+    uint8 GetHealthPercent(const Unit &target) const;
+    uint8 GetHealthPercent() const;
+    uint8 GetBaseManaPercent(const Unit &target) const;
+    uint8 GetBaseManaPercent() const;
+    uint8 GetManaPercent(const Unit &target) const;
+    uint8 GetManaPercent() const;
+    uint8 GetRageAmount(const Unit &target) const;
+    uint8 GetRageAmount() const;
+    uint8 GetEnergyAmount(const Unit &target) const;
+    uint8 GetEnergyAmount() const;
+    uint8 GetRunicPower(const Unit &target) const;
+    uint8 GetRunicPower() const;
+
+    Item *FindFood() const;
+    Item *FindDrink() const;
+    Item *FindPotion() const;
+    Item *FindBandage() const;
+    Item *FindPoisonForward() const;    // finds poison starting from the front
+    Item *FindPoisonBackward() const;   // finds poison starting from the back
+
+    void UseMount() const;
+
+    //******* Actions ****************************************
+    //Your handlers can call these actions to make the bot do things.
+    void TellMaster(const std::string &text);
+    void SendWhisper(const std::string &text, Player &player);
+    bool CastSpell(const char *args);
+    //Player bots main spell cast function, if checkFirst > performs canCast() first, if castExistingAura > performs the cast even if the aura exists on target,
+    //if skipFriendlyCheck > do not perform spell positive/negative and target friendly/hostile checks (Useful for dual purpose spells like holy shock)
+    virtual bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    virtual bool CastSpell(const SpellEntry * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    //Simple Checks to determine if the bot can cast the spell or not...
+    //Mana/Stance/EquipmentRequirement/Distance/TargetInFront/OverwriteOrStackExistingAura/FriendlyFire checks
+    virtual bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    virtual bool CanCast(const SpellEntry * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    //Gets the current form/stance of player
+    uint8 GetForm(Unit *pPlayer=NULL);
+    void UseItem(Item &item);
+    void PoisonWeapon(Item &item, uint32 spellid=0, uint32 target=0, EquipmentSlots weapon=EQUIPMENT_SLOT_MAINHAND);
+    void EquipItem(Item &item);
+    void Stay();
+    bool Follow(Player &player);
+    void SendNotEquipList(Player &player);
+    void Feast();
+    void SetLooting(bool looting);
+    void InterruptCurrentCastingSpell();
+    void GetCombatOrders();
+    void DoNextCombatManeuver();
+    void KilledMonster(uint32 entry, uint64 guid);
+    void ItemLocalization(std::string &itemName, const uint32 itemID) const;
+    void QuestLocalization(std::string &questTitle, const uint32 questID) const;
+
+    uint32 GetAttackerCount(){ return m_attackerInfo.size(); }
+	void SetIgnoreUpdateTime(float t){m_ignoreAIUpdatesUntilTime=getMSTime() + (t * 1000); };
+
+    Player *GetPlayerBot(){ return m_bot; }
+    void SetInFront(const Unit *obj);
+
+    bool CanBotsFly();  // take the flight path?
+    uint32 GetStartMapID() { return m_startMapID; };
+    uint32 GetStartZoneID() { return m_startZoneID; };
+    uint32 GetStartAreaID() { return m_startAreaID; };
+    uint32 GetStartPhase() { return m_startPhase; };
+    uint32 GetStartDifficulty() { return m_startDifficulty; };
+    uint32 GetStartInstanceID() { return m_startInstanceID; };
+    float GetStartX() { return m_startX; };
+    float GetStartY() { return m_startY; };
+    float GetStartZ() { return m_startZ; };
+    float GetStartO() { return m_startO; };
+
+    void SetStartMapID(uint32 mapID) { m_startMapID = mapID; };
+    void SetStartZoneID(uint32 zoneID) { m_startZoneID = zoneID; };
+    void SetStartAreaID(uint32 areaID) { m_startAreaID = areaID; };
+    void SetStartPhase(uint32 phase) { m_startPhase = phase; };
+    void SetStartDifficulty(uint32 difficulty) { m_startDifficulty = difficulty; };
+    void SetStartInstanceID(uint32 instanceID) { m_startInstanceID = instanceID; };
+    void SetStartX(float x) { m_startX = x; };
+    void SetStartY(float y) { m_startY = y; };
+    void SetStartZ(float z) { m_startZ = z; };
+    void SetStartO(float o) { m_startO = o; };
+
+    void AddLootGUID(uint64 guid);
+    void SetCombatOrder (CombatOrderType orders);
+
+private:
+
+    //****** Closed Actions ********************************
+    //These actions may only be called at special times.
+    //Trade methods are only applicable when the trade window is open
+    //and are only called from within HandleCommand.
+    // submits packet to trade an item (trade window must already be open)
+
+    // default slot is -1 which means trade slots 0 to 5. if slot is set
+    // to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+    // 'Will not be traded' slot.
+    bool TradeItem(const Item& item, int8 slot=-1);
+
+    bool TradeCopper(uint32 copper);
+
+    //it is safe to keep these back reference pointers because m_bot
+    //owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    Player *const m_master;
+    Player *const m_bot;
+    PlayerbotClassAI *m_classAI;
+
+    //ignores AI updates until time specified
+    //no need to waste CPU cycles during casting etc
+    uint32 m_ignoreAIUpdatesUntilTime;
+
+    CombatOrderType m_combatOrder;
+
+    ScenarioType m_ScenarioType;
+    typedef std::set<Unit *> AttackerSet;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    time_t m_TimeRessurect;
+    uint32 m_CurrentlyCastingSpellId;
+    bool m_IsFollowingMaster;
+
+    //if master commands bot to do something, store here until updateAI
+    //can do it
+    uint32 m_spellIdCommand;
+    uint64 m_targetGuidCommand;
+
+    //finds who to attack next
+    Unit *getNextTarget(Unit *victim);
+
+    /* -- Loot routines by runsttren */
+    bool DoLoot();
+    void SetQuestNeedItems();
+
+    void TurnInQuests( WorldObject *questgiver );
+
+    typedef std::map<uint32, uint32> BotNeedItem;
+    typedef std::list<uint64> BotLootCreature;
+    typedef std::map<uint32, std::string> BotQuestsSeen;
+
+    //list of items needed to fullfill quests
+    BotNeedItem m_needItemList;
+
+    //list of items needed to fullfill quests
+    BotNeedItem m_needEmblemList;
+
+    //list of quests recently seen that we can accept
+    BotQuestsSeen m_questsSeen;
+
+    //list of creatures we recently attacked and want to loot
+    BotLootCreature m_lootCreature; //list of creatures
+    uint64 m_lootCurrent; //current remains of interest
+    uint64 m_lootobjtemp;
+    bool isLooting;
+    AttackerInfoList m_attackerInfo;
+
+    float m_followDistanceMin, m_followDistanceMax;
+    int m_playerBotsFly;
+
+    uint32 m_startMapID;
+    uint32 m_startZoneID;
+    uint32 m_startAreaID;
+    uint32 m_startPhase;
+    uint32 m_startDifficulty;
+    uint32 m_startInstanceID;
+    float m_startX;
+    float m_startY;
+    float m_startZ;
+    float m_startO;
+
+    uint32 m_FeastSpamTimer;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp
new file mode 100644
index 0000000..d3b5dda
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotClassAI.cpp
@@ -0,0 +1,596 @@
+/*
+Name :    PlayerbotClassAI.cpp
+Notes:    Does not really work with peldor's own classbot AIs
+        Contains many improvements and hacks to overcome some difficulites
+Known
+Problems:    - Contains hardcoded values,  for an example check group heal, individual heal decision
+            - ai->getSpellIdExact func, *although works more accurately* is probably slower and hackish
+            - FindMainTankRaid func, includes a db query making it a resource hog
+            - canCast func, does not check for every possible problem, can cause AI stuck.. Should be inside PlayerbotAI class
+            - castSpell func is redundant and should be placed in PlayerbotAI class, sets private variable m_ai->m_CurrentlyCastingSpellId which is made public as a hack..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotClassAI.h"
+#include "Common.h"
+#include "Spell.h"
+#include "Group.h"
+
+PlayerbotClassAI::PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai): m_master(master), m_bot(bot), m_ai(ai), rezSpamTimer(0)
+{
+    threatThreshold = 75;            // Threat % threshold for dps to lower tps
+    offensiveSpellThreshold = 70;    // Mana % threshold for healers to use offensive spells
+
+    // first aid
+    RECENTLY_BANDAGED = 11196; // first aid check
+
+    // RACIALS
+    R_ARCANE_TORRENT = ai->getSpellIdExact("Arcane Torrent");
+    R_BERSERKING = ai->getSpellIdExact("Berserking");
+    R_BLOOD_FURY = ai->getSpellIdExact("Blood Fury");
+    R_CANNIBALIZE = ai->getSpellIdExact("Cannibalize");
+    R_ESCAPE_ARTIST = ai->getSpellIdExact("Escape Artist");
+    R_EVERY_MAN_FOR_HIMSELF = ai->getSpellIdExact("Every Man for Himself");
+    R_GIFT_OF_NAARU = ai->getSpellIdExact("Gift of the Naaru");
+    R_SHADOWMELD = ai->getSpellIdExact("Shadowmeld");
+    R_STONEFORM = ai->getSpellIdExact("Stoneform");
+    R_WAR_STOMP = ai->getSpellIdExact("War Stomp");
+    R_WILL_OF_FORSAKEN = ai->getSpellIdExact("Will of the Forsaken");
+
+    mainTank = NULL;
+    m_pulling = false;
+}
+PlayerbotClassAI::~PlayerbotClassAI(){}
+
+void PlayerbotClassAI::DoNextCombatManeuver(Unit *){}
+
+void PlayerbotClassAI::DoNonCombatActions(){}
+
+void PlayerbotClassAI::LoadSpells(){}
+
+void PlayerbotClassAI::Pull(){}
+
+bool PlayerbotClassAI::BuffPlayer(Unit *target){ return false; }
+
+bool PlayerbotClassAI::FindMount(){ return true; }
+
+bool PlayerbotClassAI::Unmount(){ return true; }
+
+bool PlayerbotClassAI::HealTarget (Unit *target, uint8 hp){ return false; }
+
+bool PlayerbotClassAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal){ return false; }
+
+bool PlayerbotClassAI::CureTarget (Unit *target){ return false; }
+
+bool PlayerbotClassAI::RezTarget (Unit *target){ return false; }
+
+bool PlayerbotClassAI::IsMounted(){ return m_bot->IsMounted(); }
+
+bool PlayerbotClassAI::CastSpell(uint32 spellId, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{return m_ai->CastSpell(spellId, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered); }
+bool PlayerbotClassAI::CastSpell(const SpellEntry * pSpellInfo, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{return m_ai->CastSpell(pSpellInfo, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered);}
+
+bool PlayerbotClassAI::CanCast(uint32 spellId, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{return m_ai->CanCast(spellId, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);}
+
+bool PlayerbotClassAI::CanCast(const SpellEntry * pSpellInfo, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{return m_ai->CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);}
+
+bool PlayerbotClassAI::listAuras(Unit *u)
+{
+    int loc = 0;
+    Unit *target = u;
+    typedef std::pair<uint32, uint8> spellEffectPair;
+    typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+    Unit::AuraMap &vAuras = target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        //SpellEntry const *spellInfo = (*itr).second->GetSpellInfo();
+        const SpellInfo *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "aura = %u %s", spellInfo->Id, name.c_str());
+    }
+    return true;
+};//end listAuras
+
+bool PlayerbotClassAI::HasAuraName (Unit *unit, uint32 spellId, uint64 casterGuid)
+{
+    //const SpellInfo *const pSpellInfo = sSpellMgr->GetSpellInfo()->LookupEntry (spellId);
+	SpellInfo const* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if(!pSpellInfo) return false;
+    int loc = m_bot->GetSession()->GetSessionDbcLocale();
+    const std::string  name = pSpellInfo->SpellName[loc];
+    if(name.length() == 0) return false;
+    return HasAuraName(unit, name, casterGuid);
+}
+
+bool PlayerbotClassAI::HasAuraName (Unit *target, std::string spell, uint64 casterGuid)
+{
+    int loc = m_bot->GetSession()->GetSessionDbcLocale();
+    typedef std::pair<uint32, uint8>spellEffectPair;
+    typedef std::multimap<spellEffectPair, Aura*>AuraMap;
+
+    Unit::AuraMap &vAuras = target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        //SpellEntry const *spellInfo = (*itr).second->GetSpellInfo();
+        const SpellInfo *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        if(!spell.compare(name))
+        //if(!strcmp(name.c_str(),spell.c_str()))
+        {
+            if(casterGuid == 0) //don't care who casted it
+                return true;
+            else if(casterGuid == itr->second->GetCasterGUID()) //only if correct caster casted it
+                return true;
+        }
+    }
+    return false;
+};
+
+bool PlayerbotClassAI::castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+    if (dispelSpell == 0 || !dTarget ) return false;
+    //if (!canCast(dispelSpell, dTarget, true)) return false; //Needless cpu cycles wasted, usually a playerbot can cast a dispell
+    //const SpellEntry *dSpell = GetSpellStore()->LookupEntry(dispelSpell);
+	SpellInfo const* dSpell = sSpellMgr->GetSpellInfo(dispelSpell);
+    if (!dSpell) return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (dSpell->Effects[i].MiscValue != (uint32)SPELL_EFFECT_DISPEL) continue;
+        uint32 dispel_type = dSpell->Effects[i].MiscValue;
+        //uint32 dispelMask  = GetDispellMask(DispelType(dispel_type));
+        Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura * aura = itr->second;
+            AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+            if (!aurApp)
+                continue;
+
+            /*if ((1<<aura->GetSpellInfo()->Dispel) & dispellMask)
+            {*/
+                if(aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)
+                {
+                    bool positive = aurApp->IsPositive() ? (!(aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE)) : false;
+
+                    // do not remove positive auras if friendly target
+                    //               negative auras if non-friendly target
+                    if(positive == dTarget->IsFriendlyTo(GetPlayerBot()))
+                        continue;
+                }
+                // If there is a successfull match return, else continue searching.
+                //if (CastSpell(dSpell, dTarget, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck)) { return true; }
+            //}
+        }
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::castSelfCCBreakers (uint32 castList[])
+{
+    uint32 dispelSpell = 0;
+    Player *dTarget = GetPlayerBot();
+
+
+            /* dispelSpell = (uint32) R_ESCAPE_ARTIST; // this is script effect,
+            Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+            {
+                Aura * aura = itr->second;
+                AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+                if (!aurApp)
+                    continue;
+
+                if ( ( aura->GetSpellInfo()->Mechanic == MECHANIC_SNARE ) || ( aura->GetSpellInfo()->Mechanic == MECHANIC_ROOT ) )
+                {
+                    if(aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)
+                    {
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_UNK7)) : false;
+
+                        // do not remove positive auras if friendly target
+                        //               negative auras if non-friendly target
+                        if(positive == dTarget->IsFriendlyTo(caster))
+                            continue;
+                    }
+                    return castSpell(dispelSpell, dTarget);
+                }
+            }
+            return false;  */
+
+        // racial abilities
+    /*  if( GetPlayerBot()->getRace() == RACE_BLOODELF && !pTarget->HasAura( ARCANE_TORRENT,0 ) && castSpell( ARCANE_TORRENT,pTarget ) ) {
+         //GetPlayerBot()->Say("Arcane Torrent!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_HUMAN && (GetPlayerBot()->HasUnitState( UNIT_STAT_STUNNED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_FEAR ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_CHARM )) && castSpell( EVERY_MAN_FOR_HIMSELF, GetPlayerBot() ) ) {
+        //GetPlayerBot()->Say("EVERY MAN FOR HIMSELF!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_UNDEAD_PLAYER && (GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_FEAR ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_CHARM )) && castSpell( WILL_OF_THE_FORSAKEN, GetPlayerBot() ) ) {
+       // GetPlayerBot()->Say("WILL OF THE FORSAKEN!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_DWARF && GetPlayerBot()->HasAuraState( AURA_STATE_DEADLY_POISON ) && castSpell( STONEFORM, GetPlayerBot() ) ) {
+        //GetPlayerBot()->Say("STONEFORM!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_GNOME && (GetPlayerBot()->HasUnitState( UNIT_STAT_STUNNED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED )) && castSpell( ESCAPE_ARTIST, GetPlayerBot() ) ) {
+       // GetPlayerBot()->Say("ESCAPE ARTIST!", LANG_UNIVERSAL);
+    } */
+
+    for (uint8 j = 0; j <  sizeof (castList); j++)
+    {
+        dispelSpell = castList[j];
+        if (dispelSpell == 0 || !dTarget->HasSpell(dispelSpell) || !CanCast(dispelSpell, dTarget, true)) continue;
+        SpellInfo const *dSpell = sSpellMgr->GetSpellInfo(dispelSpell);
+        if (!dSpell) continue;
+
+       /*for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+        {
+            if (dSpell->Effect[i] != (uint32)SPELL_EFFECT_DISPEL && dSpell->Effect[i] != (uint32)SPELL_EFFECT_APPLY_AURA) continue;
+            if (dSpell->Effect[i] == (uint32)SPELL_EFFECT_APPLY_AURA && (
+                (dSpell->EffectApplyAuraName[i] != (uint32) SPELL_AURA_MECHANIC_IMMUNITY) ||
+                (dSpell->EffectApplyAuraName[i] != (uint32) SPELL_AURA_DISPEL_IMMUNITY)
+                )) continue;
+*/
+            Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+            {
+                Aura * aura = itr->second;
+                AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+                if (!aurApp) continue;
+
+               /* if (aura->GetSpellInfo() && (
+                    (dSpell->Effect[i] == (uint32)SPELL_EFFECT_DISPEL  && ((1<<aura->GetSpellInfo()->Dispel) & GetDispelMask(DispelType(dSpell->EffectMiscValue[i]))) )
+                    || (dSpell->EffectApplyAuraName[i] == (uint32) SPELL_AURA_MECHANIC_IMMUNITY && ( GetAllSpellMechanicMask(aura->GetSpellInfo()) & ( 1 << dSpell->EffectMiscValue[i]) ) )
+                    || (dSpell->EffectApplyAuraName[i] == (uint32) SPELL_AURA_DISPEL_IMMUNITY && ( (1<<aura->GetSpellInfo()->Dispel) & GetDispelMask(DispelType(dSpell->EffectMiscValue[i])) ) )
+                    ) )
+                {*/
+                    if(aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)
+                    {
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE)) : false;
+                        if(positive)continue;
+                    }
+                    return CastSpell(dispelSpell, dTarget, false);
+                //}
+            }
+        }return false;
+    }
+    
+
+
+bool PlayerbotClassAI::DoSupportRaid(Player *gPlayer, float radius, bool dResurrect, bool dGroupHeal, bool dHeal, bool dCure, bool dBuff)
+{
+    bool needHeal = false;
+    if (dGroupHeal || dHeal)
+    {
+        uint8 cntNeedHeal = 0;
+        uint8 raidHPPercent = GetHealthPercentRaid(gPlayer, cntNeedHeal);
+        if (dGroupHeal && raidHPPercent <=90 && cntNeedHeal > 1)
+        {
+            if (HealGroup(gPlayer, raidHPPercent, cntNeedHeal)) return true;
+        }
+        if (raidHPPercent < 60 ) needHeal = true;
+    }
+    //std::list<Unit*> unitList;
+    //gPlayer->GetRaidMember(unitList,30);
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return false;
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Unit* tPlayer = itr->getSource();
+        if(!tPlayer || gPlayer->IsHostileTo(tPlayer)) continue;
+        if(GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        if(!m_bot->IsWithinDistInMap(tPlayer, radius)) { continue; }
+        if(tPlayer->isDead()) // May be we can rez
+        {
+            if(!dResurrect) continue;
+            if(needHeal) continue; //First heal others needing heal
+            if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+            if(tPlayer->IsNonMeleeSpellCasted(true)) continue; //Already rez
+            if(RezTarget(tPlayer)) { return true; }
+            else continue;
+        }
+        if (dHeal)
+        {
+            uint8 tarHPPercent = tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth();
+            if (tarHPPercent < 100 && HealTarget(tPlayer, tarHPPercent)) return true;
+        }
+        if (needHeal && dHeal) continue; //First heal others needing heal
+        if (dCure && CureTarget(tPlayer)) return true;
+        if (dBuff && BuffPlayer(tPlayer)) return true;
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::TakePosition(Unit *followTarget, BotRole bRole, float bDist, float bMinDist, float bMaxDist, float bAngle, Unit *faceTarget)
+{
+    bool doFollow = true;
+    bool omitAngle = false;
+    bool angleIsAutoSet = false;
+    if (!bAngle) angleIsAutoSet = true;
+    if (bAngle < 0) bAngle += 2 * M_PI;
+    //if (bAngle > 2 * M_PI) bAngle -= 2 * M_PI; //Do not send values higher than 2 PI, lower than -2 PI
+    bool rval = false;
+    if (followTarget == NULL) { followTarget = GetMaster(); if (followTarget == NULL) { return false; } }
+    if (faceTarget == NULL) { faceTarget = followTarget; }
+    if (bRole == BOT_ROLE_NONE) { bRole = ( (m_role == BOT_ROLE_NONE) ? BOT_ROLE_DPS_MELEE : m_role);  }
+    //Default values
+    Unit *pVictim = followTarget->getVictim();
+    if (pVictim && pVictim->GetGUID() == m_bot->GetGUID()) //if target is attacking me
+    {
+        if (bRole == BOT_ROLE_TANK || bRole == BOT_ROLE_OFFTANK || bRole == BOT_ROLE_DPS_MELEE)
+        {
+            //Move to target
+            if (!bDist || bDist > 0.7f) bDist = 0.7f;
+            if (bMinDist < 0 || bMinDist > 1) bMinDist = 0;
+            if (bMaxDist <= 0 || bMaxDist > MELEE_RANGE) bMaxDist = MELEE_RANGE;
+            bAngle = 0;
+        }
+        else {doFollow = false;} //Do not move, creature will come
+    }
+    else
+    {
+        // calculating distance to follow
+        switch (bRole)
+        {
+            case BOT_ROLE_TANK:
+            case BOT_ROLE_OFFTANK:
+                if (!bDist) { bDist = 0.7f; bMinDist = 0; bMaxDist = MELEE_RANGE; bAngle = 0;}
+                break;
+            case BOT_ROLE_HEALER:
+            case BOT_ROLE_SUPPORT:
+                if (!bDist) { bDist = urand(12, 14); bMinDist = 10; bMaxDist = 18; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+            case BOT_ROLE_DPS_RANGED:
+                if (!bDist) { bDist = urand(18, 24); bMinDist = 10;  bMaxDist = 26; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+            default:
+                if (!bDist) { bDist = 0.7f; bMinDist = 0.1f; bMaxDist = MELEE_RANGE; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+        }
+    }
+    //Do not try to go behind if ranged and creature is not boss like
+    if (bDist > MELEE_RANGE && followTarget->GetTypeId() != TYPEID_PLAYER)
+    {
+        const CreatureTemplate *creatureInfo = ((Creature*) followTarget)->GetCreatureInfo();
+        if (!creatureInfo || creatureInfo->rank != 3) { omitAngle = true; }
+    }
+
+    //Move
+    if (doFollow)
+    {
+        float curDist = m_bot->GetDistance(followTarget);
+        if (m_pulling ||
+            (!m_bot->isMoving() &&
+            ((curDist > bMaxDist || curDist < bMinDist)  //Outside range boundries
+            || (!omitAngle && ((!followTarget->HasInArc(M_PI,m_bot)) ^ (bAngle > 0.5f * M_PI && bAngle < 1.5f * M_PI)))) )//is at right position front/behind?
+            )
+        {
+            //m_bot->GetMotionMaster()->Clear();
+            //sLog->outError("Bot[%u] is moving, curDist[%f], bDist[%f], bminDist[%f], bMaxDist[%f], bAngle[%f], InFront[%u]", m_bot->GetGUIDLow(), curDist, bDist,bMinDist, bMaxDist, bAngle, followTarget->HasInArc(M_PI,m_bot));
+            if (angleIsAutoSet && omitAngle) { m_bot->GetMotionMaster()->MoveChase(followTarget, bDist); }
+            else { m_bot->GetMotionMaster()->MoveChase(followTarget, bDist, bAngle); }
+            rval |= true;
+        }
+    }
+    //Face your faceTarget
+    if (!m_bot->HasInArc(M_PI/16, faceTarget) && !m_bot->isMoving() ) { m_bot->SetFacingToObject(faceTarget); rval |= true; }
+    return rval;
+}
+
+uint8 PlayerbotClassAI::GetThreatPercent(Unit *pTarget, Unit *pFrom)
+{
+    uint8 tPercent = 0;
+    Unit *pVictim = pTarget->getVictim();
+    if (!pVictim) return 100; //Not Attacking anyone yet, somehow..
+    if (!pFrom) { pFrom = m_bot; }
+    if (pVictim->GetGUID() == pFrom->GetGUID()) return 100; //I'm already being attacked, too late for alert, kill it..
+    //if (m_tank->GetGUID() == m_bot->GetGUID()) {} //If I am not tank and there is a target
+
+    ThreatManager &pthreatManager = pTarget->getThreatManager();
+    float maxThreat = pthreatManager.getThreat(pTarget->getVictim()) ;
+    if (maxThreat <= 0) { return 100; } //0 threat
+    float curThreat = pthreatManager.getThreat(pFrom);
+    return (curThreat * 100 / maxThreat);
+}
+//Gets if the unit is under attack by # of attackers
+bool PlayerbotClassAI::isUnderAttack(Unit *pAttacked,const uint8 &minNumberOfAttackers)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) { return false; } }
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() >= minNumberOfAttackers) { return true; }
+    return false;
+}
+
+//Gets the first found attacker of Unit
+Unit *PlayerbotClassAI::GetAttackerOf(Unit *pAttacked)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) { return NULL; } }
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() <= 0) { return NULL; }
+    return (*fAttackerSet.begin());
+}
+//Gets the first found attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+Unit *PlayerbotClassAI::GetNearestAttackerOf(Unit *pAttacked, bool nearestToAttacked)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) return NULL;}
+
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() <= 0) { return NULL; }
+
+    Unit *nearestTo = m_bot;
+    if (nearestToAttacked) { nearestTo = pAttacked; }
+
+    Unit *curAtt = NULL;
+    float minDist = 30;
+
+
+    for (Unit::AttackerSet::const_iterator itr = fAttackerSet.begin(); itr != fAttackerSet.end(); ++itr)
+    {
+        Unit *tAtt = (*itr);
+        if (!tAtt) break; // Something is wrong.. How can a non existing mob attack?
+        if (tAtt->isDead()) break;
+        if (m_bot->GetDistance(tAtt) >= minDist) continue; //Get the nearest one
+        curAtt = tAtt;
+        minDist = tAtt->GetDistance(nearestTo);
+    }
+    return curAtt;
+
+}
+
+uint8 PlayerbotClassAI::GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing)
+{
+    uint8 validMemberCount=0;
+    uint16 totalHPPercent=0;
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if(!unitList.empty()){
+      for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+        //Player *tPlayer = GetPlayerBot()->GetObjPlayer((*itr)->GetGUID());
+        Unit *tPlayer = ObjectAccessor::FindPlayer((*itr)->GetGUID());
+        if(tPlayer == NULL) continue;
+        if(tPlayer->isDead()) continue;
+        if(GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if(GetPlayerBot()->GetDistance(tPlayer) > 30) continue;
+        uint8 fndHPPercent =  tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth();
+        totalHPPercent+=fndHPPercent;
+        validMemberCount++;
+        if (fndHPPercent < 100) countNeedHealing++;
+
+        //const std::string myname = GetPlayerBot()->GetName();
+        //const std::string hisname = tPlayer->GetName();
+        //sLog->outDebug(LOG_FILTER_NETWORKIO, "me = %s, checked= %s %u [%u / %u]", myname.c_str(), hisname.c_str(), fndHPPercent, tPlayer->GetHealth(), tPlayer->GetMaxHealth());
+
+      }
+    }
+    if (validMemberCount == 0) return 100;
+    return totalHPPercent / validMemberCount;
+}
+
+Unit *PlayerbotClassAI::DoSelectLowestHpFriendly(float range, uint32 MinHPDiff)
+{
+    Unit *pUnit = NULL;
+    Trinity::MostHPMissingInRange u_check(GetPlayerBot(), range, MinHPDiff);
+    Trinity::UnitLastSearcher<Trinity::MostHPMissingInRange> searcher(GetPlayerBot(), pUnit, u_check);
+
+    GetPlayerBot()->VisitNearbyObject(range, searcher);
+
+    return pUnit;
+}
+
+void PlayerbotClassAI::SetMainTank(Unit *tank)
+{
+    mainTank = tank;
+}
+
+// is Resource heavy, do not spam or use heavily in loop
+Unit *PlayerbotClassAI::FindMainTankInRaid(Player *gPlayer)
+{
+    // check if original main tank is still alive. No point regetting main
+    // tank b/c chances are slim that it will not get reset in the middle of a fight.
+    // But if main tank dies, try to find next best canidate
+    if (mainTank!=NULL && mainTank->isAlive()) {
+        return mainTank;
+    }
+
+    if (!gPlayer) return NULL;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return NULL;
+    uint64 pLeaderGuid = pGroup->GetLeaderGUID();
+
+    Unit *pPlayer = NULL;
+
+    // Check if set in raid
+    if (pGroup->isRaidGroup())
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINTANK, pGroup->GetGUID());
+        if(result)
+        {
+            uint64 pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+            pPlayer = ObjectAccessor::FindPlayer(pGuid);
+            if (pPlayer && pGroup->IsMember(pGuid) && pPlayer->isAlive()){
+                mainTank = pPlayer;
+                return pPlayer;
+            }
+        }
+    }
+
+
+    // if could not find tank try assuming
+    // Assume the one with highest health is the main tank
+    uint32 maxhpfound=0;
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if (!unitList.empty()){
+      for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+        //Player *tPlayer = GetPlayerBot()->GetObjPlayer((*itr)->GetGUID());
+        Unit *tPlayer = ObjectAccessor::FindPlayer((*itr)->GetGUID());
+        if (tPlayer == NULL) continue;
+        if (tPlayer->isDead()) continue;
+        if (GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if (GetPlayerBot()->GetDistance(tPlayer) > 50) continue;
+        if (tPlayer->GetMaxHealth() > maxhpfound) { maxhpfound = tPlayer->GetMaxHealth(); pPlayer=tPlayer; }
+        // Also check pets
+        if ( (tPlayer->getClass() == (uint8) CLASS_HUNTER || tPlayer->getClass() == (uint8) CLASS_WARLOCK) && IS_PET_GUID(tPlayer->GetPetGUID()) )
+        {
+            Pet* tpet = ObjectAccessor::GetPet(*tPlayer, tPlayer->GetPetGUID());
+            if (!tpet || !tpet->IsInWorld() || !tpet->isDead()) continue;
+            if (tpet->GetArmor() > tPlayer->GetArmor()) //Probably a tanking capable pet..
+            {
+                if (tpet->GetMaxHealth() > maxhpfound) { maxhpfound = tpet->GetMaxHealth(); pPlayer=tpet; }
+                else if (tPlayer->GetGUID() == pPlayer->GetGUID()) {pPlayer = tpet;} //set pet as tank instead of owner
+            }
+        }
+      }
+    }
+
+    mainTank = pPlayer;
+    return pPlayer;
+}
+
+Unit *PlayerbotClassAI::FindMainAssistInRaid(Player *gPlayer)
+{
+    if (!gPlayer) return NULL;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return NULL;
+    uint64 pLeaderGuid = pGroup->GetLeaderGUID();
+
+
+    Unit *pPlayer = NULL;
+
+    // Check if set in raid
+    if (pGroup->isRaidGroup())
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINASSIST, pGroup->GetGUID());
+          if(result)
+        {
+            uint64 pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+            pPlayer = ObjectAccessor::FindPlayer(pGuid);
+            if (pPlayer && pGroup->IsMember(pGuid) && pPlayer->isAlive()){
+                return pPlayer;
+            }
+        }
+    }
+
+    // default to main tank
+    return FindMainTankInRaid(gPlayer);
+}
+
+Player * PlayerbotClassAI::FindMage(Player *gPlayer)
+{
+    Group::MemberSlotList const &groupSlot = gPlayer->GetGroup()->GetMemberSlots();
+    for(Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+
+        if(tPlayer == NULL) continue;
+        if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if(GetPlayerBot()->GetAreaId() != gPlayer->GetAreaId()) continue;
+        if(GetPlayerBot()->GetDistance(tPlayer) > 30) continue;
+
+        if (tPlayer->getClass() == CLASS_MAGE) return tPlayer;
+    }
+    return NULL;
+}
+
+
diff --git a/src/server/game/AI/PlayerBots/PlayerbotClassAI.h b/src/server/game/AI/PlayerBots/PlayerbotClassAI.h
new file mode 100644
index 0000000..5537b1d
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotClassAI.h
@@ -0,0 +1,162 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "Unit.h"
+#include "SharedDefines.h"
+#include "PlayerbotAI.h"
+#include "SpellAuras.h"
+#include "Cell.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+
+
+class Player;
+class PlayerbotAI;
+class Aura;
+
+        enum BotRole
+        {
+            BOT_ROLE_NONE,
+            BOT_ROLE_TANK,
+            BOT_ROLE_OFFTANK,
+            BOT_ROLE_DPS_RANGED,
+            BOT_ROLE_DPS_MELEE,
+            BOT_ROLE_SUPPORT,
+            BOT_ROLE_HEALER
+        };
+
+class PlayerbotClassAI
+{
+    public:
+        PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotClassAI();
+
+        //all combat actions go here
+        virtual void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        virtual void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        virtual bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        virtual bool HealTarget (Unit *target, uint8 hp);
+
+        //Heals the group based off its HP
+        virtual bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cure the target
+        virtual bool CureTarget (Unit *target);
+
+        //Resurrect the target (OBSOLETE - Check individual ClassAIs instead)
+        virtual bool RezTarget(Unit *target);
+
+        //find any specific mount spells, ie druids = cat, shaman = ghost wolf etc (OBSOLETE)
+        virtual bool FindMount();
+
+        virtual bool Unmount();
+
+        virtual bool IsMounted();
+
+        virtual void LoadSpells();
+
+        virtual void Pull();
+
+        //Utilities
+        Player *GetMaster (){ return m_master; }
+        Player *GetPlayerBot(){ return m_bot; }
+        PlayerbotAI *GetAI (){ return m_ai; }
+
+        bool isPulling() { return m_pulling; }
+        bool TakePosition(Unit *followTarget, BotRole bRole=BOT_ROLE_NONE, float bDist=0, float bMinDist=0, float bMaxDist=0, float bAngle=0, Unit *faceTarget=NULL);
+        //Gets the threat done by bot / threat max (percent) to the target.
+        uint8 GetThreatPercent(Unit *pTarget, Unit *pFrom = NULL);
+        //Gets if the unit is under attack by # of attackers
+        bool isUnderAttack(Unit *pAttacked=NULL,const uint8 &minNumberOfAttackers=1);
+        //Gets the first found attacker of Unit
+        Unit *GetAttackerOf(Unit *pAttacked=NULL);
+        //Gets the nearest attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+        Unit *GetNearestAttackerOf(Unit *pAttacked=NULL, bool nearestToAttacked=false);
+        //Calculates Average Raid Health condition as Percentage, ref value is the Count of units need healing..
+        uint8 GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing);
+
+        // Called when the main tank is set from raid ui
+        void SetMainTank (Unit *tank);
+
+        //Finds the possible MainTank in Raid including Hunter/Warlock pets.. Makes the assumption based on - max maxHealth..
+        Unit *FindMainTankInRaid(Player *gPlayer);
+
+        //Finds the possible MainAssist in Raid.  Defaults to Main Tank if it cannot find one.
+        Unit *FindMainAssistInRaid(Player *gPlayer);
+
+        Player *FindMage(Player *gPlayer);
+        //Finds the lowest hp creature around that is friendly with the caster.
+        Unit *DoSelectLowestHpFriendly(float range, uint32 MinHPDiff);
+
+
+        protected:
+        bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+        bool CastSpell(const SpellEntry * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+        bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+        bool CanCast(const SpellEntry * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+
+        //Debug method to list the auras currently active.
+        //Use to find what spells were casted
+        bool listAuras(Unit *unit);
+
+        //More generalized method than HasAura().  It looks for
+        //any rank of the spell and it doesn't care which
+        //spell effect you want.  If it has the spell aura than
+        //it returns true
+        bool HasAuraName(Unit *unit, std::string spell, uint64 casterGuid=0);
+        bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid=0);
+
+        //The following functions return true only a match is found and the bot successfully casted a spell to resolve the problem
+        //If the result is false, either a match is not found, or the ClassAI could not cast or refused to cast a spell for some reason..
+
+        //Combination of all Healer roles, scans the party and decides if group healing > individual healing > Rez > curing > buffing is needed
+        //and directs any matches found to individual ClassAIs
+        //Main Raid scan function for Healer/Support types..
+        bool DoSupportRaid(Player *gPlayer, float radius=30, bool dResurrect=true, bool dGroupHeal=true, bool dHeal=true, bool dCure=true, bool dBuff=true);
+        //Find matching debuffs on target to provided Spell, and call castSpell() with provided parameters
+        bool castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+        //Cast matching debuffs on self with probided SpellId list.. Mainly Used for Racial spells.. List is used to prevent extra loops for each spell..
+        bool castSelfCCBreakers (uint32 castList[]);
+
+
+
+        typedef std::set<Unit *> AttackerSet;
+
+        uint8 rezSpamTimer;
+        uint32 foodDrinkSpamTimer;
+        static const uint32 foodDrinkSpamCount = 100;
+
+        BotRole m_role;
+        bool m_pulling;
+        uint32 threatThreshold, offensiveSpellThreshold;
+
+        // RACIAL SPELLS
+        uint32 R_ARCANE_TORRENT, R_BERSERKING, R_BLOOD_FURY, R_CANNIBALIZE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_GIFT_OF_NAARU, R_SHADOWMELD, R_STONEFORM, R_WAR_STOMP, R_WILL_OF_FORSAKEN;
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+        uint32 SHOOT;
+
+    private:
+        Player *m_master;
+        Player *m_bot;
+        PlayerbotAI *m_ai;
+        Unit *mainTank;
+
+
+
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
new file mode 100644
index 0000000..b0c26d9
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
@@ -0,0 +1,325 @@
+/*
+Name : PlayerbotDeathknightAI.cpp
+Complete: maybe around 65%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is Blood dps/offtank type
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Situations needing Death grip casting : limited / non-existant..
+
+Authors : SwaLLoweD, rrtn
+Version : 0.40
+*/
+
+#include "PlayerbotDeathKnightAI.h"
+
+class PlayerbotAI;
+PlayerbotDeathKnightAI::PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+
+PlayerbotDeathKnightAI::~PlayerbotDeathKnightAI() {}
+
+void PlayerbotDeathKnightAI::LoadSpells(){
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    // Unholy
+    PLAGUE_STRIKE = ai->getSpellIdExact("Plague Strike");
+    DEATH_STRIKE = ai->getSpellIdExact("Death Strike");
+    SCOURGE_STRIKE  = ai->getSpellIdExact("Scourge Strike");
+
+    // Frost
+    ICY_TOUCH = ai->getSpellIdExact("Icy Touch");
+    OBLITERATE = ai->getSpellIdExact("Obliterate");
+
+    // Blood
+    BLOOD_STRIKE = ai->getSpellIdExact("Blood Strike");
+    HEART_STRIKE  = ai->getSpellIdExact("Heart Strike");
+    RUNE_TAP = ai->getSpellIdExact("Rune Tap");
+    DARK_COMMAND = ai->getSpellIdExact("Dark Command");
+
+    // AOE
+    HOWLING_BLAST = ai->getSpellIdExact("Howling Blast");
+    BLOOD_BOIL = ai->getSpellIdExact("Blood Boil");
+    PESTILENCE = ai->getSpellIdExact("Pestilence");
+    CORPSE_EXPLOSION = ai->getSpellIdExact("Corpse Explosion");
+    DEATH_AND_DECAY = ai->getSpellIdExact("Death and Decay");
+
+    // Rune attacks
+    FROST_STRIKE = ai->getSpellIdExact("Frost Strike");
+    DEATH_COIL = ai->getSpellIdExact("Death Coil");
+    RUNE_STRIKE = ai->getSpellIdExact("Rune Strike");
+
+    // CC Interrupt
+    DEATH_GRIP = ai->getSpellIdExact("Death Grip");
+    CHAINS_OF_ICE = ai->getSpellIdExact("Chains of Ice");
+    MIND_FREEZE = ai->getSpellIdExact("Mind Freeze");
+    HUNGERING_COLD = ai->getSpellIdExact("Hungering Cold");
+    STRANGULATE = ai->getSpellIdExact("Strangulate");
+
+    // Debuffs
+    FROST_FEVER = 55095; //ai->getSpellIdExact("Frost Fever",true);
+    BLOOD_PLAGUE = 55078; //ai->getSpellIdExact("Blood Plague",true);
+    CRYPT_FEVER = ai->getSpellIdExact("Crypt Fever",true);
+    EBON_PLAGUE = ai->getSpellIdExact("Ebon Plague",true);
+    MARK_OF_BLOOD = ai->getSpellIdExact("Mark of Blood");
+
+    // Buffs
+    HORN_OF_WINTER = ai->getSpellIdExact("Horn of Winter");
+    BONE_SHIELD = ai->getSpellIdExact("Bone Shield");
+    VAMPIRIC_BLOOD = ai->getSpellIdExact("Vampiric Blood");
+    HYSTERIA = ai->getSpellIdExact("Hysteria");
+    UNBREAKABLE_ARMOR = ai->getSpellIdExact("Unbreakable Armor");
+    ANTI_MAGIC_SHELL = ai->getSpellIdExact("Anti Magic Shell");
+    ANTI_MAGIC_ZONE = ai->getSpellIdExact("Anti Magic Zone");
+    ICEBOUND_FORTITUDE = ai->getSpellIdExact("Icebound Fortitude");
+    EMPOWER_WEAPON = ai->getSpellIdExact("Empower Rune Weapon");
+    LICHBORNE = ai->getSpellIdExact("Lichborne");
+
+    // Summons
+    RAISE_DEAD = ai->getSpellIdExact("Raise Dead");
+    ARMY_OF_THE_DEAD = ai->getSpellIdExact("Army of the Dead");
+    SUMMON_GARGOYLE = ai->getSpellIdExact("Summon Gargoyle");
+    GHOUL_FRENZY = ai->getSpellIdExact("Ghoul Frenzy");
+    DEATH_PACT = ai->getSpellIdExact("Death Pact");
+    DANCING_WEAPON = ai->getSpellIdExact("Dancing Rune Weapon");
+
+    // Presences
+    BLOOD_PRESENCE = ai->getSpellIdExact("Blood Presence");
+    FROST_PRESENCE = ai->getSpellIdExact("Frost Presence");
+    UNHOLY_PRESENCE  = ai->getSpellIdExact("Unholy Presence");
+
+    // Talent
+    TALENT_BLOOD = HEART_STRIKE;
+    TALENT_FROST = FROST_STRIKE;
+    TALENT_UNHOLY = SCOURGE_STRIKE;
+
+    uint8 talentCounter = 0;
+    if (TALENT_BLOOD) talentCounter++;
+    if (TALENT_FROST) talentCounter++;
+    if (TALENT_UNHOLY) talentCounter++;
+    if (talentCounter > 1) { TALENT_BLOOD = 0; TALENT_FROST = 0; TALENT_UNHOLY = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+void PlayerbotDeathKnightAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    std::ostringstream out;
+
+
+    if (!m_pulling)
+    {
+        m_role = BOT_ROLE_DPS_MELEE;
+        #pragma region Choose Role/Presence
+
+        // Choose Presence
+        if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+        {
+            if (CastSpell(FROST_PRESENCE,m_bot)) { m_role = BOT_ROLE_TANK; return; }
+        }
+        else if (isUnderAttack()) // I am under attack
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2)  {} // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+            if (CastSpell(FROST_PRESENCE,m_bot)) { m_role = BOT_ROLE_OFFTANK; return; }
+        }
+        else if (TALENT_UNHOLY)
+        {
+            if (CastSpell(UNHOLY_PRESENCE,m_bot)) return;
+        }
+        else if (CastSpell(BLOOD_PRESENCE,m_bot)) return;
+        #pragma endregion
+    }
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[6] = { LICHBORNE, ICEBOUND_FORTITUDE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    TakePosition(pTarget);
+
+
+   if (m_pulling) {
+        if (GetAI()->CastSpell(DEATH_GRIP,pTarget)) {
+            m_pulling = false;
+            GetAI()->SetCombatOrder(ORDERS_NONE);
+            GetAI()->Follow(*GetMaster());
+            GetAI()->SetIgnoreUpdateTime(2);
+
+            if (m_bot->GetPet()) pet->SetReactState (REACT_DEFENSIVE);
+         }
+          return;
+    }
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    #pragma region Buff Heal Interrupt
+    //Buff UP
+    if (CastSpell(HORN_OF_WINTER,m_bot)) { return; }
+    if (CastSpell(BONE_SHIELD,m_bot)) { return; }
+
+    //HEAL UP && PROTECT UP
+    if (ai->GetHealthPercent() < 80 && ai->GetHealthPercent() > 20 && CastSpell(VAMPIRIC_BLOOD,m_bot)) { }  //NO GCD
+    if (ai->GetHealthPercent() < 65 && CastSpell(RUNE_TAP,m_bot)) { } //NO GCD
+    if (CanCast(DEATH_STRIKE,pTarget,true) && ai->GetHealthPercent() < 90 &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) ||pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(DEATH_STRIKE,pTarget,false) ) {return;}
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (pet && ai->GetHealthPercent() < 50 && CastSpell(DEATH_PACT,m_bot)) { return; }
+    if (pet && ai->GetHealthPercent() < 60 && CastSpell(MARK_OF_BLOOD,pTarget)) { return; }
+    if (ai->GetHealthPercent() < 65 && CastSpell(ICEBOUND_FORTITUDE,m_bot)) { } //No GCD
+    if (ai->GetHealthPercent() < 65 && CastSpell(UNBREAKABLE_ARMOR,m_bot)) { return; }
+
+    //Break spells being cast
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (CastSpell(MIND_FREEZE,pTarget)) {} // No GCD
+        if (CastSpell(STRANGULATE,pTarget)) { return; }
+        if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+        if (CastSpell(ANTI_MAGIC_ZONE,m_bot)) { return; }
+        if (CastSpell(ANTI_MAGIC_SHELL,m_bot)) {} //NO GCD
+    }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(DEATH_GRIP,pTarget)) return;
+        if (CastSpell(CHAINS_OF_ICE,pTarget)) return;
+    }
+    #pragma endregion
+
+    #pragma region Taunt / Threat
+    // if i am main tank, protect master by taunt
+    if(m_tank->GetGUID() == m_bot->GetGUID())
+    {
+        // Taunt if needed (Only for master)
+        Unit *curAtt = GetAttackerOf(GetMaster());
+        if (curAtt && CastSpell(DARK_COMMAND, curAtt))  { }     //No gcd
+        // My target is not attacking me, taunt..
+        if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(DARK_COMMAND, pTarget) )  { } // No gcd
+    }
+
+    // If not in Frost Presence slow down due to threat
+    if (pThreat > threatThreshold && !m_bot->HasAura(FROST_PRESENCE) && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else { return; } //DK has no threat reducing spells, just slow down
+    }
+    #pragma endregion
+
+    #pragma region Dps
+    //Dps up
+    if (CastSpell(EMPOWER_WEAPON,m_bot)) {} //NO GCD
+    if (ai->GetHealthPercent() > 90 && CastSpell(HYSTERIA,m_bot)) {} //NO GCD
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    // Use up excess Runic Power
+    if (ai->GetRunicPower() > 60 && CastSpell(FROST_STRIKE,pTarget)) { return; }
+    else if (ai->GetRunicPower() > 60 && CastSpell(DEATH_COIL,pTarget,true,true,true)) { return; }
+    if ((isUnderAttack() || ai->GetRunicPower() > 70) && CastSpell(RUNE_STRIKE,pTarget)) {} //Next attack spell
+
+    // Build Diseases
+    if (!pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) && CastSpell(ICY_TOUCH,pTarget)) { return; }
+    if (!pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) && CastSpell(PLAGUE_STRIKE,pTarget)) { return; }
+
+    // Use AOEs summons
+    if (isUnderAttack(m_tank,4) && CastSpell(DEATH_AND_DECAY,pTarget)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(HOWLING_BLAST,pTarget)) { return; }
+    if (CanCast(PESTILENCE,pTarget,true) && isUnderAttack(m_tank,4) &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) && pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(PESTILENCE,pTarget,false)) { return; }
+    if (CanCast(BLOOD_BOIL,pTarget,true) && isUnderAttack(m_tank,4) &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) || pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(BLOOD_BOIL,pTarget,false)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    if (isUnderAttack(m_tank,6) && CastSpell(ARMY_OF_THE_DEAD,m_bot)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(SUMMON_GARGOYLE,pTarget)) { return; } //This should be somewhat different
+
+    // Use standard damage spells
+    if (CastSpell(HEART_STRIKE,pTarget,true,true)) { return; }
+    if (CastSpell(BLOOD_STRIKE,pTarget)) { return; }
+    if (TALENT_FROST && CastSpell(OBLITERATE,pTarget)) { return; }
+    else if (TALENT_UNHOLY && CastSpell(SCOURGE_STRIKE,pTarget)) { return; }
+    else if (CastSpell(DEATH_STRIKE,pTarget)) { return; }
+    #pragma endregion
+
+} // end DoNextCombatManeuver
+
+void PlayerbotDeathKnightAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff UP
+    if (CastSpell(HORN_OF_WINTER,m_bot)) { return; }
+    if (CastSpell(BONE_SHIELD,m_bot)) { return; }
+
+    //mana/hp check
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(RUNE_TAP,m_bot)) { return; } //no gcd but lets give the others a time to heal
+    if (ai->GetHealthPercent() < 30) { ai->Feast(); }
+    //Item* fItem = ai->FindBandage();
+    /* if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }  */
+} // end DoNonCombatActions
+
+void PlayerbotDeathKnightAI::Pull()
+{
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        m_pulling = false;
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+
+    if (GetPlayerBot()->GetPet()) GetPlayerBot()->GetPet()->SetReactState (REACT_PASSIVE);
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
new file mode 100644
index 0000000..a337537
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
@@ -0,0 +1,61 @@
+#ifndef _PLAYERDEATHKNIGHTAI_H
+#define _PLAYERDEATHKNIGHTAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotDeathKnightAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotDeathKnightAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotDeathKnightAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        void Pull();
+
+    private:
+        // Unholy
+        uint32 PLAGUE_STRIKE, DEATH_STRIKE, SCOURGE_STRIKE;
+
+        // Frost
+        uint32 ICY_TOUCH, OBLITERATE;
+
+        // Blood
+        uint32 BLOOD_STRIKE, HEART_STRIKE, RUNE_TAP, DARK_COMMAND;
+
+        // AOE
+        uint32 HOWLING_BLAST, BLOOD_BOIL, PESTILENCE, CORPSE_EXPLOSION, DEATH_AND_DECAY;
+
+        // Rune attacks
+        uint32 FROST_STRIKE, DEATH_COIL, RUNE_STRIKE;
+
+        // CC Interrupt
+        uint32 DEATH_GRIP, CHAINS_OF_ICE, MIND_FREEZE, HUNGERING_COLD, STRANGULATE;
+
+        // Debuffs
+        uint32 FROST_FEVER, BLOOD_PLAGUE, CRYPT_FEVER, EBON_PLAGUE, MARK_OF_BLOOD;
+
+        // Buffs
+        uint32 HORN_OF_WINTER, BONE_SHIELD, VAMPIRIC_BLOOD, HYSTERIA, UNBREAKABLE_ARMOR, ANTI_MAGIC_SHELL, ANTI_MAGIC_ZONE, ICEBOUND_FORTITUDE, EMPOWER_WEAPON, LICHBORNE;
+
+        // Summons
+        uint32 RAISE_DEAD, ARMY_OF_THE_DEAD, SUMMON_GARGOYLE, GHOUL_FRENZY, DEATH_PACT, DANCING_WEAPON;
+
+        // Presences
+        uint32 BLOOD_PRESENCE, FROST_PRESENCE, UNHOLY_PRESENCE;
+
+        // Talent
+        uint32 TALENT_BLOOD, TALENT_FROST, TALENT_UNHOLY;
+
+};
+
+#endif
+
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
new file mode 100644
index 0000000..4afa17d
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
@@ -0,0 +1,676 @@
+/*
+Name : PlayerbotDruidAI.cpp
+Complete: maybe around 70%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is a combination of Feral/balance type..
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Tree of life form transition is late and may never occur, due to healing bots attacking priority at full mana.
+                - Boomkin's support roles are not fully covered.. For example -> off healing
+                - Situations needing Abolish Disease casting : limited / non-existant..
+
+Authors : SwaLLoweD, rrtn, Natsukawa
+Version : 0.40
+*/
+#include "PlayerbotDruidAI.h"
+
+class PlayerbotAI;
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI(){}
+
+void PlayerbotDruidAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+#pragma region SpellId Fill
+    // Balance Spells
+    MOONFIRE = ai->getSpellIdExact("Moonfire"); //attacks
+    WRATH = ai->getSpellIdExact("Wrath");
+    STARFIRE = ai->getSpellIdExact("Starfire");
+    STARFALL = ai->getSpellIdExact("Starfall");
+    FORCE_OF_NATURE = ai->getSpellIdExact("Force of Nature");
+    TYPHOON = ai->getSpellIdExact("Typhoon");
+    HURRICANE = ai->getSpellIdExact("Hurricane");
+    INSECT_SWARM = ai->getSpellIdExact("Insect Swarm");
+
+    CYCLONE = ai->getSpellIdExact("Cyclone");
+    ROOTS = ai->getSpellIdExact("Entangling Roots");
+    NATURES_GRASP = ai->getSpellIdExact("Nature's Grasp");
+
+    HIBERNATE = ai->getSpellIdExact("Hibernate");
+    FAERIE_FIRE = ai->getSpellIdExact("Faerie Fire");
+
+
+    // Bear Form Spells
+    MAUL = ai->getSpellIdExact("Maul");
+    BASH = ai->getSpellIdExact("Bash");
+    LACERATE = ai->getSpellIdExact("Lacerate");
+    MANGLE_BEAR = ai->getSpellIdExact("Mangle (Bear)");
+    SWIPE_BEAR = ai->getSpellIdExact("Swipe (Bear)");
+
+    DEMORALIZING_ROAR = ai->getSpellIdExact("Demoralizing Roar");
+    GROWL = ai->getSpellIdExact("Growl");
+    CHALLENGING_ROAR = ai->getSpellIdExact("Challenging Roar");
+
+    ENRAGE = ai->getSpellIdExact("Enrage");
+    FERAL_CHARGE_BEAR = ai->getSpellIdExact("Feral Charge - Bear");
+    FRENZIED_REGENERATION = ai->getSpellIdExact("Frenzied Regeneration");
+
+
+    //Cat Attack type's
+    RAKE = ai->getSpellIdExact("Rake"); //40 energy
+    CLAW = ai->getSpellIdExact("Claw"); //45
+    MANGLE_CAT = ai->getSpellIdExact("Mangle (Cat)"); //45
+    SHRED = ai->getSpellIdExact("Shred");
+
+    RIP = ai->getSpellIdExact("Rip"); //30
+    FEROCIOUS_BITE = ai->getSpellIdExact("Ferocious Bite"); //35
+    SAVAGE_ROAR = ai->getSpellIdExact("Savage Roar");
+    MAIM = ai->getSpellIdExact("Maim"); //35
+
+    FERAL_CHARGE_CAT = ai->getSpellIdExact("Feral Charge - Cat");
+    COWER = ai->getSpellIdExact("Cower"); //20
+    TIGERS_FURY = ai->getSpellIdExact("Tiger's Fury");
+
+    // Feral General
+    BERSERK = ai->getSpellIdExact("Berserk");
+    FAERIE_FIRE_FERAL = ai->getSpellIdExact("Faerie Fire (Feral)"); //debuffs
+
+    //buffs
+    MARK_OF_THE_WILD = ai->getSpellIdExact("Mark of the Wild"); //buffs
+    GIFT_OF_THE_WILD = ai->getSpellIdExact("Gift of the Wild");
+    THORNS = ai->getSpellIdExact("Thorns");
+    SURVIVAL_INSTINCTS = ai->getSpellIdExact("Survival Instincts");
+
+    // Restoration Spells
+    LIFEBLOOM = ai->getSpellIdExact("Lifebloom");
+    REJUVENATION = ai->getSpellIdExact("Rejuvenation"); //heals
+    REGROWTH = ai->getSpellIdExact("Regrowth");
+    NOURISH = ai->getSpellIdExact("Nourish");
+    SWIFTMEND = ai->getSpellIdExact("Swiftmend");
+    HEALING_TOUCH = ai->getSpellIdExact("Healing Touch");
+    INNERVATE = ai->getSpellIdExact("Innervate");
+    WILD_GROWTH = ai->getSpellIdExact("Wild Growth");
+    TRANQUILITY = ai->getSpellIdExact("Tranquility");
+    NATURES_SWIFTNESS = ai->getSpellIdExact("Nature's Swiftness");
+
+    CURE_POISON = ai->getSpellIdExact("Abolish Poison");
+    if (!CURE_POISON) CURE_POISON = ai->getSpellIdExact("Cure Poison");
+
+    REBIRTH    = ai->getSpellIdExact("Rebirth");
+    REVIVE = ai->getSpellIdExact("Revive");
+
+    BARKSKIN = ai->getSpellIdExact("Barkskin");
+
+    //Druid Forms
+    BEAR_FORM = ai->getSpellIdExact("Dire Bear Form");
+    if (!BEAR_FORM) BEAR_FORM = ai->getSpellIdExact("Bear Form");
+    CAT_FORM = ai->getSpellIdExact("Cat Form");
+    MOONKIN_FORM = ai->getSpellIdExact("Moonkin Form");
+    TREE_OF_LIFE_FORM = ai->getSpellIdExact("Tree of Life"); //33891;//learning spell has higher id..
+    AQUATIC_FORM = ai->getSpellIdExact("Aquatic Form");
+    TRAVEL_FORM = ai->getSpellIdExact("Travel Form");
+    FLIGHT_FORM = ai->getSpellIdExact("Swift Flight Form");
+    if (!FLIGHT_FORM) FLIGHT_FORM = ai->getSpellIdExact("Flight Form");
+
+
+    TALENT_BALANCE    = MOONKIN_FORM;
+    TALENT_RESTO    = SWIFTMEND;
+    TALENT_FERAL    = MANGLE_CAT;
+
+    uint8 talentCounter = 0;
+    if (TALENT_BALANCE) talentCounter++;
+    if (TALENT_FERAL) talentCounter++;
+    if (TALENT_RESTO) talentCounter++;
+    if (talentCounter > 1) { TALENT_BALANCE = 0; TALENT_RESTO = 0; TALENT_FERAL = 0; } //Unreliable Talent detection.
+#pragma endregion
+}
+
+void PlayerbotDruidAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+
+    #pragma region Select behaviour
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        if (TALENT_FERAL && BEAR_FORM) { m_role = BOT_ROLE_TANK; } //Just Keep Tanking dont even change forms for healing
+        else
+        {
+            if (TALENT_BALANCE) {
+                if ((ai->GetHealthPercent() <= 40 || masterHP <30 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else if (ai->GetManaPercent() < 25 ) { m_role = BOT_ROLE_TANK; }
+                else { m_role = BOT_ROLE_DPS_RANGED; }
+            }
+            else //I am both healer and tank?? Hmm
+            {
+                if ((ai->GetHealthPercent() <= 70 || masterHP <70 ) && (ai->GetManaPercent() >= 50)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else if (ai->GetManaPercent() < 15 ) { m_role = BOT_ROLE_TANK; }
+                else { m_role = BOT_ROLE_DPS_RANGED; }
+            }
+        }
+    }
+    else if (isUnderAttack() && !( ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_TREE)  ) // if i am under attack
+    {
+        // Keep being in Cat Form if you can reduce threat
+        if (ai->GetForm() == FORM_CAT && CastSpell(COWER,pTarget)) {return; }
+        else if (TALENT_RESTO && ai->GetManaPercent() > 10 ) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_OFFTANK; }
+    }
+    else if (TALENT_FERAL && CAT_FORM) { // If has any feral forms at all
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 30 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+        else{ m_role = BOT_ROLE_DPS_MELEE; }
+    }
+    else if (TALENT_BALANCE) {
+        if ((ai->GetHealthPercent() <= 50 || masterHP <40 ) && (ai->GetManaPercent() >= 10)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+    else if (TALENT_RESTO)    { m_role = BOT_ROLE_SUPPORT; }
+    else
+    {
+        // Unknown build or low level : Do not change forms rapidly..
+        if ( (ai->GetManaPercent() < 30 && BEAR_FORM) || ( (ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR) && ai->GetManaPercent() < 70 )  ) m_role = BOT_ROLE_DPS_MELEE;
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+
+    if (!isUnderAttack() && m_tank->GetGUID() != m_bot->GetGUID())
+    {
+        // Select Attacking target
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {} //if my target is attacking me continue
+        else
+        {
+            Unit *curAtt = GetNearestAttackerOf(m_bot);
+            if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(curAtt->GetGUID());
+                //ai->AddLootGUID(curAtt->GetGUID());
+                DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                return;
+            }
+        }
+        //my target is attacking me
+    }
+    #pragma endregion
+
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+    // Return to normal form from non combat forms
+    if (ai->GetForm() == FORM_NONE || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_TREE || ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR )  { } //Those are valid incombat auras
+    else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { } //return to caster form
+
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            //ai->TellMaster("DruidCombat");
+
+            // Do caster form stuff
+            if (ai->GetForm() == FORM_NONE)
+            {
+                //We have little mana probably cant change form
+                if (ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot) ) { return; }
+                else if(m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) {  return;}
+                else if(DoSupportRaid(GetMaster(),false,false,false)) return;
+                else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+            }
+
+            if (CAT_FORM) { if (ChangeForm(CAT_FORM)) { return; } }
+            else if (BEAR_FORM) { if (ChangeForm(BEAR_FORM)) { return; } }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) {  } //Normal Form
+
+            TakePosition(pTarget);
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_OFFTANK:
+        case BOT_ROLE_TANK: // It is a tank druid or a defending druid
+
+            // Do what you must before getting attacked...
+            if (ai->GetForm() == FORM_NONE)
+            {
+                // Non tank stuff to avoid
+                if (m_tank->GetGUID() != m_bot->GetGUID())
+                {
+                    if (ROOTS && !pTarget->HasAura(CYCLONE) && !pTarget->HasAura(HIBERNATE) && CastSpell(ROOTS, pTarget)) { return; }
+                    if (CYCLONE && pDist > 5 && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(HIBERNATE) && CastSpell(CYCLONE, pTarget)) { return; }
+                    if (HIBERNATE && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(CYCLONE) && CastSpell(HIBERNATE, pTarget)) { return; }
+                    //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+                }
+                // Things to do wheter Tank or not
+                if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd
+                if (ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot) ) { return; } //We have little mana probably cant change form
+            }
+            TakePosition(pTarget);
+
+            if (ChangeForm(BEAR_FORM)) { return; }
+
+            // if i am main tank, protect master by taunt
+            if(m_tank->GetGUID() == m_bot->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt)
+                {
+                    if (isUnderAttack(GetMaster(),2) && CastSpell(CHALLENGING_ROAR, curAtt)) { return; }
+                    if (CastSpell(GROWL, curAtt))  { return; }
+                }
+                // My target is not attacking me, taunt..
+                if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(GROWL, pTarget) )  { return; }
+            }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            if ( ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot)) { return; }
+
+            // Do caster form stuff
+            if (ai->GetForm() == FORM_NONE)
+            {
+                if(DoSupportRaid(GetMaster())) return;
+                else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+            }
+
+            if (MOONKIN_FORM) { if (ChangeForm(MOONKIN_FORM)) { return; } }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { } //Normal Form
+
+            TakePosition(pTarget);
+
+            // BUFF UP
+            if(DoSupportRaid(GetMaster(),false,false,false)) return;
+            else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+            if ( ai->GetManaPercent() < 20 && CastSpell (INNERVATE,m_bot)) { return; }
+            //Get to tree form only if you will no longer cast attack spells
+            if( TREE_OF_LIFE_FORM && (ai->GetManaPercent() < offensiveSpellThreshold || isUnderAttack()) )
+            {
+                 if (ChangeForm(TREE_OF_LIFE_FORM)) { return; }
+            }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { }  //Normal Form no gcd
+
+            TakePosition(pTarget);
+
+            //RezGroup(REBIRTH, GetMaster());
+            if (DoSupportRaid(GetMaster())) { return; }
+            if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            Unit *target = DoSelectLowestHpFriendly(30, 1000);
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            break;
+        #pragma endregion
+    }
+
+    #pragma region DruidCommon
+    // Common Dps and protection routine
+    if (ai->GetHealthPercent() <= 70 && CastSpell(BARKSKIN,m_bot)) { return; }
+    if (isUnderAttack() && CastSpell(NATURES_GRASP,m_bot)) { return; }
+
+    if (ai->GetForm() == FORM_CAT)
+    {
+        // If at threat limit, use Cower to reduce threat
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+        {
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+            {
+                m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                return;
+            }
+            else
+            {
+                if (CastSpell(COWER,pTarget)) { return; } //Lets see if we can manage
+                else { return; } //use no spells and wait threat to be reduced
+            }
+        }
+        if (CastSpell(FERAL_CHARGE_CAT,pTarget)) { return; }
+        if (m_bot->GetComboPoints() >= 1 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(MAIM, pTarget)) { return; }
+
+        if (CastSpell(BERSERK, m_bot)) { return; }
+        if (ai->GetHealthPercent() <= 75 && CastSpell(SURVIVAL_INSTINCTS, m_bot)) { return; }
+        if (isUnderAttack() && CastSpell(NATURES_GRASP, m_bot)) { return; }
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget)) { return; }
+
+        if (m_bot->GetComboPoints() < 5)
+        {
+            if (CastSpell(RAKE, pTarget)) { return; }
+            if (CastSpell(MANGLE_CAT, pTarget)) { return; }
+            if (!pTarget->HasInArc(M_PI,m_bot) && CastSpell(SHRED, pTarget)) { return; }
+            if (ai->GetEnergyAmount() > 65 && CastSpell(MANGLE_CAT, pTarget)) { return; } //Spam mangle if cannot cast shred
+            if (ai->GetEnergyAmount() > 65 && CastSpell(CLAW, pTarget) ) { return; } //Spam Claw if there is no mangle
+            // if (CanCast(COWER, pTarget) && CastSpell(COWER, pTarget)) { return; } //if still nothing, use COWER to reduce threat
+        }
+        else
+        {
+            if (CastSpell(SAVAGE_ROAR)) { return; }
+            if (CastSpell(RIP, pTarget)) { return; }
+            if (ai->GetEnergyAmount() >= 65 && CastSpell(FEROCIOUS_BITE, pTarget)) { return; } //maxhit for feracious bite
+        }
+        if (CastSpell(TIGERS_FURY, m_bot)) { return; } //if nothing is ready yet, use tigers fury
+    }
+    else if (ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        // If at threat limit, stop
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+        {
+            //Change to tank's target
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) { m_bot->SetSelection(m_tank->getVictim()->GetGUID()); }
+            return; //use no spells and wait threat to be reduced
+        }
+        if (CastSpell(FERAL_CHARGE_BEAR,pTarget)) { return; }
+        if (CastSpell(BASH, pTarget,true,true)) { return; } //Need check for immunity
+        if (CastSpell(BERSERK, m_bot)) { return; }
+        if (CastSpell(DEMORALIZING_ROAR, pTarget)) { return; }
+        if (ai->GetHealthPercent() > 90 && ai->GetRageAmount() < 50 && CastSpell(ENRAGE, m_bot)) { return; }
+        if (ai->GetHealthPercent() <= 75 && CastSpell(SURVIVAL_INSTINCTS, m_bot)) { return; }
+        if ( ( ai->GetHealthPercent() <= 30 || (ai->GetHealthPercent() < 85 && m_tank->GetGUID() != m_bot->GetGUID())  )
+            && CastSpell(FRENZIED_REGENERATION)) { return; }
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget)) { return; }
+        if (CastSpell(MANGLE_BEAR, pTarget)) { return; }
+        if ((ai->GetRageAmount() > 70 || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(SWIPE_BEAR, pTarget)) { return; }
+        if (ai->GetRageAmount() > 50 && CastSpell(MAUL, pTarget)) {} // Low Priority, Next Attack effect
+        if (ai->GetRageAmount() > 60 && CastSpell(LACERATE, pTarget)) { return; } //Currently applies only 1
+    }
+    else
+    {
+        //Defensive stuff
+        if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+        {
+            if (ROOTS && !pTarget->HasAura(CYCLONE) && !pTarget->HasAura(HIBERNATE) && CastSpell(ROOTS, pTarget)) { return; }
+            if (CYCLONE && pDist > 5 && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(HIBERNATE) && CastSpell(CYCLONE, pTarget)) { return; }
+            if (HIBERNATE && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(CYCLONE) && CastSpell(HIBERNATE, pTarget)) { return; }
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+            if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; }
+        }
+
+        if (CastSpell(FAERIE_FIRE, pTarget)) { return; }
+
+        // If at threat limit, stop
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+        {
+            //Change to tank's target
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) { m_bot->SetSelection(m_tank->getVictim()->GetGUID()); }
+            return; //use no spells and wait threat to be reduced
+        }
+        // Continue attacking if theres excess mana (for healers)
+        if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+        if (m_role != BOT_ROLE_SUPPORT && CastSpell(NATURES_SWIFTNESS, m_bot)) { } //only balance no gcd
+
+        if (m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(STARFIRE, pTarget)) { return; }
+        if (CastSpell(INSECT_SWARM, pTarget)) { return; }
+        if (CastSpell(TYPHOON, pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(HURRICANE, pTarget)) { ai->SetIgnoreUpdateTime(8); return; }
+        if (isUnderAttack(m_tank,5) && CastSpell(FORCE_OF_NATURE, m_bot)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(STARFALL, pTarget)) { return; }
+        if (CastSpell(MOONFIRE, pTarget)) { return; }
+        if (CastSpell(WRATH, pTarget)) { return; }
+        if (CastSpell(STARFIRE, pTarget)) { return; }
+    }
+
+    // If there is nothing else to do buff UP
+    if (m_role == BOT_ROLE_DPS_MELEE) //Those already healed and buffed or should never buff in combat
+    {
+        if (DoSupportRaid(GetMaster(),false,false,false)) { return; }
+        if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+    }
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+    #pragma endregion
+} //end DoNextCombatManeuver
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(GetMaster())) { return; }
+    if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(30, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 10 && CastSpell (INNERVATE, m_bot)) { return; } //Need mana fast
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() &&
+        (ai->GetForm() != FORM_CAT && ai->GetForm() != FORM_MOONKIN && ai->GetForm() != FORM_DIREBEAR && ai->GetForm() != FORM_BEAR)
+        && CastSpell(REGROWTH,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+
+bool PlayerbotDruidAI::BuffPlayer(Unit *target)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+
+    if(!target || target->isDead()) { return false; }
+
+    if (CanCast(THORNS,target,0,0,1) && !HasAuraName(target, THORNS)) {
+        // Decide if it is worth to change form
+        if( /*m_bot->HasAura(MOONKIN_FORM) ||*/ m_bot->HasAura(CAT_FORM) || m_bot->HasAura(BEAR_FORM))
+        {
+            if(GetAI()->GetManaPercent() >= 80 ) { ChangeForm(1); }
+            else { return false; }
+        }
+        return CastSpell(THORNS, target, false);
+    }
+    if (CanCast(MARK_OF_THE_WILD,target,0,0,1) && !HasAuraName(target, GIFT_OF_THE_WILD) && !HasAuraName(target, MARK_OF_THE_WILD)) {
+        // Decide if it is worth to change form
+        if(/*m_bot->HasAura(MOONKIN_FORM) ||*/ m_bot->HasAura(CAT_FORM) || m_bot->HasAura(BEAR_FORM))
+        {
+            if(GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+            else return false;
+        }
+        return CastSpell(MARK_OF_THE_WILD, target, false);
+    }
+    return false;
+}
+
+bool PlayerbotDruidAI::HealTarget(Unit *target, uint8 hp)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+
+    // Decide if it is worth to change form
+    if (ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        if (hp < 75 && GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+        else if (hp < 40 && GetAI()->GetManaPercent() >= 50) { ChangeForm(1); }
+        else if (hp < 25 && GetAI()->GetManaPercent() >= 30) { ChangeForm(1); }
+        else return false;
+    }
+
+    // if(m_bot->HasAura(TRAVEL_FORM)) ChangeForm(1);
+
+    if(hp < 60 && m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(HEALING_TOUCH, target)) { return true; }
+    if(hp < 90 && CastSpell(LIFEBLOOM, target)) { return true; }
+    if(hp < 80 && CastSpell(REJUVENATION, target)) { return true; }
+    if(hp < 60 && CastSpell(REGROWTH, target)) { return true; }
+    if(hp < 70 && CanCast(NOURISH,target) &&
+        (HasAuraName(target,REJUVENATION,m_bot->GetGUID()) || HasAuraName(target,LIFEBLOOM,m_bot->GetGUID()) || HasAuraName(target,REGROWTH,m_bot->GetGUID()))
+        ) { return CastSpell(NOURISH, target, false); }
+    if(hp < 50 && CanCast(SWIFTMEND,target) &&
+        (HasAuraName(target,REJUVENATION,m_bot->GetGUID()) || HasAuraName(target,REGROWTH,m_bot->GetGUID()))
+        ) { return CastSpell(SWIFTMEND, target, false); }
+    if(hp < 40 && m_bot->isInCombat() && CastSpell(NATURES_SWIFTNESS, m_bot)) { } // NO gcd
+    if(hp < 40 && CastSpell(HEALING_TOUCH, target)) { return true; }
+    return false;
+} //end HealTarget
+
+bool PlayerbotDruidAI::HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+
+    if (countNeedHeal < 2) { return false; }
+
+    // Decide if it is worth to change form
+    if (ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        if (hp > 70) { return false; }
+        if (!CanCast(TRANQUILITY,target,0,0,1) && !WILD_GROWTH) { return false; }
+        if (!WILD_GROWTH && hp > 35) { return false; }
+        if (hp < 65 && GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+        else if (hp < 40 && GetAI()->GetManaPercent() >= 50) { ChangeForm(1); }
+        else if (hp < 25 && GetAI()->GetManaPercent() >= 30) { ChangeForm(1); }
+        else return false;
+    }
+
+    if (hp < 36 && m_bot->isInCombat() && CanCast(TRANQUILITY,target))
+    {
+            bool sc = CastSpell(TRANQUILITY, target, false);
+            if (sc) GetAI()->SetIgnoreUpdateTime(10);
+            return sc;
+    }
+    if (hp < 75 && CastSpell(WILD_GROWTH,target)) { return true; }
+    return false;
+}
+
+bool PlayerbotDruidAI::CureTarget(Unit *target)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+    // Decide if it is worth to change form (they cange forms even if theres nothing to cure..)
+    if (ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        //if(GetAI()->GetManaPercent() >= 80 ) { ChangeForm(1); }
+        //else { return false; }
+        return false;
+    }
+    if (castDispel(CURE_POISON, target)) { return true; }
+    // if(HasAuraName(target, "Venom Spit") || HasAuraName(target, "Poison")) return CastSpell(CURE_POISON, target);
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotDruidAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+
+    if (m_bot->isInCombat())
+    {
+        if (!CanCast(REBIRTH,target)) return false;
+        Unit *m_tank = FindMainTankInRaid(m_bot);
+        if (!m_tank) m_tank = m_bot;
+        if (target->GetGUID() != m_tank->GetGUID() &&
+            (target->getClass() != (uint8) CLASS_PRIEST || target->getClass() != (uint8) CLASS_DRUID || target->getClass() != (uint8) CLASS_PALADIN) ) return false;
+        std::string msg = "Rezzing ";
+        msg += target->GetName();
+       // msg += " with ";
+       // msg += *REZZSpell->SpellName;
+        GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+        return CastSpell(REBIRTH, target);
+    }
+    else
+    {
+        if (!CanCast(REVIVE,target)) return false;
+        std::string msg = "Rezzing ";
+        msg += target->GetName();
+       // msg += " with ";
+       // msg += *REZZSpell->SpellName;
+        GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+        return CastSpell(REVIVE, target);
+    }
+    return false;
+}
+
+/*bool PlayerbotDruidAI::FindMount() {
+    if (TRAVEL_FORM) {
+        if (GetPlayerBot())    CastSpell(TRAVEL_FORM, GetPlayerBot());
+        return true;
+    } else return false;
+}
+
+bool PlayerbotDruidAI::Unmount() {
+    GetPlayerBot()->RemoveAurasDueToSpell(TRAVEL_FORM);
+    return true;
+}
+
+bool PlayerbotDruidAI::IsMounted() {
+    return GetPlayerBot()->IsMounted() || HasAuraName(GetPlayerBot(), TRAVEL_FORM);
+} */
+
+bool PlayerbotDruidAI::ChangeForm(uint32 form)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!form) return false;
+
+    if (form == 1 && ai->GetForm() == FORM_NONE) return false;
+
+    if (form != 1)
+    {
+        if (!CanCast(form,m_bot,0,0,1)) return false;
+        if (m_bot->HasAura(form)) { return false; }
+    }
+
+    if (ai->GetForm() == FORM_TREE) m_bot->RemoveAurasDueToSpell(TREE_OF_LIFE_FORM);
+    else if (ai->GetForm() == FORM_CAT) m_bot->RemoveAurasDueToSpell(CAT_FORM);
+    else if (ai->GetForm() == FORM_MOONKIN) m_bot->RemoveAurasDueToSpell(MOONKIN_FORM);
+    else if (ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR) m_bot->RemoveAurasDueToSpell(BEAR_FORM);
+    else if (ai->GetForm() == FORM_TRAVEL) m_bot->RemoveAurasDueToSpell(TRAVEL_FORM);
+    else if (ai->GetForm() == FORM_FLIGHT || ai->GetForm() == FORM_FLIGHT_EPIC)    m_bot->RemoveAurasDueToSpell(FLIGHT_FORM);
+    else if (ai->GetForm() == FORM_AQUA) m_bot->RemoveAurasDueToSpell(AQUATIC_FORM);
+
+    if (form == 1) { return true; }
+
+    return CastSpell(form,m_bot,false);
+}
+
+
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
new file mode 100644
index 0000000..35f4d54
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotDruidAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotDruidAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotDruidAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        bool HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget(Unit *target);
+
+        // find any specific mount spells, ie druids=cat, shaman=ghost wolf etc
+        /* virtual bool FindMount();
+        virtual bool Unmount();
+        virtual bool IsMounted(); */
+
+        //Change Form
+        bool ChangeForm(uint32 form);
+
+    private:
+
+        // BALANCE Attacks
+        uint32 MOONFIRE, WRATH, STARFALL, STARFIRE, TYPHOON, HURRICANE, FORCE_OF_NATURE, INSECT_SWARM, CYCLONE, ROOTS, NATURES_GRASP, HIBERNATE, FAERIE_FIRE;
+
+        // RESTORATION Spells
+        uint32 LIFEBLOOM, REJUVENATION, REGROWTH, NOURISH, SWIFTMEND, HEALING_TOUCH, NATURES_SWIFTNESS, INNERVATE, WILD_GROWTH, TRANQUILITY, REBIRTH, REVIVE, CURE_POISON, BARKSKIN;
+
+        // BEAR SPELLS
+        uint32 MAUL, BASH, LACERATE, MANGLE_BEAR, SWIPE_BEAR, DEMORALIZING_ROAR, GROWL, CHALLENGING_ROAR , ENRAGE, FERAL_CHARGE_BEAR, FRENZIED_REGENERATION;
+
+        // CAT SPELLS
+        uint32 CLAW, RAKE, SHRED, MANGLE_CAT, RIP, FEROCIOUS_BITE, SAVAGE_ROAR, MAIM, FERAL_CHARGE_CAT, COWER, TIGERS_FURY;
+
+        // FERAL General
+        uint32 BERSERK, FAERIE_FIRE_FERAL;
+
+        // BUFFS
+        uint32 MARK_OF_THE_WILD, GIFT_OF_THE_WILD, THORNS, SURVIVAL_INSTINCTS;
+
+        // FORMS
+        uint32 CAT_FORM, BEAR_FORM, MOONKIN_FORM, TREE_OF_LIFE_FORM, TRAVEL_FORM, FLIGHT_FORM, AQUATIC_FORM;
+
+        // Key TALENT SPELLS
+        uint32 TALENT_BALANCE, TALENT_RESTO, TALENT_FERAL;
+
+};
+
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
new file mode 100644
index 0000000..f7ec447
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
@@ -0,0 +1,561 @@
+/*
+Name : PlayerbotHunterAI.cpp
+Complete: maybe around 70%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - AI always assumes pet is the tank if there are no higher hp people in group than the hunter..
+                - Possible threat build / reduce race between pet and hunter if attacking to same target.. Needs checking
+                - Possible target changing loop between pet and hunter if attacking to same target and getting aggro repeatedly.. Needs checking
+                - Disarm and Nature resist aspect, Disengage, Scorpid sting are not used right now..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotHunterAI.h"
+
+
+class PlayerbotAI;
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    m_petSummonFailed = false;
+    LoadSpells();
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+void PlayerbotHunterAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    // PET CONTROL
+    PET_SUMMON = ai->getSpellIdExact("Call Pet");
+    PET_DISMISS = ai->getSpellIdExact("Dismiss Pet");
+    PET_REVIVE = ai->getSpellIdExact("Revive Pet");
+    PET_MEND = ai->getSpellIdExact("Mend Pet");
+    PET_FEED = 1539; //ai->getSpellIdExact("Feed Pet");
+    KILL_COMMAND = ai->getSpellIdExact("Kill Command");
+    INTIMIDATION = ai->getSpellIdExact("Intimidation");
+    BESTIAL_WRATH = ai->getSpellIdExact("Bestial Wrath");
+
+    // PET SPELL (master does not have these spells anymore)
+    GROWL = ai->getSpellIdExact("Growl");
+    COWER = ai->getSpellIdExact("Cower");
+    BAD_ATTITUDE = ai->getSpellIdExact("Bad Attitude");
+    SONIC_BLAST = ai->getSpellIdExact("Sonic Blast");
+    NETHER_SHOCK = ai->getSpellIdExact("Nether Shock");
+    DEMORALIZING_SCREECH = ai->getSpellIdExact("Demoralizing Screech");
+
+    // RANGED ATTACK
+    AUTO_SHOT = ai->getSpellIdExact("Auto Shot");
+    ARCANE_SHOT = ai->getSpellIdExact("Arcane Shot");
+    EXPLOSIVE_SHOT = ai->getSpellIdExact("Explosive Shot");
+    STEADY_SHOT = ai->getSpellIdExact("Steady Shot");
+    AIMED_SHOT = ai->getSpellIdExact("Aimed Shot");
+    SCATTER_SHOT = ai->getSpellIdExact("Scatter Shot");
+    KILL_SHOT = ai->getSpellIdExact("Kill Shot");
+    CHIMERA_SHOT = ai->getSpellIdExact("Chimera Shot");
+    CONCUSSIVE_SHOT = ai->getSpellIdExact("Concussive Shot");
+    DISTRACTING_SHOT = ai->getSpellIdExact("Distracting Shot");
+    SILENCING_SHOT = ai->getSpellIdExact("Silencing Shot");
+
+    // STINGS
+    SERPENT_STING = ai->getSpellIdExact("Serpent Sting");
+    SCORPID_STING = ai->getSpellIdExact("Scorpid Sting");
+    WYVERN_STING = ai->getSpellIdExact("Wyvern Sting");
+    VIPER_STING = ai->getSpellIdExact("Viper Sting");
+
+    // DEBUFF
+    HUNTERS_MARK = ai->getSpellIdExact("Hunter's Mark");
+    SCARE_BEAST = ai->getSpellIdExact("Scare Beast");
+
+    //AOE
+    VOLLEY = ai->getSpellIdExact("Volley");
+    MULTI_SHOT = ai->getSpellIdExact("Multi Shot");
+
+    //MELEE
+    RAPTOR_STRIKE = ai->getSpellIdExact("Raptor Strike");
+    WING_CLIP = ai->getSpellIdExact("Wing Clip");
+    MONGOOSE_BITE = ai->getSpellIdExact("Mongoose Bite");
+    COUNTERATTACK = ai->getSpellIdExact("Counterattack");
+
+    //TRAP
+    FREEZING_TRAP = ai->getSpellIdExact("Freezing Trap");
+    IMMOLATION_TRAP = ai->getSpellIdExact("Immolation Trap");
+    FROST_TRAP = ai->getSpellIdExact("Frost Trap");
+    EXPLOSIVE_TRAP = ai->getSpellIdExact("Explosive Trap");
+    SNAKE_TRAP = ai->getSpellIdExact("Snake Trap");
+    ARCANE_TRAP = ai->getSpellIdExact("Arcane Trap");
+    FREEZING_ARROW = ai->getSpellIdExact("Freezing Arrow");
+    BLACK_ARROW = ai->getSpellIdExact("Black Arrow");
+
+    //BUFF
+    TRUESHOT_AURA = ai->getSpellIdExact("Trueshot Aura");
+    DETERRENCE = ai->getSpellIdExact("Deterrence");
+    FEIGN_DEATH = ai->getSpellIdExact("Feign Death");
+    DISENGAGE = ai->getSpellIdExact("Disengage");
+    RAPID_FIRE = ai->getSpellIdExact("Rapid Fire");
+    READINESS = ai->getSpellIdExact("Readiness");
+    MISDIRECTION = ai->getSpellIdExact("Misdirection");
+
+    //ASPECT
+    ASPECT_OF_THE_HAWK = ai->getSpellIdExact("Aspect of the Dragonhawk");
+    ASPECT_OF_THE_MONKEY = ASPECT_OF_THE_HAWK;
+    if (!ASPECT_OF_THE_HAWK) ASPECT_OF_THE_HAWK = ai->getSpellIdExact("Aspect of the Hawk");
+    if (!ASPECT_OF_THE_MONKEY) ASPECT_OF_THE_MONKEY = ai->getSpellIdExact("Aspect of the Monkey");
+    ASPECT_OF_THE_VIPER = ai->getSpellIdExact("Aspect of the Viper");
+
+    TALENT_MM = TRUESHOT_AURA;
+    TALENT_BM = BESTIAL_WRATH;
+    TALENT_SURVIVAL = WYVERN_STING;
+
+    uint8 talentCounter = 0;
+    if (TALENT_MM) talentCounter++;
+    if (TALENT_BM) talentCounter++;
+    if (TALENT_SURVIVAL) talentCounter++;
+    if (talentCounter > 1) { TALENT_MM = 0; TALENT_BM = 0; TALENT_SURVIVAL = 0; } //Unreliable Talent detection.
+
+    #pragma endregion
+}
+
+bool PlayerbotHunterAI::HasPet(Player* bot)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot = '%u')",bot->GetGUIDLow(),PET_SAVE_AS_CURRENT,PET_SAVE_NOT_IN_SLOT);
+
+    if(result)
+        return true; //hunter has current pet
+    else
+        return false; //hunter either has no pet or stabled
+}// end HasPet
+
+void PlayerbotHunterAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    if (m_tank->GetGUID() == m_bot->GetGUID() && pet && pet->isAlive() && pet->isInCombat()) { m_tank = pet; }
+    uint8 petThreat = 0;
+    if (pet) { GetThreatPercent(pTarget,pet); }
+
+ //   switch (ai->GetScenarioType())
+//    {
+//        case PlayerbotAI::SCENARIO_DUEL:
+ //           ai->CastSpell(RAPTOR_STRIKE);
+ //           return;
+//    }
+
+    // ------- Non Duel combat ----------
+
+
+    #pragma region Choose Target
+    // Choose Target
+    if (isUnderAttack()) // I am under attack
+    {
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+        else //Have to select nearest target
+        {
+            Unit *curAtt = GetNearestAttackerOf(m_bot);
+            if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(curAtt->GetGUID());
+                //ai->AddLootGUID(curAtt->GetGUID());
+                DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                return;
+            }
+        }
+        //my target is attacking me
+    }
+
+    #pragma endregion
+
+    #pragma region Pet Actions
+    // Pet's own Actions
+    if( pet && pet->isAlive() )
+    {
+        // Setup pet
+        if (pet->GetCharmInfo()->IsAtStay()) {pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW); }
+
+        //Heal pet
+        if ( ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        && ( PET_MEND>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot
+        && CastSpell(PET_MEND,m_bot) )) { return; }
+
+        // Set pet to attack hunter's attacker > its own attackers > hunter's target
+        if (!pet->getVictim()) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(m_bot)) { pet->AI()->AttackStart(pTarget); }  //Always help hunter if she's under attack
+        else if (pet->getVictim()->GetGUID() != pTarget->GetGUID() && !isUnderAttack(pet)) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(pet)) // Pet is under attack and hunter has no attackers
+        {
+            if ( pet->getVictim()->getVictim() && pet->getVictim()->getVictim()->GetGUID() == pet->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(pet,true);
+                if (curAtt && (!pet->getVictim() || curAtt->GetGUID() != pet->getVictim()->GetGUID()))
+                {
+                    pet->AI()->AttackStart(curAtt); //Attack nearest attacker
+                }
+            }
+            //Actions to do under attack (Always tank it, and try to kill it, until someone (!= hunter) takes aggro back)
+            //Hunter should help her pet whether main tank or not, unless she's being attacked (BEWARE Targeting Loop possibility)
+            if (pet->getVictim() && !isUnderAttack(m_bot) && pet->getVictim()->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(pet->getVictim()->GetGUID());
+                DoNextCombatManeuver(pet->getVictim()); //Restart new update to get variables fixed..
+                return;
+            }
+
+        }
+        // Pet tanking behaviour
+        /*if (pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot) || isUnderAttack(pet))
+        {
+            if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,true); //Autocast growl
+            if (BAD_ATTITUDE) pet->GetCharmInfo()->SetSpellAutocast(BAD_ATTITUDE,true);
+            if (COWER) pet->GetCharmInfo()->SetSpellAutocast(COWER,false);
+            if (CastSpell(INTIMIDATION,m_bot)) { return; }
+        }
+        else
+        {
+            if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,false); //Do not try to get aggro
+            if (BAD_ATTITUDE) pet->GetCharmInfo()->SetSpellAutocast(BAD_ATTITUDE,false);
+            if (COWER) pet->GetCharmInfo()->SetSpellAutocast(COWER,true); //Autocast cower
+        }*/
+        // NORMAL PET dps attacks
+        if (petThreat < threatThreshold || pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot))
+        {
+            if (CastSpell(KILL_COMMAND,m_bot)) { }
+            else if (CastSpell(BESTIAL_WRATH,m_bot)) { }
+        }
+        // NETHERSHOCK DEMORALIZINGSCREECH
+    }
+    #pragma endregion
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[4] = { R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    #pragma region Evasive manuevers
+    // Do evasive manuevers if under attack
+    if (isUnderAttack())
+    {
+        if (m_tank->GetGUID() == m_bot->GetGUID()) { } // i am tank and my pet is probably dead, so i have to face the attackers
+        else if (CastSpell(FEIGN_DEATH,m_bot)) { return; } //avoid attack
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+        else if (CastSpell(CONCUSSIVE_SHOT,pTarget)) { return; }
+        else if (CastSpell(WYVERN_STING,pTarget)) { return; }
+        else if (CastSpell(SCATTER_SHOT,pTarget)) { return; }
+        else if (CastSpell(FREEZING_ARROW,pTarget)) { return; }
+        else if (CastSpell(MISDIRECTION,m_tank)) { return; }
+        else if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget) ) { return; } //no gcd but is cast
+        else if (pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && CastSpell(SCARE_BEAST,pTarget)) { return; }
+        else if (pDist <= 2 && CastSpell(FREEZING_TRAP,pTarget)) { return; }
+    }
+    #pragma endregion
+
+    //Select combat mode
+    m_role = BOT_ROLE_DPS_RANGED;
+    if ((isUnderAttack()  && pDist <= ATTACK_DISTANCE) || !m_bot->GetUInt32Value(PLAYER_AMMO_ID) ) { m_role = BOT_ROLE_DPS_MELEE; }
+
+    TakePosition(pTarget);
+
+    #pragma region Buff / Protect
+    //Buff UP
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot) ) {  } //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot) ) { } //no GCD
+    if (CastSpell(TRUESHOT_AURA, m_bot)) { return; }
+    if (CastSpell(RAPID_FIRE,m_bot)) { return; }
+    if (CastSpell(HUNTERS_MARK,pTarget)) { return; }
+    if ((ai->GetHealthPercent() < 80 || ai->GetManaPercent() < 60 ) && CastSpell(READINESS,m_bot)) { } //no gcd
+
+
+    //Protect yourself if needed
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot) ) { } //no gcd
+    if (ai->GetHealthPercent() < 20 && CastSpell(DETERRENCE,m_bot)) {} //No GCD
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return;  }
+
+    //Break Spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && ( pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 20 ) && CastSpell(R_ARCANE_TORRENT, pTarget) ) { } //no gcd
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SILENCING_SHOT, pTarget) ) { return; }
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SCATTER_SHOT, pTarget) ) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(WING_CLIP,pTarget)) return;
+        if (CastSpell(CONCUSSIVE_SHOT,pTarget)) return;
+        if (CastSpell(SCATTER_SHOT, pTarget) ) { return; }
+    }
+    #pragma endregion
+
+    //Do combat
+    switch (m_role)
+    {
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            if (AUTO_SHOT) { m_bot->InterruptNonMeleeSpells( true, AUTO_SHOT ); } //Stop autoshot
+            if (CastSpell(ASPECT_OF_THE_MONKEY,m_bot)) { return; } //Get Monkey aspect
+
+            if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+
+            // Threat control
+            if (pThreat < threatThreshold || m_tank->GetGUID() == m_bot->GetGUID() || m_bot->HasAura(MISDIRECTION) ) { } //Continue attack
+            else
+            {
+                if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+                {
+                    m_bot->SetSelection(pet->getVictim()->GetGUID());
+                    return;
+                }
+                else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+                {
+                    m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                    return;
+                }
+                else if (CastSpell(FEIGN_DEATH,m_bot)) { return; }
+                else { return; } // No more threat reducing spells, just slow down
+            }
+
+            if (CastSpell(RAPTOR_STRIKE,pTarget,true,true)) {} //No gcd
+            if (CastSpell(MONGOOSE_BITE,pTarget,true,true)) { return; } // Cannot be sure if casted or not
+            else if (CastSpell(COUNTERATTACK,pTarget,true,true)) { return; } // Cannot be sure if casted or not
+            if (CastSpell(WING_CLIP,pTarget)) { return; }
+            if (isUnderAttack(m_tank,6) && CastSpell(SNAKE_TRAP,m_bot)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(EXPLOSIVE_TRAP,m_bot)) { return; }
+            if (CastSpell(IMMOLATION_TRAP,m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            if (m_pulling) {
+                if (GetAI()->CastSpell(CONCUSSIVE_SHOT,pTarget) ||
+                    GetAI()->CastSpell(AUTO_SHOT,pTarget)) {
+                    m_pulling = false;
+                    GetAI()->SetCombatOrder(ORDERS_NONE);
+                    GetAI()->Follow(*GetMaster());
+                    GetAI()->SetIgnoreUpdateTime(2);
+
+                    if(HasPet(GetPlayerBot()))
+                        m_bot->GetPet()->SetReactState(REACT_DEFENSIVE);
+                }
+                return;
+            }
+            if (AUTO_SHOT && !m_bot->FindCurrentSpellBySpellId(AUTO_SHOT)) { ai->CastSpell(AUTO_SHOT,pTarget); } //Start autoshot
+            if (!(ai->GetManaPercent() < 85 && m_bot->HasAura(ASPECT_OF_THE_VIPER)) && CastSpell(ASPECT_OF_THE_HAWK,m_bot)) { return; } //Get Hawk aspect
+            if ((ai->GetManaPercent() < 25) && CastSpell(ASPECT_OF_THE_VIPER,m_bot,true,false,true)) { return; } //Build up mana
+
+            // if i am main tank, protect master by taunt
+            if(m_tank->GetGUID() == m_bot->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt && CastSpell(DISTRACTING_SHOT, curAtt))  { return; }
+                // My target is not attacking me, taunt..
+                if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(DISTRACTING_SHOT, pTarget) )  { return; }
+            }
+            // If i am not tank, transfer threat to tank or pet..
+            else
+            {
+                if (CastSpell(MISDIRECTION,m_tank)) { return; }
+                if (pet && pet->isAlive() && CastSpell(MISDIRECTION,pet)) { return; }
+
+                // Threat control
+                if (pThreat < threatThreshold || m_bot->HasAura(MISDIRECTION) ) { } //Continue attack
+                else
+                {
+                    if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+                    {
+                        m_bot->SetSelection(pet->getVictim()->GetGUID());
+                        return;
+                    }
+                    else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+                    {
+                        m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                        return;
+                    }
+                    else if (CastSpell(FEIGN_DEATH,m_bot)) { return; }
+                    else { return; } // No more threat reducing spells, just slow down
+                }
+            }
+
+            // DO dps
+            if (ai->GetHealthPercent(*pTarget) < 20 && CastSpell(KILL_SHOT,pTarget)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(MULTI_SHOT,pTarget)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(VOLLEY,pTarget)) { GetAI()->SetIgnoreUpdateTime(7); return; }
+            if (CanCast(CHIMERA_SHOT,pTarget) &&
+                (pTarget->HasAura(VIPER_STING,m_bot->GetGUID()) || pTarget->HasAura(SERPENT_STING,m_bot->GetGUID()) )
+                && CastSpell(CHIMERA_SHOT,pTarget,false) ) { return; }
+            if (ai->GetManaPercent() < 60 && ai->GetManaPercent(*pTarget) > 4 && CastSpell(VIPER_STING,pTarget)) { return; }
+            if (!pTarget->HasAura(VIPER_STING,m_bot->GetGUID()) && CastSpell(SERPENT_STING,pTarget)) { return; }
+            if (CastSpell(ARCANE_SHOT,pTarget)) { return; }
+            if (CastSpell(BLACK_ARROW,pTarget)) { return; }
+            if (CastSpell(EXPLOSIVE_SHOT,pTarget)) { return; }
+            if (CastSpell(STEADY_SHOT,pTarget)) { return; }
+            break;
+        #pragma endregion
+    }
+
+    /*// drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }*/
+} // end DoNextCombatManeuver
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    // buff group
+    if (CastSpell(TRUESHOT_AURA, m_bot)) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 20 || ai->GetHealthPercent() < 30) { ai->Feast(); }
+
+    #pragma region Check Pet
+    // check for pet
+    if( PET_SUMMON>0 && !m_petSummonFailed && HasPet(m_bot) )
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if( !pet )
+        {
+            // summon pet
+            if( PET_SUMMON>0 && ai->CastSpell(PET_SUMMON,m_bot) )
+                ai->TellMaster( "summoning pet." );
+            else
+            {
+                m_petSummonFailed = true;
+                ai->TellMaster( "summon pet failed!" );
+            }
+        }
+        else if( pet->getDeathState() != ALIVE )
+        {
+            // revive pet
+            if( PET_REVIVE>0 && ai->GetManaPercent()>=80 && ai->CastSpell(PET_REVIVE,m_bot) )
+                ai->TellMaster( "reviving pet." );
+        }
+        else if( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        {
+            // heal pet when health lower 50%
+            if( PET_MEND>0 && !pet->getDeathState() != ALIVE && !pet->HasAura(PET_MEND,0) && ai->GetManaPercent()>=13 && ai->CastSpell(PET_MEND,m_bot) )
+                ai->TellMaster( "healing pet." );
+        }
+        else if(pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit*)m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+                    if (!pItemTemplate )
+                        continue;
+                    if(pet->HaveInDiet(pItemTemplate)) // is pItem in pets diet
+                    {
+                        //sLog.outDebug("Food for pet: %s",pItemTemplate->Name1);
+                        caster->CastSpell(caster,51284,true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemTemplate->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                        ai->TellMaster( "feeding pet." );
+                        ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                {
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+                            if (!pItemTemplate )
+                                continue;
+                            if(pet->HaveInDiet(pItemTemplate)) // is pItem in pets diet
+                            {
+                                //sLog.outDebug("Food for pet: %s",pItemTemplate->Name1);
+                                caster->CastSpell(caster,51284,true); // pet feed visual
+                                uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemTemplate->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                                ai->TellMaster( "feeding pet." );
+                                ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+            if( pet->HasAura(PET_MEND, 0) && !pet->HasAura(PET_FEED, 0))
+
+                ai->TellMaster( "..no pet food!" );
+                ai->SetIgnoreUpdateTime(7);
+        }
+    #pragma endregion
+    }
+} // end DoNonCombatActions
+
+void PlayerbotHunterAI::Pull()
+{
+    if (!AUTO_SHOT) return;
+
+    // check ammo
+    uint32 ammo_id = GetPlayerBot()->GetUInt32Value(PLAYER_AMMO_ID);
+    if (!ammo_id) {
+        GetPlayerBot()->Say("I'm out of ammo.", LANG_UNIVERSAL);
+        return;
+    }
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+
+    if(GetPlayerBot()->GetPet())
+        GetPlayerBot()->GetPet()->SetReactState(REACT_PASSIVE);
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
new file mode 100644
index 0000000..4892624
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotHunterAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotHunterAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotHunterAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        bool HasPet(Player* bot);
+
+        virtual void Pull();
+
+        //buff a specific player, usually a real PC who is not in group
+        //void BuffPlayer(Player *target);
+
+    private:
+        //Hunter
+        bool m_petSummonFailed;
+        bool m_petFeedPetFailed;
+
+        // PET CONTROL
+        uint32 PET_SUMMON, PET_DISMISS, PET_REVIVE, PET_MEND, PET_FEED, KILL_COMMAND, INTIMIDATION, BESTIAL_WRATH;
+
+        // PET SPELL
+        uint32 GROWL, COWER, BAD_ATTITUDE, SONIC_BLAST, NETHER_SHOCK, DEMORALIZING_SCREECH;
+
+        // RANGED ATTACK
+        uint32 AUTO_SHOT, ARCANE_SHOT, EXPLOSIVE_SHOT, STEADY_SHOT, AIMED_SHOT, SCATTER_SHOT, KILL_SHOT, CHIMERA_SHOT, CONCUSSIVE_SHOT, DISTRACTING_SHOT, SILENCING_SHOT;
+
+        // STINGS
+        uint32 SERPENT_STING, SCORPID_STING, WYVERN_STING, VIPER_STING;
+
+        // DEBUFF
+        uint32 HUNTERS_MARK, SCARE_BEAST;
+
+        //AOE
+        uint32 VOLLEY, MULTI_SHOT;
+
+        //MELEE
+        uint32 RAPTOR_STRIKE, WING_CLIP, MONGOOSE_BITE, COUNTERATTACK;
+
+        //TRAP
+        uint32 FREEZING_TRAP, IMMOLATION_TRAP, FROST_TRAP, EXPLOSIVE_TRAP, SNAKE_TRAP, ARCANE_TRAP, FREEZING_ARROW, BLACK_ARROW;
+
+        //BUFF
+        uint32 TRUESHOT_AURA, DETERRENCE, FEIGN_DEATH, DISENGAGE, RAPID_FIRE, READINESS, MISDIRECTION;
+
+        //ASPECT
+        uint32 ASPECT_OF_THE_HAWK, ASPECT_OF_THE_MONKEY, ASPECT_OF_THE_VIPER;
+
+        uint32 TALENT_MM, TALENT_BM, TALENT_SURVIVAL;
+
+};
+
+#endif
+
+
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
new file mode 100644
index 0000000..1e33e03
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
@@ -0,0 +1,384 @@
+#include "PlayerbotMageAI.h"
+class PlayerbotAI;
+PlayerbotMageAI::PlayerbotMageAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai){\
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotMageAI::~PlayerbotMageAI(){}
+
+void PlayerbotMageAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //arcane
+    ARCANE_MISSILES = ai->getSpellIdExact("Arcane Missiles");
+    ARCANE_EXPLOSION = ai->getSpellIdExact("Arcane Explosion");
+    ARCANE_BLAST = ai->getSpellIdExact("Arcane Blast");
+    ARCANE_BARRAGE = ai->getSpellIdExact("Arcane Barrage");
+
+
+    //fire
+    FIREBALL = ai->getSpellIdExact("Fireball");
+    FROSTFIRE_BOLT = ai->getSpellIdExact("Frostfire Bolt");
+    FIRE_BLAST = ai->getSpellIdExact("Fire Blast");
+    FLAMESTRIKE = ai->getSpellIdExact("Flamestrike");
+    BLAST_WAVE = ai->getSpellIdExact("Blastwave");
+    SCORCH = ai->getSpellIdExact("Scorch");
+    PYROBLAST = ai->getSpellIdExact("Pyroblast");
+    LIVING_BOMB = ai->getSpellIdExact("Living Bomb");
+
+
+    //cold
+    FROSTBOLT = ai->getSpellIdExact("Frostbolt");
+    FROST_NOVA = ai->getSpellIdExact("Frost Nova");
+    ICE_LANCE = ai->getSpellIdExact("Ice Lance");
+    BLIZZARD = ai->getSpellIdExact("Blizzard");
+    CONE_OF_COLD = ai->getSpellIdExact("Cone of Cold");
+
+    WATER_ELEMENTAL = ai->getSpellIdExact("Summon Water Elemental");
+
+
+    // buffs
+    FROST_ARMOR = ai->getSpellIdExact("Ice Armor");
+    if (!FROST_ARMOR) FROST_ARMOR = ai->getSpellIdExact("Frost Armor");
+    MAGE_ARMOR = ai->getSpellIdExact("Mage Armor");
+    MOLTEN_ARMOR = ai->getSpellIdExact("Molten Armor");
+    FIRE_WARD = ai->getSpellIdExact("Fire Ward");
+    FROST_WARD = ai->getSpellIdExact("Frost Ward");
+    MANA_SHIELD = ai->getSpellIdExact("Mana Shield");
+    ICE_BARRIER = ai->getSpellIdExact("Ice Barrier");
+    POM = ai->getSpellIdExact("Presence of Mind");
+    FOCUS_MAGIC = ai->getSpellIdExact("Focus Magic");
+    ARCANE_POWER = ai->getSpellIdExact("Arance Power");
+    COMBUSTION = ai->getSpellIdExact("Combustion");
+    ICY_VEINS = ai->getSpellIdExact("Icy Veins");
+
+    ARCANE_INTELLECT = ai->getSpellIdExact("Arcane Intellect");
+    ARCANE_BRILLIANCE = ai->getSpellIdExact("Arcane Brilliance");
+    DALARAN_INTELLECT = ai->getSpellIdExact("Dalaran Intellect");
+    DALARAN_BRILLIANCE = ai->getSpellIdExact("Dalaran Brilliance");
+    DAMPEN_MAGIC = ai->getSpellIdExact("Dampen Magic");
+    AMPLIFY_MAGIC = ai->getSpellIdExact("Amplify Magic");
+
+
+    //CC
+    POLYMORPH = ai->getSpellIdExact("Polymorph");
+    DRAGONS_BREATH = ai->getSpellIdExact("Dragon's Breath");
+    DEEP_FREEZE = ai->getSpellIdExact("Deep Freeze");
+
+
+    //other
+    CONJURE_REFRESHMENT = ai->getSpellIdExact("Conjure Refreshment");
+    CONJURE_WATER = ai->getSpellIdExact("Conjure Water");
+    CONJURE_FOOD = ai->getSpellIdExact("Conjure Food");
+    CONJURE_MANA_GEM = ai->getSpellIdExact("Conjure Mana Gem");
+    MIRROR_IMAGE = ai->getSpellIdExact("Mirror Image");
+    BLINK = ai->getSpellIdExact("Blink");
+    ICE_BLOCK = ai->getSpellIdExact("Ice Block");
+    INVISIBILITY = ai->getSpellIdExact("Invisibility");
+    EVOCATION = ai->getSpellIdExact("Evocation");
+    REMOVE_CURSE = ai->getSpellIdExact("Remove Curse");
+    COUNTER_SPELL = ai->getSpellIdExact("Counterspell");
+    SLOW = ai->getSpellIdExact("Slow");
+
+    //Special
+    P_BRAIN_FREEZE = 57761; //Brain Freeze proc
+    P_FIRESTARTER = 54741; //Firestarter proc
+    P_HOT_STREAK = 48108; //Hot Sreak proc
+    P_ARCANE_BLAST = 36032; //Arcane blast proc
+	P_MISSILE_BARRAGE = 54490; //Missle Barrage proc
+	P_FINGERS_OF_FROST = 44545; //Fingers of Frost proc
+	IMP_SCORCH = 12873; //IMP SCORCH
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_ARCANE = ARCANE_BARRAGE;
+    TALENT_FIRE = COMBUSTION;
+    TALENT_FROST = ICE_BARRIER;
+
+    uint8 talentCounter = 0;
+    if (TALENT_ARCANE) talentCounter++;
+    if (TALENT_FIRE) talentCounter++;
+    if (TALENT_FROST) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ARCANE = 0; TALENT_FIRE = 0; TALENT_FROST = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotMageAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents (MAGE is always ranged dps)
+    m_role = BOT_ROLE_DPS_RANGED;
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (isUnderAttack())
+    {
+        // Keep hitting but reduce threat
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    if (DoSupportRaid(m_bot,30,0,0,0,1,1)) { return; }
+
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        //if (CastSpell(INVISIBILITY, m_bot)) { return; }
+        if (ai->GetHealthPercent(*pTarget) > 50 && CastSpell(POLYMORPH)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (isUnderAttack() && pDist > 5 && CastSpell(FROST_NOVA, pTarget)) { return; }
+    if (DEEP_FREEZE && pTarget->isFrozen() && CastSpell(DEEP_FREEZE,pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(DRAGONS_BREATH, pTarget)) { return; }
+    if ((isUnderAttack() || ai->GetHealthPercent() < 75 && !HasAuraName(m_bot, MANA_SHIELD))  && ai->GetManaPercent() > 40 && CastSpell(MANA_SHIELD,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    if ((ai->GetHealthPercent() < 65 || ai->GetManaPercent() < 5) && CastSpell(ICE_BLOCK,m_bot)) { return; }
+    if (isUnderAttack() && CastSpell(ICE_BARRIER, pTarget)) { return; }
+    if (ai->GetManaPercent() < 30 && CastSpell (EVOCATION, m_bot)) { return; }
+
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pThreat < threatThreshold && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(COUNTER_SPELL, pTarget)) { return; } //High threat
+	if (!m_bot->HasAura(MOLTEN_ARMOR) && CastSpell(MOLTEN_ARMOR,m_bot)) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) > 96) { return; } // dont dps too early
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(FROST_NOVA,pTarget)) return;
+        if (CastSpell(FROSTBOLT,pTarget)) return;
+    }
+
+    // If at threat limit, try to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(INVISIBILITY,m_bot)) { return; } //Lets see if we can manage
+            else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+
+    // buff up
+    if (CastSpell(ICY_VEINS,m_bot)) {} //nogcd
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+    if (CastSpell(POM,m_bot)) {} //nogcd
+
+	if (TALENT_ARCANE)
+	{
+		if (CastSpell(ARCANE_POWER,m_bot)) {} //nogcd
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+		//AOE
+		if (isUnderAttack(m_tank,5))
+		{
+			if (CastSpell(BLIZZARD,pTarget)) { return; }
+		}
+		//DPS
+		if (ARCANE_BLAST)
+        {
+            Aura *abaura = m_bot->GetAura(P_ARCANE_BLAST);
+            if (abaura && abaura->GetStackAmount() >= 3)
+			{
+				if (m_bot->HasAura(P_MISSILE_BARRAGE) && CastSpell(ARCANE_MISSILES,pTarget)) { return; }
+				else if (CastSpell(ARCANE_BARRAGE,pTarget)) { return; }
+			}
+        }
+        if (CastSpell(ARCANE_BARRAGE,pTarget) ) { return; }
+
+	}
+	if (TALENT_FIRE)
+	{
+		if (CastSpell(COMBUSTION,m_bot)) { } //nogcd
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+
+		//AOE
+		if (isUnderAttack(m_tank,5))
+		{
+			if (CastSpell(FLAMESTRIKE,pTarget)) { return; }
+			if (CastSpell(BLAST_WAVE,pTarget)) { return; }
+			if (CastSpell(LIVING_BOMB,pTarget)) { return; }
+			if (CastSpell(DRAGONS_BREATH,pTarget)) { return; }
+		}
+
+		//DPS
+		if (m_bot->HasAura(P_HOT_STREAK) && CastSpell(PYROBLAST,pTarget)) { return; }
+		if (!pTarget->HasAura(LIVING_BOMB,m_bot->GetGUID()) && CastSpell(LIVING_BOMB,pTarget)) { return; }
+		//if (!pTarget->HasAura(IMP_SCORCH) && CastSpell(SCORCH,pTarget)) { return; }
+		if (CastSpell(FIREBALL,pTarget)) { return; }
+	}
+	if (TALENT_FROST)
+	{
+		if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+        if (CastSpell(WATER_ELEMENTAL,m_bot)) { return; }
+
+        uint64 pet_guid = m_bot->GetPetGUID();
+        if (pet_guid>0){
+            Pet* pet = ObjectAccessor::GetPet(*m_bot, pet_guid);
+            Unit *unit = ObjectAccessor::GetUnit(*m_bot, pet_guid);
+            if (unit!=NULL){
+				if (!unit->isInCombat()) {
+                    m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, COMMAND_ATTACK, ACT_COMMAND, pTarget->GetGUID());
+				}
+            }
+        }
+
+        //if (CastSpell(33395, pTarget)) // pet freeze spell
+        //    sLog.outError ("successfully casted freeze");
+
+        //AOE
+        if (isUnderAttack(m_tank,5))
+        {
+            if (CastSpell(BLIZZARD,pTarget)) { return; }
+        }
+
+        //DPS
+        if (m_bot->HasAura(P_FINGERS_OF_FROST) && CastSpell(DEEP_FREEZE,pTarget)) { return; }
+        if (m_bot->HasAura(P_BRAIN_FREEZE) && CastSpell(FROSTFIRE_BOLT,pTarget)) { return; }
+        if (CastSpell(FROSTBOLT,pTarget,true,true)) { return; }
+
+    }
+
+    // Defaults especialy for lower levels
+    if (m_bot->HasAura(P_BRAIN_FREEZE) && CastSpell(FIREBALL,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(P_FIRESTARTER) && CastSpell(FLAMESTRIKE,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(P_HOT_STREAK) && CastSpell(PYROBLAST,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(POM) && (CastSpell(PYROBLAST,pTarget,1,1) || CastSpell(FIREBALL,pTarget,1,1) || CastSpell(FROSTBOLT,pTarget,1,1))) { return; }
+        if (pTarget->isFrozen() && CastSpell(ICE_LANCE,pTarget)) { return; }
+        if (m_bot->isMoving() && (CastSpell(FIRE_BLAST,pTarget,1,1) || CastSpell(ARCANE_BARRAGE,pTarget) || CastSpell(ICE_LANCE,pTarget))) { return; }
+        if (CastSpell(FIREBALL,pTarget)) { return; }
+        if (CastSpell(FROSTBOLT,pTarget)) { return; }
+        if (CastSpell(ARCANE_MISSILES,pTarget)) { return; }
+
+    // drink potion
+    if(ai->GetManaPercent() < 5 )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+    // if we get down here, it means we are out of mana, so use wand
+    CastSpell(SHOOT, pTarget);
+
+} //end DoNextCombatManeuver
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    // make sure pet stays by your side
+    uint64 pet_guid = m_bot->GetPetGUID();
+    if (pet_guid>0){
+        Pet* pet = ObjectAccessor::GetPet(*m_bot, pet_guid);
+        Unit *unit = ObjectAccessor::GetUnit(*m_bot, pet_guid);
+        if (unit!=NULL){
+            m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, COMMAND_FOLLOW, ACT_COMMAND, 0);
+            m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, REACT_DEFENSIVE, ACT_REACTION, 0);
+        }
+    }
+
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot,30,0,0,0,1,1)) { return; }
+
+    //Own Buffs
+    if (MOLTEN_ARMOR) { if ( CastSpell(MOLTEN_ARMOR,m_bot)) { return; } }
+    else if (CastSpell(MAGE_ARMOR,m_bot)) { return; }
+    if (CastSpell(COMBUSTION,m_bot)) { } //nogcd
+    if (!HasAuraName(m_bot, MANA_SHIELD)) CastSpell (MANA_SHIELD);
+
+    //conjure food & water
+    Item *pItem = ai->FindDrink();
+	if(pItem == NULL && ai->GetManaPercent() >= 48)
+    {
+        if (CastSpell(CONJURE_REFRESHMENT, m_bot)) { return; }
+        if (CastSpell(CONJURE_WATER, m_bot)) { return; }
+        return;
+    }
+    pItem = ai->FindFood();
+    if(pItem == NULL && ai->GetManaPercent() >= 48)
+    {
+        if (CastSpell(CONJURE_REFRESHMENT, m_bot)) { return; }
+        if (CastSpell(CONJURE_FOOD, m_bot)) { return; }
+        return;
+    }
+    //Conjure mana gem??
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 && CastSpell (EVOCATION, m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 || ai->GetHealthPercent() < 50) { ai->Feast(); }
+} //end DoNonCombatActions
+
+
+bool PlayerbotMageAI::BuffPlayer(Unit *target)
+{
+    if (!target || target->isDead()) return false;
+
+    if (target->getClass() == CLASS_WARRIOR || target->getClass() == CLASS_DEATH_KNIGHT || target->getClass() == CLASS_ROGUE) return false;
+
+    if (!HasAuraName(target, ARCANE_INTELLECT) && !HasAuraName(target, ARCANE_BRILLIANCE) && !HasAuraName(target, DALARAN_INTELLECT) && !HasAuraName(target, DALARAN_BRILLIANCE))
+    {
+        if (CastSpell(ARCANE_BRILLIANCE, target)) return true;
+        else if (CastSpell (ARCANE_INTELLECT, target)) return true;
+    }
+    return false;
+}
+bool PlayerbotMageAI::CureTarget(Unit *target)
+{
+	//Cures the target
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(DISPEL_CURSE, target)) return true;
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMageAI.h b/src/server/game/AI/PlayerBots/PlayerbotMageAI.h
new file mode 100644
index 0000000..307e519
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMageAI.h
@@ -0,0 +1,69 @@
+#ifndef _PLAYERBOTMAGEAI_H
+#define _PLAYERBOTMAGEAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_SCORCH,
+    SPELL_POM,
+    SPELL_ARCANE_POWER,
+    SPELL_FIREBALL,
+    SPELL_MISSILES,
+    SPELL_FROSTBOLT
+};
+
+//class Player;
+
+class PlayerbotMageAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotMageAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotMageAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        typedef std::set<Unit *> AttackerSet;
+    private:
+        //arcane
+        uint32 ARCANE_MISSILES, ARCANE_EXPLOSION, ARCANE_BLAST, ARCANE_BARRAGE;
+
+        //fire
+        uint32 FIREBALL, FROSTFIRE_BOLT, FIRE_BLAST, FLAMESTRIKE, BLAST_WAVE, SCORCH, PYROBLAST, LIVING_BOMB;
+
+        //cold
+        uint32 FROSTBOLT, FROST_NOVA, ICE_LANCE, BLIZZARD, CONE_OF_COLD, WATER_ELEMENTAL;
+
+        // buffs
+        uint32 FROST_ARMOR, ICE_ARMOR, MAGE_ARMOR, MOLTEN_ARMOR, FIRE_WARD, FROST_WARD, MANA_SHIELD, ICE_BARRIER, POM, FOCUS_MAGIC, ARCANE_POWER, COMBUSTION, ICY_VEINS,
+            ARCANE_INTELLECT, ARCANE_BRILLIANCE, DALARAN_INTELLECT, DALARAN_BRILLIANCE, DAMPEN_MAGIC, AMPLIFY_MAGIC;
+
+        //CC
+        uint32 POLYMORPH, DRAGONS_BREATH, DEEP_FREEZE;
+
+        //other
+        uint32 CONJURE_REFRESHMENT, CONJURE_WATER, CONJURE_FOOD, CONJURE_MANA_GEM, MIRROR_IMAGE, BLINK, ICE_BLOCK, INVISIBILITY, EVOCATION, REMOVE_CURSE, COUNTER_SPELL, SLOW, SHOOT;
+
+        //special
+        uint32 P_BRAIN_FREEZE, P_FIRESTARTER, P_HOT_STREAK, P_ARCANE_BLAST, P_MISSILE_BARRAGE, P_FINGERS_OF_FROST, IMP_SCORCH;
+
+
+        uint32 TALENT_ARCANE, TALENT_FIRE, TALENT_FROST;
+
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
new file mode 100644
index 0000000..c20e832
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
@@ -0,0 +1,536 @@
+#include "PlayerbotPaladinAI.h"
+
+class PlayerbotAI;
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotPaladinAI::~PlayerbotPaladinAI(){}
+
+void PlayerbotPaladinAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //heals
+    FLASH_OF_LIGHT = ai->getSpellIdExact("Flash of Light");
+    HOLY_LIGHT = ai->getSpellIdExact("Holy Light");
+    HOLY_SHOCK = ai->getSpellIdExact("Holy Shock");
+    CLEANSE = ai->getSpellIdExact("Cleanse");
+    if (!CLEANSE) CLEANSE = ai->getSpellIdExact("Purify");
+    LOH = ai->getSpellIdExact("Lay on Hands");
+    SACRED_SHIELD = ai->getSpellIdExact("Sacred Shield");
+    BEACON_OF_LIGHT = ai->getSpellIdExact("Beacon of Light");
+    DIVINE_FAVOR = ai->getSpellIdExact("Divine Favor");
+    REDEMPTION = ai->getSpellIdExact("Redemption");
+
+    //Damages
+    JOL = ai->getSpellIdExact("Judgement of Light");
+    JOW = ai->getSpellIdExact("Judgement of Wisdom");
+	JOJ = ai->getSpellIdExact("Judgement of Justice");
+    HAMMER_OF_WRATH = ai->getSpellIdExact("Hammer of Wrath");
+    EXORCISM = ai->getSpellIdExact("Exorcism");
+    HOLY_WRATH = ai->getSpellIdExact("Holy Wrath");
+    CONSECRATION = ai->getSpellIdExact("Consecration");
+    AVENGERS_SHIELD = ai->getSpellIdExact("Avenger's Shield");
+    SHIELD_OF_RIGHTEOUSNESS = ai->getSpellIdExact("Shield of Righteousness");
+    HOTR = ai->getSpellIdExact("Hammer of the Righteous");
+    CRUSADER_STRIKE = ai->getSpellIdExact("Crusader Strike");
+    DIVINE_STORM = ai->getSpellIdExact("Divine Storm");
+
+    //CC
+    HAMMER_OF_JUSTICE = ai->getSpellIdExact("Hammer of Justice");
+    REPENTANCE = ai->getSpellIdExact("Repentance");
+
+    //Self buffs
+    SOL = ai->getSpellIdExact("Seal of Light");
+    SOW = ai->getSpellIdExact("Seal of Wisdom");
+    SOR = ai->getSpellIdExact("Seal of Righteousness");
+    SOC = ai->getSpellIdExact("Seal of Command");
+	SOV = ai->getSpellIdExact("Seal of Vengeance");
+	if (!SOV) SOV = ai->getSpellIdExact("Seal of Corruption");
+    DIVINE_PLEA = ai->getSpellIdExact("Divine Plea");
+    HOLY_SHIELD = ai->getSpellIdExact("Holy Shield");
+    RIGHTEOUS_FURY = ai->getSpellIdExact("Righteous Fury");
+    DIVINE_SHIELD = ai->getSpellIdExact("Divine Shield");
+    if (!DIVINE_SHIELD) DIVINE_SHIELD = ai->getSpellIdExact("Divine Protection");
+    AVENGING_WRATH = ai->getSpellIdExact("Avenging Wrath");
+
+    //AURAS
+    DEVOTION_AURA = ai->getSpellIdExact("Devotion Aura");
+    RETRIBUTION_AURA = ai->getSpellIdExact("Retribution Aura");
+    CONCENTRATION_AURA = ai->getSpellIdExact("Concentration Aura");
+    FIRE_AURA = ai->getSpellIdExact("Fire Resistance Aura");
+    FROST_AURA = ai->getSpellIdExact("Frost Resistance Aura");
+    SHADOW_AURA = ai->getSpellIdExact("Shadow Resistance Aura");
+    CRUSADER_AURA = ai->getSpellIdExact("Crusader Aura");
+
+    //Blessings
+    BOW = ai->getSpellIdExact("Blessing of Wisdom");
+    BOM = ai->getSpellIdExact("Blessing of Might");
+    BOS = ai->getSpellIdExact("Blessing of Sanctuary");
+    BOK = ai->getSpellIdExact("Blessing of Kings");
+    GBOW = ai->getSpellIdExact("Greater Blessing of Wisdom");
+    GBOM = ai->getSpellIdExact("Greater Blessing of Might");
+    GBOS = ai->getSpellIdExact("Greater Blessing of Sanctuary");
+    GBOK = ai->getSpellIdExact("Greater Blessing of Kings");
+
+    //Hands
+    HOF = ai->getSpellIdExact("Hand of Freedom");
+    HOR = ai->getSpellIdExact("Hand of Reckoning");
+    HOS = ai->getSpellIdExact("Hand of Salvation");
+    HOP = ai->getSpellIdExact("Hand of Protection");
+    DIVINE_SACRIFICE = ai->getSpellIdExact("Divine Sacrifice");
+
+    //Taunt
+    RIGHTEOUS_DEFENSE = ai->getSpellIdExact("Righteous Defense");
+
+    FORBEARANCE = 25771;
+	AOW = 53488;
+
+    TALENT_RETRI = CRUSADER_STRIKE;
+    TALENT_PROT = HOLY_SHIELD;
+    TALENT_HOLY = HOLY_SHOCK;
+
+    uint8 talentCounter = 0;
+    if (TALENT_RETRI) talentCounter++;
+    if (TALENT_PROT) talentCounter++;
+    if (TALENT_HOLY) talentCounter++;
+    //if (talentCounter > 1) { TALENT_RETRI = 0; TALENT_PROT = 0; TALENT_HOLY = 0; } //Unreliable Talent detection.
+
+    #pragma endregion
+}
+
+void PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+
+    // Fill mana if needed
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && ai->GetManaPercent() < 20 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (ai->GetManaPercent() < 30 && CastSpell (DIVINE_PLEA, m_bot)) { return; }
+
+    // If hp is too low divine shield
+    if (ai->GetHealthPercent() < 20 && (!m_bot->HasAura(DIVINE_SHIELD) || !m_bot->HasAura(HOP) || !m_bot->HasAura(SACRED_SHIELD)))
+    {
+        if (!m_bot->HasAura(FORBEARANCE))
+        {
+            if (CastSpell(DIVINE_SHIELD,m_bot)) { return; }
+            if (CastSpell(HOP,m_bot)) { return; }
+        }
+        else if (CastSpell(SACRED_SHIELD,m_bot)) { return; }
+    }
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && !TALENT_PROT && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(HOS,m_bot,true,true)) { }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        if (TALENT_PROT) { m_role=BOT_ROLE_TANK; } //Just Keep Tanking
+        else
+        {
+            if (TALENT_RETRI) {
+                if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else { m_role = BOT_ROLE_TANK; } //have no shield but can tank if you think so
+            }
+            else if (TALENT_HOLY) //I am both healer and tank?? Hmm
+            {
+                if ((ai->GetHealthPercent() <= 70 || masterHP <70 ) && (ai->GetManaPercent() >= 50))m_role = BOT_ROLE_SUPPORT;
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else m_role = BOT_ROLE_TANK;
+            }
+            else { m_role = BOT_ROLE_TANK; } //Unknown build or low level
+        }
+    }
+    else if (TALENT_RETRI) {
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) {m_role = BOT_ROLE_SUPPORT;}
+        else { m_role = BOT_ROLE_DPS_MELEE; }
+    }
+    else if (TALENT_PROT) {
+        if ((ai->GetHealthPercent() <= 30 || masterHP <40 ) && (ai->GetManaPercent() >= 20)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 40) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_OFFTANK; }
+    }
+    else if (TALENT_HOLY) { m_role = BOT_ROLE_SUPPORT; }
+    else { m_role = BOT_ROLE_DPS_MELEE; } //Unknown build or low level.. Mainly attack
+
+	//takepos
+    if (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) TakePosition(pTarget,BOT_ROLE_DPS_MELEE,0.5f);
+    else TakePosition(pTarget,m_role);
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+
+            ChangeAura(CONCENTRATION_AURA);
+            if (!TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID()) m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+            // Choose Seal
+            if (SOW && ai->GetManaPercent() <= 30) {    if (CastSpell(SOW,m_bot)) { return; } }
+            else if (m_bot->HasAura(SOW) && ai->GetManaPercent() < 85) { } // Paladin was striving for mana, keep until he got most of his mana back
+            else if(SOL && ai->GetHealthPercent() < 40) { if(CastSpell(SOL,m_bot)) { return; } }
+            else if(CastSpell(SOR, m_bot)) { return; }
+
+            if (!m_bot->HasAura(FORBEARANCE) && CastSpell(AVENGING_WRATH,m_bot)) { } // no gcd
+
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            if (ai->GetManaPercent() <= 80 && CastSpell(JOW,pTarget,true,true)) { return; }
+
+            // Use Spells only if mana is sufficient..
+            if(ai->GetManaPercent() < offensiveSpellThreshold ) return;
+
+        break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_TANK:
+        case BOT_ROLE_OFFTANK:
+
+            ChangeAura(DEVOTION_AURA);
+            if (CastSpell(RIGHTEOUS_FURY,m_bot)) { return; }
+            // Choose Seal
+            if (SOW && ai->GetManaPercent() <= 30) { if (CastSpell(SOW,m_bot)) { return; } }
+            else if (m_bot->HasAura(SOW) && ai->GetManaPercent() < 85) { } // Paladin was striving for mana, keep until he got most of his mana back
+            else if (SOL && ai->GetHealthPercent() < 40) { if (CastSpell(SOL,m_bot)) { return; } }
+            else if (CastSpell(SOR,m_bot)) { return; }
+
+            // We are tank/offtank threat is not an issiue;
+            // Use taunts only if helping target is not main tank..
+            // Taunt if needed (Only for master)
+            if(GetMaster()->GetGUID() != m_tank->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt)
+                {
+                    if (isUnderAttack(GetMaster(),2) && CastSpell(RIGHTEOUS_DEFENSE, GetMaster())) { return; }
+                    if (CastSpell(HOR, curAtt,true,true))  { } //No GCD
+                }
+            }
+            // My target is not attacking me, taunt..
+            if ( m_tank->GetGUID() == m_bot->GetGUID() && pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(HOR, pTarget,true,true) )  { } //NO GCD
+
+            // Tank specials
+            if (TALENT_PROT && ai->GetManaPercent() < 90 && CastSpell (DIVINE_PLEA, m_bot)) { return; } //Prot paladin always uses this..
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && CastSpell(HOLY_SHIELD,m_bot)) { return; }
+            if (CastSpell(AVENGERS_SHIELD,pTarget,true,true)) { return; }
+            if (CastSpell(HOTR,pTarget,true,true)) { return; }
+            if (CastSpell(HOLY_WRATH,pTarget,true,true)){ return; }
+            if (CastSpell(CONSECRATION,pTarget)) { return; }
+            if (m_bot->getRace() == (uint8) RACE_DWARF && CastSpell(R_STONEFORM,m_bot)) { return; }
+
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+
+        break;
+		#pragma endregion
+
+		#pragma region BOT_ROLE_DPS_MELEE
+		case BOT_ROLE_DPS_MELEE:
+
+			ChangeAura(RETRIBUTION_AURA);
+			if (!TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID()) m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+			if (CastSpell(SOV,m_bot)) { return; }
+
+			if (CastSpell (HAMMER_OF_JUSTICE, pTarget)) { return; }
+			if (!m_bot->HasAura(FORBEARANCE) && CastSpell(AVENGING_WRATH,m_bot)) {} //no gcd
+			if (CastSpell(JOW,pTarget)) { return; }
+			if (CastSpell(DIVINE_STORM, pTarget)) { return; }
+			if (CastSpell(CRUSADER_STRIKE, pTarget)) { return; }
+			if (GetAI()->GetHealthPercent(*pTarget)<20 && CastSpell(HAMMER_OF_WRATH, pTarget)) { return; }
+			if (CastSpell(CONSECRATION,pTarget)) { return; }
+			if (m_bot->HasAura(AOW) && CastSpell(EXORCISM,pTarget)) { return; }
+			if (CastSpell(HOLY_WRATH,pTarget)) { return; }
+
+		break;
+        #pragma endregion
+
+    }
+    #pragma region PaladinCommon
+    // Shared dps spells
+    if (pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_HUMANOID && pTarget->IsNonMeleeSpellCasted(true) && CastSpell (REPENTANCE, pTarget)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} // no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} // no GCD
+
+    // If at threat limit, stop
+    if(pThreat > threatThreshold && !TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(HOS,m_bot)) { return; } //Lets see if we can manage with HOS
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+    // Continue attacking if theres excess mana (for healers)
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+
+    if (GetAI()->GetHealthPercent(*pTarget)<20 && CastSpell(HAMMER_OF_WRATH, pTarget,true,true)) { return; } //no gcd but cast
+    if (CastSpell (HAMMER_OF_JUSTICE, pTarget)) { return; }
+    if (CanCast(JOW,pTarget,true) &&
+        ( ( ai->GetManaPercent() <= 70 && ai->GetHealthPercent() > 90)
+        || ( ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 75)
+        || ( ai->GetManaPercent() <= 20 && ai->GetHealthPercent() > 20) )
+        && CastSpell(JOW,pTarget,false)) { return; }
+    else if (CastSpell(JOL,pTarget),true,true) { return; }
+    if (CastSpell(SHIELD_OF_RIGHTEOUSNESS,pTarget,true,true)) { return; }
+    if (CastSpell (DIVINE_STORM, pTarget,true,true)) { return; }
+    if (CastSpell (CRUSADER_STRIKE, pTarget,true,true)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no GCD but cast
+    if (isUnderAttack(m_tank,4) && CastSpell(HOLY_WRATH,pTarget,true,true)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(CONSECRATION,pTarget)) { return; }
+    if (CastSpell(HOLY_SHOCK,pTarget,true,true)) { return; }
+    if (m_role != BOT_ROLE_SUPPORT && ai->GetManaPercent() > 60 && OwnPartyHP < 65 && DoSupportRaid(m_bot)) { return; } //if there is spare time and mana, do healz and other stuff..
+    else if (m_role != BOT_ROLE_SUPPORT && ai->GetManaPercent() > 30 && DoSupportRaid(m_bot,30,false,false,false,true,false)) { return; }
+    if (CastSpell(EXORCISM,pTarget,true,true)) { return; }
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+    #pragma endregion
+
+} //end DoNextCombatManeuver
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(FLASH_OF_LIGHT,m_bot)) { return; }
+    if (ai->GetManaPercent() < 70) { ai->Feast(); }
+} //end DoNonCombatActions
+
+bool PlayerbotPaladinAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if(hp < 10 && m_bot->isInCombat() && CastSpell(LOH, target)) { return true; }
+    if(hp < 10 && m_bot->isInCombat() && CastSpell(SACRED_SHIELD,target)) { return true; }
+    if(hp < 15 && m_bot->isInCombat() && CastSpell(HOP,target)) { return true; }
+    if(hp < 20 && m_bot->isInCombat() && CastSpell(BEACON_OF_LIGHT,target)) { return true; }
+    if(hp < 30 && CastSpell(HOLY_SHOCK,target,true,true,true)) { return true; }
+    if(hp < 30 && m_bot->isInCombat() && CanCast(DIVINE_FAVOR,m_bot,true) && CanCast(HOLY_LIGHT,target,true) ) { CastSpell(DIVINE_FAVOR, m_bot,false); return CastSpell(HOLY_LIGHT,target,false); } //No gcd
+    if(hp < 30 && CastSpell(FLASH_OF_LIGHT,target,true,true)) { return true; }
+    if(hp < 40 && m_bot->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) { return true; } // no GCD but has cast
+    if(hp < 65 && CastSpell(HOLY_LIGHT,target,true,true)) { return true; }
+    if(hp < 85 && CastSpell(FLASH_OF_LIGHT,target,true,true)) { return true; }
+    if(hp < 95 && m_bot->isInCombat() && CastSpell(BEACON_OF_LIGHT,target)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotPaladinAI::CureTarget(Unit *target)
+{
+    if (!target || target->isDead()) { return false; }
+    if (castDispel(CLEANSE, target)) { return true; }
+    return false;
+
+} //end CureTarget
+
+bool PlayerbotPaladinAI::BuffPlayer(Unit *target)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    // Check if target already has a blessing by me..
+    if (HasAuraName(target,BOW,m_bot->GetGUID()) ||
+    HasAuraName(target,BOK,m_bot->GetGUID()) ||
+    HasAuraName(target,BOM,m_bot->GetGUID()) ||
+    HasAuraName(target,BOS,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOW,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOK,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOM,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOS,m_bot->GetGUID())
+    ) return false;
+
+#pragma region Choose Buff > Class
+    switch(target->getClass())
+    {
+        case CLASS_MAGE:
+        case CLASS_WARLOCK:
+            if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_PRIEST:
+            if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_HUNTER:
+            if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_ROGUE:
+            if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_WARRIOR:
+        case CLASS_DEATH_KNIGHT:
+            if (target->GetUnitDodgeChance() + target->GetUnitParryChance() > 40)
+            {
+                if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            }
+            else
+            {
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            }
+            break;
+        case CLASS_DRUID:
+        case CLASS_SHAMAN:
+        case CLASS_PALADIN:
+            if (target->GetMaxPower(target->getPowerType()) > target->GetMaxHealth())
+            {
+                if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            }
+            else if (target->GetUnitDodgeChance() + target->GetUnitParryChance() > 40)
+            {
+                if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            }
+            else
+            {
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            }
+            break;
+
+        default:
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                break;
+    }
+#pragma endregion
+
+    return false;
+}
+
+bool PlayerbotPaladinAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(REDEMPTION,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(REDEMPTION, target, false);
+}
+
+bool PlayerbotPaladinAI::ChangeAura(uint32 aura)
+{
+    Player *m_bot = GetPlayerBot();
+    if(!aura) return false;
+
+    if(!CanCast(aura,m_bot)) return false;
+
+    if(m_bot->HasAura(aura))
+    {
+        if (aura == DEVOTION_AURA)
+        {
+            if (ChangeAura(FIRE_AURA)) return true;
+            if (ChangeAura(FROST_AURA)) return true;
+            if (ChangeAura(SHADOW_AURA)) return true;
+            return true;
+        }
+        else return ChangeAura(DEVOTION_AURA);
+    }
+    return CastSpell(aura,m_bot,false);
+}
+
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
new file mode 100644
index 0000000..72c6beb
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERBOTPALADINAI_H
+#define _PLAYERBOTPALADINAI_H
+
+#include "PlayerbotClassAI.h"
+#include "SharedDefines.h"
+
+class PlayerbotPaladinAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotPaladinAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotPaladinAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget (Unit *target);
+
+        bool ChangeAura(uint32 aura);
+
+    private:
+        //heals
+        uint32 FLASH_OF_LIGHT, HOLY_LIGHT, HOLY_SHOCK, REZZ, CLEANSE, LOH, SACRED_SHIELD, BEACON_OF_LIGHT, DIVINE_FAVOR, REDEMPTION;
+
+        //Damages
+        uint32 JOL, JOW, JOJ, HAMMER_OF_WRATH, EXORCISM, HOLY_WRATH, CONSECRATION, AVENGERS_SHIELD, SHIELD_OF_RIGHTEOUSNESS, HOTR, CRUSADER_STRIKE, DIVINE_STORM;
+
+        //CC
+        uint32 HAMMER_OF_JUSTICE, REPENTANCE;
+
+        //Self buffs
+        uint32 SOL, SOW, SOR, SOC, SOV, DIVINE_PLEA, HOLY_SHIELD, RIGHTEOUS_FURY, DIVINE_SHIELD, AVENGING_WRATH;
+
+        //AURAS
+        uint32 DEVOTION_AURA, RETRIBUTION_AURA, CONCENTRATION_AURA, FIRE_AURA, FROST_AURA, SHADOW_AURA, CRUSADER_AURA ;
+
+        //Blessings
+        uint32 BOW, BOM, BOS, BOK, GBOW, GBOM, GBOS, GBOK;
+
+        //Hands
+        uint32 HOF, HOR, HOS, HOP, DIVINE_SACRIFICE;
+
+        //Taunt
+        uint32 RIGHTEOUS_DEFENSE;
+
+        uint32 FORBEARANCE;
+
+        uint32 TALENT_HOLY, TALENT_PROT, TALENT_RETRI;
+
+		//procs
+		uint32 AOW;
+
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
new file mode 100644
index 0000000..729316f
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
@@ -0,0 +1,400 @@
+/*
+Name : PlayerbotPriest.cpp
+Complete: maybe around 55%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - Holy And Disc builds do not cast any offensive spells requiring cast time..(To compensate for the fact that Healing decision is not that intelligent)
+                - Priest breaks her own CCs.. Need a check for bots to not attack CC ed mobs..
+                - Wand usage is not very smooth..
+
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+#include "PlayerbotPriestAI.h"
+
+class PlayerbotAI;
+PlayerbotPriestAI::PlayerbotPriestAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotPriestAI::~PlayerbotPriestAI(){}
+
+void PlayerbotPriestAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //heals
+    RENEW = ai->getSpellIdExact("Renew");
+    FLASH_HEAL = ai->getSpellIdExact("Flash Heal");
+    if (!FLASH_HEAL) FLASH_HEAL = ai->getSpellIdExact("Lesser Heal");
+    HEAL = ai->getSpellIdExact("Greater Heal");
+    if (!HEAL) HEAL = ai->getSpellIdExact("Heal");
+    if (!HEAL) HEAL = FLASH_HEAL;
+    BINDING_HEAL = ai->getSpellIdExact("Binding Heal");
+    PO_MENDING = ai->getSpellIdExact("Prayer of Mending");
+    DESPERATE_PRAYER = ai->getSpellIdExact("Desperate Prayer");
+    PO_HEALING = ai->getSpellIdExact("Prayer of Healing");
+    CIRCLE_OF_HEALING = ai->getSpellIdExact("Circle of Healing");
+    DIVINE_HYMN = ai->getSpellIdExact("Divine Hymn");
+    RESURRECTION = ai->getSpellIdExact("Resurrection");
+    HYMN_OF_HOPE = ai->getSpellIdExact("Hymn of Hope");
+    CURE_DISEASE = ai->getSpellIdExact("Abolish Disease");
+    if (!CURE_DISEASE) CURE_DISEASE = ai->getSpellIdExact("Abolish Disease");
+    DISPEL_MAGIC = ai->getSpellIdExact("Dispel Magic");
+    MASS_DISPEL = ai->getSpellIdExact("Mass Dispel");
+
+    //Holy Offensive
+    SMITE = ai->getSpellIdExact("Smite");
+    HOLY_FIRE = ai->getSpellIdExact("Holy Fire");
+    PENANCE = ai->getSpellIdExact("Penance");
+    HOLY_NOVA = ai->getSpellIdExact("Holy Nova");
+
+    //Shadow Offensive
+    MIND_BLAST = ai->getSpellIdExact("Mind Blast");
+    SW_PAIN = ai->getSpellIdExact("Shadow Word: Pain");
+    DEVOURING_PLAGUE = ai->getSpellIdExact("Devouring Plague");
+    MIND_FLAY = ai->getSpellIdExact("Mind Flay");
+    VAMPIRIC_EMBRACE = ai->getSpellIdExact("Vampiric Embrace");
+    VAMPIRIC_TOUCH = ai->getSpellIdExact("Vampiric Touch");
+    SW_DEATH = ai->getSpellIdExact("Shadow Word: Death");
+    MIND_SEAR = ai->getSpellIdExact("Mind Sear");
+    MANA_BURN = ai->getSpellIdExact("Mana Burn");
+    SHADOWFIEND = ai->getSpellIdExact("Shadowfiend");
+
+    //CC - Breaker
+    PSYCHIC_SCREAM = ai->getSpellIdExact("Psychic Scream");
+    PSYCHIC_HORROR = ai->getSpellIdExact("Psychic Horror");
+    MIND_SOOTHE = ai->getSpellIdExact("Mind Soothe");
+    SHACKLE_UNDEAD = ai->getSpellIdExact("Shackle Undead");
+    SILENCE = ai->getSpellIdExact("Silence");
+    MIND_CONTROL = ai->getSpellIdExact("Mind Control");
+
+    //buffs
+    PW_SHIELD = ai->getSpellIdExact("Power Word: Shield");
+    INNER_FIRE = ai->getSpellIdExact("Inner Fire");
+    GUARDIAN_SPIRIT = ai->getSpellIdExact("Guardian Spirit");
+    FADE = ai->getSpellIdExact("Fade");
+    INNER_FOCUS = ai->getSpellIdExact("Inner Focus");
+    POWER_INFUSION = ai->getSpellIdExact("Power Infusion");
+    PAIN_SUPPRESSION = ai->getSpellIdExact("Pain Suppression");
+    SHADOWFORM = ai->getSpellIdExact("Shadowform");
+    DISPERSION = ai->getSpellIdExact("Dispersion");
+    LIGHTWELL = ai->getSpellIdExact("Lightwell");
+
+    PW_FORTITUDE = ai->getSpellIdExact("Power Word: Fortitude");
+    DIVINE_SPIRIT = ai->getSpellIdExact("Divine Spirit");
+    SHADOW_PROTECTION = ai->getSpellIdExact("Shadow Protection");
+    PO_FORTITUDE = ai->getSpellIdExact("Prayer of Fortitude");
+    PO_SPIRIT = ai->getSpellIdExact("Prayer of Spirit");
+    PO_SHADOW_PROTECTION = ai->getSpellIdExact("Prayer of Shadow Protection");
+    FEAR_WARD = ai->getSpellIdExact("Fear Ward");
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_DISC = PAIN_SUPPRESSION;
+    TALENT_HOLY = CIRCLE_OF_HEALING;
+    TALENT_SHADOW = SHADOWFORM;
+
+    uint8 talentCounter = 0;
+    if (TALENT_DISC) talentCounter++;
+    if (TALENT_HOLY) talentCounter++;
+    if (TALENT_SHADOW) talentCounter++;
+    if (talentCounter > 1) { TALENT_DISC = 0; TALENT_HOLY = 0; TALENT_SHADOW = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+    /*
+    switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            (ai->HasAura(SCREAM, pTarget) && ai->GetHealthPercent() < 60 && CastSpell(HEAL)) ||
+            CastSpell(PAIN) ||
+            (ai->GetHealthPercent() < 80 && CastSpell(RENEW)) ||
+            (m_bot->GetDistance(pTarget) <= 5 && CastSpell(SCREAM)) ||
+            CastSpell(MIND_BLAST) ||
+            (ai->GetHealthPercent() < 20 && CastSpell(FLASH_HEAL)) ||
+            CastSpell(SMITE);
+            return;
+    }*/
+
+
+    //------- Non Duel combat ----------
+
+
+    // Cast CC breakers if any match found (include any dispels first)  does not work yet
+    //uint32 ccSpells[6] = { DISPEL_MAGIC, CURE_DISEASE, DISPERSION, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    //if (ai->GetManaPercent() < 35) { ccSpells[0] = 0; ccSpells[1] = 0; } //We dont have any mana to waste...
+    //if (castSelfCCBreakers(ccSpells)) {  } // Most of them don't trigger gcd
+
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        m_role = BOT_ROLE_DPS_RANGED;
+    }
+    else if (TALENT_SHADOW) {
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 30)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 40) {m_role = BOT_ROLE_SUPPORT;}
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+    else { m_role = BOT_ROLE_SUPPORT; } //Unknown build or low level.. Mainly attack
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(FADE,m_bot)) { return; }
+        else if (CastSpell(PAIN_SUPPRESSION,m_bot)) { return; }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+
+    if (m_role == BOT_ROLE_DPS_RANGED && CastSpell(SHADOWFORM,m_bot)) { return; }
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetForm() == FORM_SHADOW) { m_bot->RemoveAurasDueToSpell(SHADOWFORM); }
+
+    //Buff
+    if (CastSpell(INNER_FIRE,m_bot)) { } //nogcd
+    if (CastSpell(POWER_INFUSION,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+
+    if (ai->GetForm() != FORM_SHADOW)
+    {
+        if (PO_MENDING && ai->GetHealthPercent(*m_tank) < 90 && !HasAuraName(m_tank, "Prayer of Mending") && CastSpell(PO_MENDING,m_tank)) { return; } //MEND tank first
+        if (DoSupportRaid(m_bot)) { return; }
+        //heal pets and bots
+        Unit *target = DoSelectLowestHpFriendly(30, 1000);
+        if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+    }
+    if (ai->GetForm() == FORM_SPIRITOFREDEMPTION) { return; } //You're dead..
+
+
+    //PROTECT
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (PSYCHIC_HORROR && CastSpell(PSYCHIC_HORROR, pTarget)) { return; }
+        if (PSYCHIC_SCREAM && CastSpell(PSYCHIC_SCREAM, pTarget)) { return; }
+        if (SHACKLE_UNDEAD && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_UNDEAD && CastSpell(SHACKLE_UNDEAD, pTarget)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (ai->GetHealthPercent() < 20 && CastSpell(DESPERATE_PRAYER)) { return; }
+    if (ai->GetHealthPercent() < 30 && CastSpell(PW_SHIELD)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (ai->GetHealthPercent() < 60 && CastSpell(PAIN_SUPPRESSION,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 50 && ai->GetManaPercent() < 10 && CastSpell(DISPERSION,m_bot)) { return; }
+    if (ai->GetManaPercent() < 10 && CastSpell (HYMN_OF_HOPE, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+
+
+    //Break Spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SILENCE, pTarget)) { return; }
+
+
+    // If at threat limit, try to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(PAIN_SUPPRESSION,m_bot)) { return; } //Lets see if we can manage
+            else if (CastSpell(FADE,m_bot)) { return; }
+            else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+    //WAND
+    if (ai->GetManaPercent() < 5 ||
+        (m_role != BOT_ROLE_DPS_RANGED && SHOOT && !m_bot->FindCurrentSpellBySpellId(SHOOT) && ai->CastSpell(SHOOT,pTarget) )
+        ) { return; } //Start autoshot
+
+    // Continue spell attacking if theres excess mana (for healers)
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) > 95) { return; } // dont dps too early
+
+    if (CastSpell(VAMPIRIC_EMBRACE,pTarget)) { return; }
+    if (CastSpell(VAMPIRIC_TOUCH,pTarget)) { return; }
+    if (CastSpell(DEVOURING_PLAGUE,pTarget)) { return; }
+    if (CastSpell(SW_PAIN,pTarget)) { return; }
+
+    if (ai->GetForm() == FORM_SHADOW)
+    {
+        if (castDispel(DISPEL_MAGIC, pTarget)) { return; } //Dispel buffs if any
+        if (CastSpell(MIND_BLAST,pTarget)) { return; }
+        if (CastSpell(MIND_FLAY,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(MIND_SEAR,pTarget)) { return; }
+    }
+
+    if (ai->GetForm() == FORM_NONE && m_role == BOT_ROLE_DPS_RANGED)
+    {
+        if (CastSpell(PENANCE,pTarget)) { return; }
+        if (CastSpell(MIND_BLAST,pTarget)) { return; }
+        if (CastSpell(HOLY_FIRE,pTarget)) { return; }
+        if (CastSpell(SMITE,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(MIND_SEAR,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(HOLY_NOVA,pTarget)) { return; }
+    }
+
+     // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+} //end DoNextCombatManeuver
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Own Buffs
+    if (CastSpell(INNER_FIRE,m_bot)) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(30, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(FLASH_HEAL,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+
+
+bool PlayerbotPriestAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if (hp < 30 && m_bot->isInCombat() && CastSpell(GUARDIAN_SPIRIT,target)) { } //nogcd
+    if (hp < 30 && CastSpell(PENANCE,target,true,false,true)) { return true; } //Channeling Dual purpose
+    if (hp < 35 && m_bot->isInCombat() && CastSpell(PW_SHIELD,target)) { return true; } //Check weakened soul
+    if (hp < 80 && hp > 50 && GetAI()->GetHealthPercent() < 80 && CastSpell (BINDING_HEAL,target)) { return true; }
+    if (hp < 85 && CastSpell(RENEW,target)) { return true; }
+    if (hp < 40 && GetPlayerBot()->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) { return true; } // no GCD, but has cast
+    if (hp < 55 && hp > 35 && CastSpell(HEAL,target)) { return true; }
+    if (hp < 75 && CastSpell(FLASH_HEAL,target)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotPriestAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    Player *m_bot = GetPlayerBot();
+    if (countNeedHeal < 2) { return false; }
+    Unit *rTarget = DoSelectLowestHpFriendly(30,500);
+    if (!rTarget || rTarget->isDead() || rTarget->GetHealth() * 100 / rTarget->GetMaxHealth() > 80 ) { return false; }
+
+    // if (hp < 75 && CastSpell(PO_MENDING, rTarget)) { return true; } //save this for tank
+    if (hp < 35 && m_bot->isInCombat() && CastSpell(DIVINE_HYMN,rTarget)) { /*GetAI()->SetIgnoreUpdateTime(9);*/ return true; }
+    if (hp < 70 && CastSpell(CIRCLE_OF_HEALING,rTarget)) { return true; }
+    if (hp < 75 && hp > 30 && countNeedHeal > 4 && CastSpell(PO_HEALING)) { return true; }
+    if (hp < 65 && CastSpell(HOLY_NOVA,rTarget,true,false,true)) { return true; }
+
+    return false;
+}
+
+//Cures the target
+bool PlayerbotPriestAI::CureTarget(Unit *target)
+{
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(DISPEL_MAGIC, target,true,false,true)) return true;
+    if (castDispel(CURE_DISEASE, target)) return true;
+    // if(HasAuraName(target, "Venom Spit") || HasAuraName(target, "Poison")) return CastSpell(CURE_POISON, target);
+    return false;
+}
+
+bool PlayerbotPriestAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(RESURRECTION,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+   // msg += " with ";
+   // msg += *REZZSpell->SpellName;
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(RESURRECTION, target,false);
+}
+
+bool PlayerbotPriestAI::BuffPlayer(Unit *target)
+{
+    if(!target || target->isDead()) return false;
+
+    return (
+        (!HasAuraName(target, PW_FORTITUDE) && !HasAuraName(target, PO_FORTITUDE) && CastSpell (PW_FORTITUDE, target)) ||
+        (!HasAuraName(target, SHADOW_PROTECTION) && !HasAuraName(target, PO_SHADOW_PROTECTION) && CastSpell(SHADOW_PROTECTION, target)) ||
+        (!HasAuraName(target, DIVINE_SPIRIT) && !HasAuraName(target, PO_SPIRIT) && CastSpell (DIVINE_SPIRIT, target)) ||
+        (!HasAuraName(target, FEAR_WARD) && CastSpell (FEAR_WARD, target))
+         );
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
new file mode 100644
index 0000000..9670986
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
@@ -0,0 +1,59 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotPriestAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPriestAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+    virtual ~PlayerbotPriestAI();
+
+    virtual void LoadSpells();
+
+    //all combat actions go here
+    void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Unit *target);
+
+    //Heals the target based off its HP
+    bool HealTarget(Unit *target, uint8 hp);
+
+    bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+    //Cures the target
+    bool CureTarget(Unit *target);
+
+    bool RezTarget (Unit *target);
+
+private:
+    //heals
+    uint32 RENEW, FLASH_HEAL, HEAL, BINDING_HEAL, PO_MENDING, DESPERATE_PRAYER, PO_HEALING, CIRCLE_OF_HEALING, DIVINE_HYMN, RESURRECTION, HYMN_OF_HOPE, CURE_DISEASE, DISPEL_MAGIC, MASS_DISPEL;
+
+    //Holy Offensive
+    uint32 SMITE, HOLY_FIRE, PENANCE, HOLY_NOVA;
+
+    //Shadow Offensive
+    uint32 MIND_BLAST, SW_PAIN, DEVOURING_PLAGUE, MIND_FLAY, VAMPIRIC_EMBRACE, VAMPIRIC_TOUCH, SW_DEATH, MIND_SEAR, MANA_BURN, SHADOWFIEND;
+
+    //CC - Breaker
+    uint32 PSYCHIC_SCREAM, PSYCHIC_HORROR, MIND_SOOTHE, SHACKLE_UNDEAD, SILENCE, MIND_CONTROL;
+
+    //buffs
+    uint32 PW_SHIELD, INNER_FIRE, GUARDIAN_SPIRIT, FADE, INNER_FOCUS, POWER_INFUSION, PAIN_SUPPRESSION, SHADOWFORM, DISPERSION, LIGHTWELL,
+        PW_FORTITUDE, DIVINE_SPIRIT, SHADOW_PROTECTION, PO_FORTITUDE, PO_SPIRIT, PO_SHADOW_PROTECTION, FEAR_WARD;
+
+    uint32 SHOOT;
+
+    uint32 TALENT_DISC, TALENT_HOLY, TALENT_SHADOW;
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
new file mode 100644
index 0000000..2715d3f
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
@@ -0,0 +1,266 @@
+#include "PlayerbotRogueAI.h"
+#include "Spell.h"
+class PlayerbotAI;
+PlayerbotRogueAI::PlayerbotRogueAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotRogueAI::~PlayerbotRogueAI(){}
+
+void PlayerbotRogueAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //Damage spells
+    BACKSTAB = ai->getSpellIdExact("Backstab");
+    SINISTER_STRIKE = ai->getSpellIdExact("Sinister Strike");
+    MUTILATE = ai->getSpellIdExact("Mutilate");
+    HEMORRHAGE = ai->getSpellIdExact("Hemorrhage");
+    GHOSTLY_STRIKE = ai->getSpellIdExact("Ghostly Strike");
+    RIPOSTE = ai->getSpellIdExact("Riposte");
+    SHIV = ai->getSpellIdExact("Shiv");
+    FAN_OF_KNIVES = ai->getSpellIdExact("Fan of Knives");
+
+    //Finishing Moves
+    EVISCERATE = ai->getSpellIdExact("Eviscerate");
+    RUPTURE = ai->getSpellIdExact("Rupture");
+    KIDNEY_SHOT = ai->getSpellIdExact("Kidney Shot");
+    ENVENOM = ai->getSpellIdExact("Envenom");
+    SLICE_AND_DICE = ai->getSpellIdExact("Slice and Dice");
+    EXPOSE_ARMOR = ai->getSpellIdExact("Expose Armor");
+    DEADLY_THROW = ai->getSpellIdExact("Deadly Throw");
+
+    //Buffs
+    STEALTH = ai->getSpellIdExact("Stealth");
+    VANISH = ai->getSpellIdExact("Vanish");
+    EVASION = ai->getSpellIdExact("Evasion");
+    CLOAK_OF_SHADOWS = ai->getSpellIdExact("Cloak of Shadows");
+    SPRINT = ai->getSpellIdExact("Sprint");
+    COLD_BLOOD = ai->getSpellIdExact("Cold Blood");
+    HUNGER_FOR_BLOOD = ai->getSpellIdExact("Hunger for Blood");
+    BLADE_FLURRY = ai->getSpellIdExact("Blade Flurry");
+    ADRENALINE_RUSH = ai->getSpellIdExact("Adrenaline Rush");
+    KILLING_SPREE = ai->getSpellIdExact("Killing Spree");
+    SHADOW_DANCE = ai->getSpellIdExact("Shadow Dance");
+
+    //Openers
+    CHEAP_SHOT = ai->getSpellIdExact("Cheap Shot");
+    GARROTE = ai->getSpellIdExact("Garrote");
+    AMBUSH = ai->getSpellIdExact("Ambush");
+
+    //Others
+    GOUGE = ai->getSpellIdExact("Gouge");
+    BLIND = ai->getSpellIdExact("Blind");
+    DISMANTLE = ai->getSpellIdExact("Dismantle");
+    SAP = ai->getSpellIdExact("Sap");
+    KICK = ai->getSpellIdExact("Kick");
+    PREPARATION = ai->getSpellIdExact("Preparation");
+    PREMEDITATION = ai->getSpellIdExact("Premeditation");
+    SHADOWSTEP = ai->getSpellIdExact("Shadowstep");
+    FEINT = ai->getSpellIdExact("Feint");
+    TRICKS_OF_THE_TRADE = ai->getSpellIdExact("Tricks of the Trade");
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+    THROW = ai->getSpellIdExact("Throw");
+
+    TALENT_ASSASSINATION = MUTILATE;
+    TALENT_COMBAT = ADRENALINE_RUSH;
+    TALENT_SUBTELTY = PREMEDITATION;
+
+    //uint8 talentCounter = 0;
+    //if (TALENT_ASSASSINATION) talentCounter++;
+    //if (TALENT_COMBAT) talentCounter++;
+    //if (TALENT_SUBTELTY) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ASSASSINATION = 0; TALENT_COMBAT = 0; TALENT_SUBTELTY = 0; } //Unreliable Talent detection.
+#pragma endregion
+}
+
+void PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    #pragma region Choose Target
+    // Choose actions accoring to talents (ROGUE is always MELEE DPS)
+    m_role = BOT_ROLE_DPS_MELEE;
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+        else if (CastSpell(VANISH,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+    #pragma endregion
+
+    // wait until we actually reach our target b4 we actually do anything
+    if (m_bot->GetDistance(pTarget)>10.0 &&
+        !m_bot->HasAura(STEALTH) &&
+        !m_bot->isInCombat() && CastSpell(STEALTH))
+    { return; }
+
+    TakePosition(pTarget);
+
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    // wait until we actually reach our target b4 we actually do anything
+    /*if (GetPlayerBot()->GetDistance(pTarget)>10.0 &&
+        !HasAuraName(GetPlayerBot(),STEALTH) &&
+        !GetPlayerBot()->isInCombat() && CastSpell(STEALTH))
+    { return; }*/
+
+    //Buff
+    if (CastSpell(PREMEDITATION,m_bot)) { return; }
+    if (CastSpell(COLD_BLOOD,m_bot)) { } //no gcd
+
+    //PROTECT UP
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+        if (CastSpell(FEINT,m_bot)) { return; }
+        if (CastSpell(VANISH,m_bot)) { return; }
+    }
+    if (isUnderAttack() && pDist <= MELEE_RANGE && ai->GetHealthPercent() <= 85 && CastSpell(EVASION, m_bot)) { } //no GCD
+    if (ai->GetHealthPercent() <= 55 && CastSpell(CLOAK_OF_SHADOWS, m_bot)) { return; }
+    if (isUnderAttack() && ai->GetHealthPercent() <= 65 && CastSpell(GOUGE, m_bot)) { return; }
+    if (isUnderAttack() && ai->GetHealthPercent() <= 45 && CastSpell(BLIND, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(KICK, pTarget)) { return; }
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(GOUGE, pTarget)) { return; }
+    else if (pTarget->IsNonMeleeSpellCasted(true) && m_bot->GetComboPoints() >= 1 && CastSpell(KIDNEY_SHOT, pTarget)) { return; }
+
+    //Transfer threat
+    if (m_tank->GetGUID() != m_bot->GetGUID() && CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+	if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    // sometimes we lose attack
+    if (!m_bot->isInCombat()) {
+        m_bot->Attack(pTarget, true);
+    }
+
+	if(TALENT_ASSASSINATION)
+	{
+		if (!m_bot->HasAura(HUNGER_FOR_BLOOD) && CastSpell(HUNGER_FOR_BLOOD,m_bot)) { return; }
+		if (m_bot->GetComboPoints() < 5)
+		{
+		    if (CastSpell(MUTILATE, pTarget)) { return; }
+		}
+		else
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+
+		}
+	}
+
+    if(TALENT_COMBAT)
+	{
+		if (CastSpell(BLADE_FLURRY,m_bot)) { return; }
+		if (ai->GetEnergyAmount() < 20 && CastSpell(ADRENALINE_RUSH,m_bot)) { return; }
+		if (!CastSpell(ADRENALINE_RUSH) && CastSpell(KILLING_SPREE,m_bot,1,0,1)) { return; }
+		if (m_bot->GetComboPoints() > 5)
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+		}
+	}
+
+    if(TALENT_SUBTELTY)
+	{
+		if (CastSpell(PREMEDITATION,m_bot)) {}
+		if (CastSpell(SHADOW_DANCE,m_bot)) {}
+		if (!CastSpell(SHADOW_DANCE,m_bot) && CastSpell(PREPARATION,m_bot)) { return; }
+		if (m_bot->GetComboPoints() < 5)
+		{
+			if (m_bot->HasAura(SHADOW_DANCE) && !pTarget->HasInArc(M_PI,m_bot)) { if (CastSpell(AMBUSH, pTarget)) { return; } }
+            if (CastSpell(GHOSTLY_STRIKE, pTarget)) { return; }
+		}
+		else
+		{
+			if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+			if (!m_bot->HasAura(SLICE_AND_DICE) && CastSpell(SLICE_AND_DICE)) { return; }
+			if (CastSpell(SHADOWSTEP,pTarget)) { }
+		}
+	}
+
+    // defaults if not high enough do specialized attacks
+    if (m_bot->GetComboPoints() < 5) {
+        if (!pTarget->HasInArc(M_PI,m_bot)) { if (CastSpell(BACKSTAB, pTarget)) { return; } }
+        if (!MUTILATE &&CastSpell(SINISTER_STRIKE,pTarget)) { return; } // Dont cast if we have mutilate, save energy for it
+    } else {
+        if (!m_bot->HasAura(SLICE_AND_DICE) && CastSpell(SLICE_AND_DICE)) {  return; }
+		if (CastSpell(ENVENOM,pTarget)) { return; }
+        if (CastSpell(EVISCERATE,pTarget)) { return; }
+    }
+} //end DoNextCombatManeuver
+
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff Up
+    if (ChangeWeaponEnchants()) { return; }
+} //end DoNonCombatActions
+
+bool PlayerbotRogueAI::ChangeWeaponEnchants()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+
+    Item *weap;
+    Item *poison;
+
+    weap = m_bot->GetWeaponForAttack(BASE_ATTACK);
+    if (weap && !weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+    {
+        poison = GetAI()->FindPoisonForward();
+        if(poison == NULL) return false;
+        GetAI()->PoisonWeapon(*poison, poison->GetTemplate()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_MAINHAND);
+        return true;
+    }
+    weap = m_bot->GetWeaponForAttack(OFF_ATTACK);
+    if (weap && !weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+    {
+        poison = GetAI()->FindPoisonBackward();
+        if(poison == NULL) return false;
+        GetAI()->PoisonWeapon(*poison, poison->GetTemplate()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_OFFHAND);
+        return true;
+    }
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
new file mode 100644
index 0000000..9c400f1
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
@@ -0,0 +1,41 @@
+#ifndef _PLAYERBOTROGUEAI_H
+#define _PLAYERBOTROGUEAI_H
+
+#include "PlayerbotClassAI.h"
+#include "TargetedMovementGenerator.h"
+
+class PlayerbotRogueAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotRogueAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotRogueAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, REBIRTHes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool ChangeWeaponEnchants();
+
+    private:
+        //Damage spells
+        uint32 BACKSTAB, SINISTER_STRIKE, MUTILATE, HEMORRHAGE, GHOSTLY_STRIKE, RIPOSTE, SHIV, FAN_OF_KNIVES;
+        //Finishing Moves
+        uint32 EVISCERATE, RUPTURE, KIDNEY_SHOT, ENVENOM, SLICE_AND_DICE, EXPOSE_ARMOR, DEADLY_THROW;
+        //Buffs
+        uint32 STEALTH, VANISH, EVASION, CLOAK_OF_SHADOWS, SPRINT, COLD_BLOOD, HUNGER_FOR_BLOOD, BLADE_FLURRY, ADRENALINE_RUSH, KILLING_SPREE, SHADOW_DANCE;
+        //Openers
+        uint32 CHEAP_SHOT, GARROTE, AMBUSH;
+        //Others
+        uint32 GOUGE, BLIND, DISMANTLE, SAP, KICK, PREPARATION, PREMEDITATION, SHADOWSTEP, FEINT, TRICKS_OF_THE_TRADE;
+
+        uint32 TALENT_ASSASSINATION, TALENT_COMBAT, TALENT_SUBTELTY;
+
+        uint32 THROW;
+
+};
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
new file mode 100644
index 0000000..1af2ac3
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
@@ -0,0 +1,555 @@
+#include "PlayerbotShamanAI.h"
+class PlayerbotAI;
+PlayerbotShamanAI::PlayerbotShamanAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotShamanAI::~PlayerbotShamanAI(){}
+
+void PlayerbotShamanAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //totems
+    HEALING_STREAM_TOTEM = ai->getSpellIdExact("Healing Stream Totem");
+    MANA_SPRING_TOTEM = ai->getSpellIdExact("Mana Spring Totem");
+    MANA_TIDE_TOTEM = ai->getSpellIdExact("Mana Tide Totem");
+    CLEANSING_TOTEM = ai->getSpellIdExact("Cleansing Totem");
+    FIRE_RESISTANCE_TOTEM = ai->getSpellIdExact("Fire Resistance Totem");
+
+    WINDFURY_TOTEM = ai->getSpellIdExact("Windfury Totem");
+    WRATH_OF_AIR_TOTEM = ai->getSpellIdExact("Wrath of Air Totem");
+    GROUNDING_TOTEM = ai->getSpellIdExact("Grounding Totem");
+    NATURE_RESISTANCE_TOTEM = ai->getSpellIdExact("Nature Resistance Totem");
+
+    STRENGTH_OF_EARTH_TOTEM = ai->getSpellIdExact("Strength of Earth Totem");
+    EARTHBIND_TOTEM = ai->getSpellIdExact("Earthbind Totem");
+    STONESKIN_TOTEM = ai->getSpellIdExact("Stoneskin Totem");
+    STONECLAW_TOTEM = ai->getSpellIdExact("Stoneclaw Totem");
+    TREMOR_TOTEM = ai->getSpellIdExact("Tremor Totem");
+    EARTH_ELEMENTAL_TOTEM = ai->getSpellIdExact("Earth Elemental Totem");
+
+    FLAMETONGUE_TOTEM = ai->getSpellIdExact("Flametongue Totem");
+    TOTEM_OF_WRATH = ai->getSpellIdExact("Totem of Wrath");
+    SEARING_TOTEM = ai->getSpellIdExact("Searing Totem");
+    MAGMA_TOTEM = ai->getSpellIdExact("Magma Totem");
+    FIRE_ELEMENTAL_TOTEM = ai->getSpellIdExact("Fire Elemental Totem");
+    FROST_RESISTANCE_TOTEM = ai->getSpellIdExact("Frost Resistance Totem");
+
+    TOTEMIC_RECALL = ai->getSpellIdExact("Totemic Recall");
+    CALL_OF_THE_ELEMENTS = ai->getSpellIdExact("Call of the Elements");
+    CALL_OF_THE_ANCESTORS = ai->getSpellIdExact("Call of the Ancestors");
+    CALL_OF_THE_SPIRITS = ai->getSpellIdExact("Call of the Spirits");
+
+    //restoration
+    HEAL = ai->getSpellIdExact("Healing Wave");
+    LESSER_HEAL = ai->getSpellIdExact("Lesser Healing Wave");
+    CHAIN_HEAL = ai->getSpellIdExact("Chain Heal");
+    RIPTIDE = ai->getSpellIdExact("Riptide");
+    ANCESTRAL_SPIRIT = ai->getSpellIdExact("Ancestral Spirit");
+    CLEANSE_SPIRIT = ai->getSpellIdExact("Cleanse Spirit");
+    if (CLEANSE_SPIRIT) CLEANSE_SPIRIT = ai->getSpellIdExact("Cure Toxins");
+
+    //offensive spells
+    LIGHTNING_BOLT = ai->getSpellIdExact("Lightning Bolt");
+    CHAIN_LIGHTNING = ai->getSpellIdExact("Chain Lightning");
+    FIRE_NOVA = ai->getSpellIdExact("Fire Nova");
+    THUNDERSTORM = ai->getSpellIdExact("Thunderstorm");
+    LAVA_BURST = ai->getSpellIdExact("Lava Burst");
+    EARTH_SHOCK = ai->getSpellIdExact("Earth Shock");
+    WIND_SHEAR = ai->getSpellIdExact("Wind Shear");
+    FLAME_SHOCK = ai->getSpellIdExact("Flame Shock");
+    FROST_SHOCK = ai->getSpellIdExact("Frost Shock");
+    PURGE = ai->getSpellIdExact("Purge");
+    HEX  = ai->getSpellIdExact("Hex");
+
+    //buffs
+    LIGHTNING_SHIELD = ai->getSpellIdExact("Lightning Shield");
+    WATER_SHIELD = ai->getSpellIdExact("Water Shield");
+    EARTH_SHIELD = ai->getSpellIdExact("Earth Shield");
+    HEROISM = ai->getSpellIdExact("Heroism");
+    if (HEROISM) HEROISM = ai->getSpellIdExact("Bloodlust");
+    ELEMENTAL_MASTERY = ai->getSpellIdExact("Elemental Mastery");
+    NATURES_SWIFTNESS = ai->getSpellIdExact("Nature's Swiftness");
+
+    WINDFURY_WEAPON = ai->getSpellIdExact("Windfury Weapon");
+    FLAMETONGUE_WEAPON = ai->getSpellIdExact("Flametongue Weapon");
+    FROSTBRAND_WEAPON = ai->getSpellIdExact("Frostbrand Weapon");
+    ROCKBITER_WEAPON = ai->getSpellIdExact("Rockbiter Weapon");
+    EARTHLIVING_WEAPON = ai->getSpellIdExact("Earthliving Weapon");
+
+    WATER_BREATHING = ai->getSpellIdExact("Water Breathing");
+    WATER_WALKING = ai->getSpellIdExact("Water Walking");
+
+    //melee
+    LAVA_LASH = ai->getSpellIdExact("Lava Lash");
+    STORMSTRIKE = ai->getSpellIdExact("Stormstrike");
+    SHAMANISTIC_RAGE = ai->getSpellIdExact("Shamanistic Rage");
+    FERAL_SPIRIT = ai->getSpellIdExact("Feral Spirit");
+
+    GHOST_WOLF = ai->getSpellIdExact("Ghost Wolf");
+
+    EXHAUSTION = 57723; // heroism debuff
+    SATED = 57724; // bloodlust debuff
+    //MAELSTROM_WEAPON = 0; // We want the triggered aura, not the talent spell
+    uint32 mwtrigger = ai->getSpellIdExact("Maelstrom Weapon",true);
+    if (mwtrigger)
+    {
+        SpellInfo const *mwtSpell = sSpellMgr->GetSpellInfo(mwtrigger);
+        if (mwtSpell && mwtSpell->Effects[0].TriggerSpell > 0) MAELSTROM_WEAPON = mwtSpell->Effects[0].TriggerSpell;
+    }
+
+    TALENT_ELEMENTAL = ELEMENTAL_MASTERY;
+    TALENT_ENHANCEMENT = STORMSTRIKE;
+    TALENT_RESTO = EARTH_SHIELD;
+
+    uint8 talentCounter = 0;
+    if (TALENT_ELEMENTAL) talentCounter++;
+    if (TALENT_ENHANCEMENT) talentCounter++;
+    if (TALENT_RESTO) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ELEMENTAL = 0; TALENT_ENHANCEMENT = 0; TALENT_RESTO = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+void PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+    switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            ((ai->GetHealthPercent() < 80 && CastSpell(LESSER_HEAL)) ||
+            CastSpell(LIGHTNING_BOLT, pTarget));
+            return;
+    }
+
+    // Cast CC breakers if any match found (include any dispels first)  does not work yet
+    //uint32 ccSpells[4] = { R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    //if (ai->GetManaPercent() < 35) { ccSpells[0] = 0; ccSpells[1] = 0; } //We dont have any mana to waste...
+    //if (castSelfCCBreakers(ccSpells)) {  } // Most of them don't trigger gcd
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) { m_role=BOT_ROLE_TANK; } // Hey! I am Main Tank
+    else if (TALENT_ENHANCEMENT) { m_role = BOT_ROLE_DPS_MELEE; }
+    else if (TALENT_ELEMENTAL) { m_role = BOT_ROLE_DPS_RANGED; }
+    else if (TALENT_RESTO) { m_role = BOT_ROLE_SUPPORT; }
+    else { m_role = BOT_ROLE_DPS_MELEE; } //Unknown build or low level.. Mainly attack
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack()  )
+    {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+    }
+    #pragma endregion
+
+    // Choose Weapon Enchant
+    if (ChangeWeaponEnchants()) return;
+
+	if (TALENT_ELEMENTAL){ if (!m_bot->HasAura(WATER_SHIELD) && CastSpell(WATER_SHIELD,m_bot)) { return; }}
+	if (TALENT_ENHANCEMENT){ if (!m_bot->HasAura(LIGHTNING_SHIELD) && CastSpell(LIGHTNING_SHIELD,m_bot)) { return; }}
+	if (TALENT_RESTO){ if (!m_bot->HasAura(WATER_SHIELD) && CastSpell(WATER_SHIELD,m_bot)) { return; }}
+    // Choose shield
+	/*
+    if (EARTH_SHIELD && ai->GetHealthPercent() < 80 && isUnderAttack()) { if (CastSpell(EARTH_SHIELD,m_bot)) { return; } }
+    else if (WATER_SHIELD && ai->GetManaPercent() < 40) { if (CastSpell(WATER_SHIELD,m_bot)) { return; } }
+    else if (LIGHTNING_SHIELD &&
+        ( isUnderAttack() || m_tank->GetGUID() == m_bot->GetGUID() )  && !(m_bot->HasAura(WATER_SHIELD) && ai->GetManaPercent() < 80)
+        ) { if (CastSpell(LIGHTNING_SHIELD,m_bot)) { return; } }
+    else if (CastSpell(WATER_SHIELD,m_bot)) { return; }
+	*/
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_TANK:
+        case BOT_ROLE_OFFTANK:
+             if (!TALENT_ELEMENTAL && !TALENT_RESTO) { TakePosition(pTarget); }
+            else { TakePosition(pTarget,BOT_ROLE_DPS_RANGED); } // mob will come to you sooner or later no need to hurry
+
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 70 && DoSupportRaid(m_bot)) { return; }
+
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 40 && DoSupportRaid(m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 40 && DoSupportRaid(m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            Unit *target = DoSelectLowestHpFriendly(40, 1000);
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            break;
+        #pragma endregion
+    }
+    #pragma region ShamanCommon
+
+
+    //Defensive Stuff
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (pDist > 5 && CastSpell(FROST_SHOCK, pTarget)) { return; }
+        if ((pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST || pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_HUMANOID) && CastSpell(HEX, pTarget)) { return; } // no gcd
+        if (CastSpell(WIND_SHEAR, pTarget)) { } // no gcd
+    }
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(WIND_SHEAR, pTarget)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(FROST_SHOCK,pTarget)) return;
+    }
+
+
+    //Buff and restores
+    if ( ( (ai->GetHealthPercent() < 60 && isUnderAttack()) ||
+        (ai->GetManaPercent() < 30) ) && CastSpell(SHAMANISTIC_RAGE, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} // no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} // no GCD
+    if (!m_bot->HasAura(HEROISM) && !m_bot->HasAura(EXHAUSTION) && !m_bot->HasAura(SATED) && CastSpell(HEROISM,m_bot)) { return; }
+    if (m_role != BOT_ROLE_SUPPORT && CastSpell(NATURES_SWIFTNESS, m_bot)) { } //healers keep it for healing no gcd
+    else if (CastSpell(ELEMENTAL_MASTERY, m_bot)) { } //no gcd
+
+    // If at threat limit, use WIND_SHEAR to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(WIND_SHEAR,pTarget)) { return; } //Lets see if we can manage
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+
+	if (TALENT_ELEMENTAL)
+	{
+		if (CastSpell(ELEMENTAL_MASTERY, m_bot)) { } //no gcd
+		if (!pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) && CastSpell(FLAME_SHOCK,pTarget)) { return; }
+		if (CastSpell(LAVA_BURST,pTarget)) { return; }
+		if (CastSpell(CHAIN_LIGHTNING,pTarget)) { return; }
+		if (CastSpell(LIGHTNING_BOLT,pTarget)) { return; }
+	}
+
+    //dps
+    if (MAELSTROM_WEAPON)
+    {
+        Aura *maelaura = m_bot->GetAura(MAELSTROM_WEAPON);
+        if (maelaura && maelaura->GetStackAmount() == 5)
+        {
+            if ((isUnderAttack(m_tank,3) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(CHAIN_LIGHTNING,pTarget,true,true)) { return; }
+            if (CastSpell(LIGHTNING_BOLT,pTarget,true,true)) { return; }
+        }
+    }
+	if (CastSpell(FLAME_SHOCK,pTarget)) { return; }
+    if (CastSpell(STORMSTRIKE,pTarget,true,true)) { return; }
+
+    //if (!TALENT_ENHANCEMENT && CanCast(LAVA_BURST,pTarget,true) && pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) && CastSpell(LAVA_BURST,pTarget,false)) { return; }
+	if (CastSpell(FERAL_SPIRIT,m_bot)) { return; }
+    if (CanCast(EARTH_SHOCK,pTarget,true) && (pTarget->HasAura(STORMSTRIKE,m_bot->GetGUID()) || pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) ) && CastSpell(EARTH_SHOCK,pTarget)) { return; }
+    //if (CanCast(FLAME_SHOCK,pTarget) && CastSpell(FLAME_SHOCK,pTarget)) { return; }
+	if (CastSpell(LAVA_LASH,pTarget,true,true)) { return; }
+	if (CastSpell(FIRE_NOVA,pTarget)) { return; }
+    //if ((isUnderAttack(m_tank,4) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(FIRE_NOVA,pTarget)) { return; }
+    if (ai->GetManaPercent() > 60 && castDispel(PURGE,pTarget)) { return; } //PURGE but dont overpurge
+
+    #pragma endregion
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+
+} //end DoNextCombatManeuver
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //Buffs
+    if (ChangeWeaponEnchants()) { return; }
+    if (CastSpell(WATER_SHIELD,m_bot)) { return; }
+    if (CastSpell(EARTH_SHIELD,m_bot)) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(LESSER_HEAL,m_bot)) { return; }
+	if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+bool PlayerbotShamanAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if(hp < 30 && m_bot->isInCombat() && CastSpell(NATURES_SWIFTNESS, m_bot)) {} // NO gcd
+    if(hp < 60 && CanCast(HEAL,target,true) && m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(HEAL, target, false)) { return true; }
+    if(hp < 30 && CastSpell(LESSER_HEAL,target,true,true)) { return true; }
+    if(hp < 40 && m_bot->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) {} // no GCD
+    if(hp < 65 && CanCast(EARTH_SHIELD,target) && !m_bot->HasAura(EARTH_SHIELD,m_bot->GetGUID()) && CastSpell(EARTH_SHIELD,target,false)) { return true; }
+    if(hp < 65 && CastSpell(HEAL,target,true,true)) { return true; }
+    if(hp < 85 && CastSpell(LESSER_HEAL,target,true,true)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotShamanAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    Player *m_bot = GetPlayerBot();
+    if (countNeedHeal < 2) { return false; }
+    Unit *rTarget = DoSelectLowestHpFriendly(30,500);
+    if (!rTarget || rTarget->isDead() || rTarget->GetHealth() * 100 / rTarget->GetMaxHealth() > 80 ) { return false; }
+
+    if (hp < 65 && RIPTIDE && rTarget->HasAura(RIPTIDE,m_bot->GetGUID()) && CastSpell(CHAIN_HEAL, rTarget)) { return true; }
+    if (hp < 85 && CastSpell(RIPTIDE, rTarget)) { return true; }
+    if (hp < 75 && CastSpell(CHAIN_HEAL, rTarget,true,true)) { return true; }
+
+    return false;
+}
+
+bool PlayerbotShamanAI::CureTarget(Unit *target)
+//Cures the target
+{
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(CLEANSE_SPIRIT, target)) return true;
+
+    return false;
+}
+
+bool PlayerbotShamanAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(ANCESTRAL_SPIRIT,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(ANCESTRAL_SPIRIT, target,false);
+}
+
+bool PlayerbotShamanAI::BuffPlayer(Unit *target)
+{
+    //std::string msg = "Mana totem, coming right up.";
+    //GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    //if(!HasAuraName(GetPlayerBot(), "Mana Spring")) { CastSpell(MANA_SPRING_TOTEM, GetPlayerBot()); } return true;
+    return false;
+}
+#pragma region Change Totems
+bool PlayerbotShamanAI::ChangeTotems(uint32 mode)
+{
+    uint32 earth=0, fire=0, water=0, air=0;
+
+    PlayerbotAI *ai = GetAI();
+    if(!ai) return false;
+    Player *m_bot = GetPlayerBot();
+    if(!m_bot || m_bot->isDead()) return false;
+
+    Unit *pTarget = m_bot->GetSelectedUnit();
+    Unit *pVictim = NULL;
+    if (m_bot->GetSelectedUnit()->IsFriendlyTo(m_bot)) pTarget = NULL;
+    if (pTarget) pVictim = pTarget->getVictim();
+
+    //Defaults
+    if (!HasAuraName(m_bot,"Horn of Winter") )earth = STRENGTH_OF_EARTH_TOTEM;
+    if (!earth) earth = STONESKIN_TOTEM;
+    if (!earth) earth = EARTHBIND_TOTEM;
+    fire = TOTEM_OF_WRATH;
+    if (!fire) fire = FLAMETONGUE_TOTEM;
+    if (!fire) fire = SEARING_TOTEM;
+    water = MANA_SPRING_TOTEM;
+    if (!water) water = HEALING_STREAM_TOTEM;
+    if (TALENT_ELEMENTAL || TALENT_RESTO) air = WRATH_OF_AIR_TOTEM;
+    else air = WINDFURY_TOTEM;
+
+    //Target reactive stuff
+    if (pTarget)
+    {
+        if (GROUNDING_TOTEM && pTarget->IsNonMeleeSpellCasted(true)) air = GROUNDING_TOTEM;
+    }
+
+    if (STONESKIN_TOTEM && isUnderAttack()) earth = STONESKIN_TOTEM;
+
+    uint32 totz[4] = {earth, fire, water, air};
+
+    for (int i = 0; i < 4; i++)
+    {
+        if (!totz[i]) continue;
+        SpellInfo const *tSpell = sSpellMgr->GetSpellInfo(totz[i]);
+        if (!tSpell) continue;
+        uint32 tEntry = (uint32) tSpell->Effects[0].MiscValue;
+        if (!tEntry) continue;
+        CreatureTemplate const *totemEntry = sObjectMgr->GetCreatureTemplate(tEntry);
+        if (!tEntry) continue;
+
+        if (CanCast(totz[i], m_bot) && !m_bot->FindNearestCreature(tEntry,30)) { return CastSpell(totz[i],m_bot,false); }
+    }
+    return false;
+}
+#pragma endregion
+#pragma region ChangeWeaponEnchants
+bool PlayerbotShamanAI::ChangeWeaponEnchants()
+{
+    uint32 mhEnch = 0, ohEnch = 0;
+
+    PlayerbotAI *ai = GetAI();
+    if(!ai) return false;
+    Player *m_bot = GetPlayerBot();
+    if(!m_bot || m_bot->isDead()) return false;
+
+
+    // Choose Weapon Enchant
+    if (TALENT_RESTO) { mhEnch = EARTHLIVING_WEAPON; }
+    else if (TALENT_ELEMENTAL){ mhEnch = FLAMETONGUE_WEAPON; }
+    else
+    {
+        if (WINDFURY_WEAPON)
+        {
+            mhEnch = WINDFURY_WEAPON;
+            if (m_bot->haveOffhandWeapon())
+            {
+                if (LAVA_LASH) ohEnch = FLAMETONGUE_WEAPON;
+                else ohEnch = WINDFURY_WEAPON;
+            }
+		}
+    else if (FLAMETONGUE_WEAPON)
+    {
+        mhEnch = FLAMETONGUE_WEAPON;
+        if (m_bot->haveOffhandWeapon()) ohEnch = FLAMETONGUE_WEAPON;
+    }
+
+    }
+
+    Item* weap;
+    uint32 enchant_id = 0;
+    SpellEntry const *tSpell;
+    bool castedsomething = false;
+
+    if (mhEnch)
+    {
+        weap = m_bot->GetWeaponForAttack(BASE_ATTACK);
+        if (weap)
+        {
+            SpellInfo const* tSpell = sSpellMgr->GetSpellInfo(mhEnch);
+            if (tSpell && tSpell->Effects[0].MiscValue > 0)
+            {
+                enchant_id = (uint32) tSpell->Effects[0].MiscValue;
+                if (enchant_id && weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) != enchant_id && sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                {
+                    m_bot->ApplyEnchantment(weap,TEMP_ENCHANTMENT_SLOT, false); //Remove old enchantment effect
+                    weap->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, 1800 * 1000, 0); //Add for 30 mins
+                    m_bot->ApplyEnchantment(weap, TEMP_ENCHANTMENT_SLOT, true); //Add new effect
+                    castedsomething = true;
+                }
+            }
+        }
+    }
+
+    if (ohEnch)
+    {
+        weap = m_bot->GetWeaponForAttack(OFF_ATTACK);
+        if (weap)
+        {
+            SpellInfo const* tSpell = sSpellMgr->GetSpellInfo(ohEnch);
+            if (tSpell && tSpell->Effects[0].MiscValue > 0)
+            {
+                enchant_id = (uint32) tSpell->Effects[0].MiscValue;
+                if (enchant_id && weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) != enchant_id && sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                {
+                    m_bot->ApplyEnchantment(weap,TEMP_ENCHANTMENT_SLOT, false); //Remove old enchantment effect
+                    weap->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, 1800 * 1000, 0); //Add for 30 mins
+                    m_bot->ApplyEnchantment(weap, TEMP_ENCHANTMENT_SLOT, true); //Add new effect
+                    castedsomething = true;
+                }
+            }
+        }
+    }
+    return castedsomething;
+
+}
+#pragma endregion
diff --git a/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
new file mode 100644
index 0000000..e5fef23
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
@@ -0,0 +1,75 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotShamanAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotShamanAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotShamanAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, REBIRTHes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget (Unit *target);
+
+        bool ChangeTotems(uint32 mode);
+
+        bool ChangeWeaponEnchants();
+
+        /*//find any specific mount spells, ie druids=cat, shaman=ghost wolf etc
+        virtual bool FindMount();
+        virtual bool Unmount();
+        virtual bool IsMounted(); */
+
+    private:
+
+        //totems
+        uint32 HEALING_STREAM_TOTEM, MANA_SPRING_TOTEM, MANA_TIDE_TOTEM, CLEANSING_TOTEM, FIRE_RESISTANCE_TOTEM; //water
+        uint32 WINDFURY_TOTEM, WRATH_OF_AIR_TOTEM, GROUNDING_TOTEM, NATURE_RESISTANCE_TOTEM;  //air
+        uint32 STRENGTH_OF_EARTH_TOTEM, EARTHBIND_TOTEM, STONESKIN_TOTEM, STONECLAW_TOTEM, TREMOR_TOTEM, EARTH_ELEMENTAL_TOTEM ; //earth
+        uint32 FLAMETONGUE_TOTEM, TOTEM_OF_WRATH, SEARING_TOTEM, MAGMA_TOTEM, FIRE_ELEMENTAL_TOTEM, FROST_RESISTANCE_TOTEM; //fire
+        uint32 TOTEMIC_RECALL, CALL_OF_THE_ELEMENTS, CALL_OF_THE_ANCESTORS, CALL_OF_THE_SPIRITS;
+
+        //restoration
+        uint32 HEAL, LESSER_HEAL, CHAIN_HEAL, RIPTIDE, ANCESTRAL_SPIRIT, CLEANSE_SPIRIT;
+
+        //offensive spells
+        uint32 LIGHTNING_BOLT, CHAIN_LIGHTNING, FIRE_NOVA, THUNDERSTORM, LAVA_BURST, EARTH_SHOCK, WIND_SHEAR, FLAME_SHOCK, FROST_SHOCK, PURGE, HEX ;
+
+        //buffs
+        uint32 LIGHTNING_SHIELD, WATER_SHIELD, EARTH_SHIELD, HEROISM, ELEMENTAL_MASTERY, NATURES_SWIFTNESS,
+            WINDFURY_WEAPON, FLAMETONGUE_WEAPON, FROSTBRAND_WEAPON, ROCKBITER_WEAPON, EARTHLIVING_WEAPON,
+            WATER_BREATHING, WATER_WALKING ;
+
+        //mellee
+        uint32 LAVA_LASH, STORMSTRIKE, SHAMANISTIC_RAGE, FERAL_SPIRIT;
+
+        uint32 GHOST_WOLF;
+
+        //special
+        uint32 EXHAUSTION, SATED, MAELSTROM_WEAPON;
+
+        uint32 TALENT_ELEMENTAL, TALENT_ENHANCEMENT, TALENT_RESTO;
+
+};
+
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
new file mode 100644
index 0000000..96d3ad1
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
@@ -0,0 +1,410 @@
+/*
+Name : PlayerbotWarlockAI.cpp
+Complete: maybe around 60%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - Curse checks are slow, later all curses should be looked up in one loop
+                - Need a function to lookup pet known spells for better pet handling
+                - Warlock do not summon other pets than Fel hunter/Imp
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+#include "PlayerbotWarlockAI.h"
+
+class PlayerbotAI;
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotWarlockAI::~PlayerbotWarlockAI(){}
+
+void PlayerbotWarlockAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //CURSES
+    CURSE_OF_ELEMENTS = ai->getSpellIdExact("Curse of Elements");
+    CURSE_OF_WEAKNESS = ai->getSpellIdExact("Curse of Weakness");
+    CURSE_OF_AGONY = ai->getSpellIdExact("Curse of Agony");
+    CURSE_OF_RECKLESSNESS = ai->getSpellIdExact("Curse of Recklessness");
+    CURSE_OF_TONGUES = ai->getSpellIdExact("Curse of Tongues");
+    CURSE_OF_DOOM = ai->getSpellIdExact("Curse of Doom");
+    CURSE_OF_EXHAUSTION = ai->getSpellIdExact("Curse of Exhaustion");
+
+
+    //AFFLICTION
+    CORRUPTION = ai->getSpellIdExact("Corruption");
+    DRAIN_SOUL = ai->getSpellIdExact("Drain Soul");
+    DRAIN_LIFE = ai->getSpellIdExact("Drain Life");
+    DRAIN_MANA = ai->getSpellIdExact("Drain Mana");
+    SIPHON_LIFE = ai->getSpellIdExact("Siphon Life");
+    UNSTABLE_AFFLICTION = ai->getSpellIdExact("Unstable Affliction");
+    HAUNT = ai->getSpellIdExact("Haunt");
+    SEED_OF_CORRUPTION = ai->getSpellIdExact("Seed of Corruption");
+    DEATH_COIL = ai->getSpellIdExact("Death Coil");
+
+
+    //DESTRUCTION
+    SHADOW_BOLT = ai->getSpellIdExact("Shadow Bolt");
+    IMMOLATE = ai->getSpellIdExact("Immolate");
+    INCINERATE = ai->getSpellIdExact("Incinerate");
+    SEARING_PAIN = ai->getSpellIdExact("Searing Pain");
+    CONFLAGRATE = ai->getSpellIdExact("Conflagrate");
+    SOUL_FIRE = ai->getSpellIdExact("Soul Fire");
+    SHADOWBURN = ai->getSpellIdExact("Shadowburn");
+    SHADOWFURY = ai->getSpellIdExact("Shadowfury");
+    CHAOS_BOLT = ai->getSpellIdExact("Chaos Bolt");
+    SHADOWFLAME = ai->getSpellIdExact("Shadowflame");
+    RAIN_OF_FIRE = ai->getSpellIdExact("Rain of Fire");
+    HELLFIRE = ai->getSpellIdExact("Hellfire");
+
+
+    //DEMONOLOGY
+    DEMON_ARMOR = ai->getSpellIdExact("Demon Armor");
+    if (!DEMON_ARMOR) DEMON_ARMOR = ai->getSpellIdExact("Demon Skin");
+    FEL_ARMOR = ai->getSpellIdExact("Fel Armor");
+    SOULSHATTER = ai->getSpellIdExact("Soulshatter");
+    HEALTH_FUNNEL = ai->getSpellIdExact("Health Funnel");
+    DARK_PACT = ai->getSpellIdExact("Dark Pact");
+    SOUL_LINK = ai->getSpellIdExact("Soul Link");
+    DEMONIC_EMPOWERMENT = ai->getSpellIdExact("Demonic Empowerment");
+    METAMORPHOSIS = ai->getSpellIdExact("Metamorphosis"); //Original is learn spell
+    SUMMON_IMP = ai->getSpellIdExact("Summon Imp");
+    SUMMON_VOIDWALKER = ai->getSpellIdExact("Summon Voidwalker");
+    SUMMON_SUCCUBUS = ai->getSpellIdExact("Summon Succubus");
+    SUMMON_FELHUNTER = ai->getSpellIdExact("Summon Felhunter");
+    SUMMON_FELGUARD = ai->getSpellIdExact("Summon Felguard");
+
+
+    //CC
+    FEAR = ai->getSpellIdExact("Fear");
+    HOWL_OF_TERROR = ai->getSpellIdExact("Howl of Terror");
+    BANISH = ai->getSpellIdExact("Banish");
+    ENSLAVE_DEMON = ai->getSpellIdExact("Enslave Demon");
+
+
+    //Buff
+    UNENDING_BREATH = ai->getSpellIdExact("Unending Breath");
+    DETECT_INVISIBILITY = ai->getSpellIdExact("Detect Invisibility");
+    SHADOW_WARD = ai->getSpellIdExact("Shadow Ward");
+
+
+    //Other
+    LIFE_TAP = ai->getSpellIdExact("Life Tap");
+    CREATE_SOULSTONE = ai->getSpellIdExact("Create Soulstone");
+
+
+    SOUL_SHARD = 6265; //Soul Shard Item id
+    P_BACKLASH = 34936; //Backlash proc
+    P_NIGHTFALL= 17941; //Nightfall proc
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_DEMONOLOGY = SUMMON_FELGUARD;
+    TALENT_AFFLICTION = UNSTABLE_AFFLICTION;
+    TALENT_DESTRUCTION = CONFLAGRATE;
+
+    uint8 talentCounter = 0;
+    if (TALENT_DEMONOLOGY) talentCounter++;
+    if (TALENT_AFFLICTION) talentCounter++;
+    if (TALENT_DESTRUCTION) talentCounter++;
+    if (talentCounter > 1) { TALENT_DEMONOLOGY = 0; TALENT_AFFLICTION = 0; TALENT_DESTRUCTION = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotWarlockAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    if (m_tank->GetGUID() == m_bot->GetGUID() && pet && pet->isAlive() && pet->isInCombat()) { m_tank = pet; }
+    uint8 petThreat = 0;
+    if (pet) { GetThreatPercent(pTarget,pet); }
+
+    /*switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            if(SHADOW_BOLT > 0) CastSpell(SHADOW_BOLT);
+            return;
+    }*/
+
+    //------- Non Duel combat ----------
+
+    //ai->Follow(*GetMaster()); //don't want to melee mob
+
+    #pragma region Choose Target
+    // Choose actions accoring to talents (WARLOCK is always ranged dps)
+    m_role = BOT_ROLE_DPS_RANGED;
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(SOULSHATTER,m_bot)) { return; }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+
+    #pragma endregion
+
+    #pragma region Pet Actions
+    // Pet's own Actions
+    if( pet && pet->isAlive() )
+    {
+        // Setup pet
+        if (pet->GetCharmInfo()->IsAtStay()) {pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW); }
+        //if (pet->HasSpell(BLOOD_PACT) && ); //Cast Blood Pact
+
+        if ( ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        && ( HEALTH_FUNNEL>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot
+        && CastSpell(HEALTH_FUNNEL,m_bot) )) { return; } //Heal pet
+
+        // Set pet to attack warlock's attacker > its own attackers > warlock's target
+        if (!pet->getVictim()) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(m_bot)) { pet->AI()->AttackStart(pTarget); }  //Always help warlock if he's under attack
+        else if (pet->getVictim()->GetGUID() != pTarget->GetGUID() && !isUnderAttack(pet)) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(pet)) // Pet is under attack and warlock has no attackers
+        {
+            if ( pet->getVictim()->getVictim() && pet->getVictim()->getVictim()->GetGUID() == pet->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(pet,true);
+                if (curAtt && (!pet->getVictim() || curAtt->GetGUID() != pet->getVictim()->GetGUID()))
+                {
+                    pet->AI()->AttackStart(curAtt); //Attack nearest attacker
+                }
+            }
+            //Actions to do under attack (Always tank it, and try to kill it, until someone (!= warlock) takes aggro back)
+            //Warlock should help her pet whether main tank or not, unless he's being attacked (BEWARE Targeting Loop possibility)
+            if (pet->getVictim() && !isUnderAttack(m_bot) && pet->getVictim()->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(pet->getVictim()->GetGUID());
+                DoNextCombatManeuver(pet->getVictim()); //Restart new update to get variables fixed..
+                return;
+            }
+
+        }
+        // Pet tanking behaviour
+        if (pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot) || isUnderAttack(pet))
+        {
+            //need pet tanking spells
+            //if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,true); //Autocast growl
+        }
+        else
+        {
+            //if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,false); //Do not try to get aggro
+        }
+        // NORMAL PET dps attacks
+        if (petThreat < threatThreshold || pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot))
+        {
+            //if (CastSpell(KILL_COMMAND,m_bot)) { }
+        }
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    //Buff
+    if (isUnderAttack()) { if (CastSpell (DEMON_ARMOR, m_bot)) { return; } }
+    else if (FEL_ARMOR) { if (CastSpell(FEL_ARMOR,m_bot)) { return; } }
+    else if (CastSpell(DEMON_ARMOR, m_bot)) { return; }
+    if (CastSpell(METAMORPHOSIS,m_bot)) { return; }
+    if (CastSpell(DEMONIC_EMPOWERMENT,m_bot)) { return; }
+
+    //Protect
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (CastSpell(SOULSHATTER, m_bot)) { return; }
+        if (pTarget->GetCreatureType() == CREATURE_TYPE_DEMON && CastSpell(BANISH,pTarget)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (isUnderAttack() && CastSpell(FEAR, pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(HOWL_OF_TERROR, pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(SHADOWFURY, pTarget)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    //Void Walker shield?
+    if (ai->GetHealthPercent() < 70 && CastSpell(DEATH_COIL,pTarget)) { return; }
+    if (ai->GetHealthPercent() < 70 && CastSpell(DRAIN_LIFE,pTarget)) { return; }
+    if (ai->GetManaPercent() < 70 && ai->GetManaPercent(*pTarget) > 10 && CastSpell(DRAIN_MANA,pTarget)) { return; }
+    if (ai->GetManaPercent() < 50 && pet && ai->GetManaPercent(*pet) > 50 && CastSpell(DARK_PACT,pet,1,0,1)) { return; }
+    if (ai->GetManaPercent() < 30 && ai->GetHealthPercent() > 60 && CastSpell(LIFE_TAP,m_bot,1,0,1)) { return; }
+    //Use Health stone
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(CURSE_OF_TONGUES, pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(CURSE_OF_EXHAUSTION,pTarget)) return;
+    }
+
+    // Threat control
+    if (pThreat < threatThreshold || m_tank->GetGUID() == m_bot->GetGUID() ) { } //Continue attack
+    else
+    {
+        if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+        {
+            m_bot->SetSelection(pet->getVictim()->GetGUID());
+            return;
+        }
+        else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else if (CastSpell(SOULSHATTER,m_bot)) { return; }
+        else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+        else { return; } // No more threat reducing spells, just slow down
+    }
+
+
+
+    //Urgent DPS
+    if ((m_bot->HasAura(P_NIGHTFALL) || m_bot->HasAura(P_BACKLASH)) && CastSpell(SHADOW_BOLT,pTarget)) { return; }
+    if (INCINERATE && pTarget->HasAura(IMMOLATE,m_bot->GetGUID()) && CastSpell(INCINERATE,pTarget)) { return; }
+    if (CONFLAGRATE && (pTarget->HasAura(IMMOLATE,m_bot->GetGUID()) || pTarget->HasAura(SHADOWFLAME,m_bot->GetGUID())) && CastSpell(CONFLAGRATE,pTarget)) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) < 2 && CastSpell(SHADOWBURN,pTarget)) { return; }
+    if (ai->GetHealthPercent(*pTarget) < 5 && m_bot->GetItemCount(SOUL_SHARD) < 20 && CastSpell(DRAIN_SOUL,pTarget)) { return; }
+
+    //Dps up
+    if (ai->GetHealthPercent(*pTarget) > 95) { return; } // dont dps too early
+
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+    if (CastSpell(HAUNT,pTarget)) { return; }
+
+    //AOE
+    if (isUnderAttack(m_tank,4) && CastSpell(SHADOWFLAME,pTarget)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(RAIN_OF_FIRE,pTarget)) { return; }
+
+    //Dps Main
+    if(CURSE_OF_ELEMENTS) { if (!CheckCurse(pTarget) && CastSpell(CURSE_OF_ELEMENTS, pTarget)) { return; } } //curse of elements trumps any other curses
+    else if (CURSE_OF_AGONY) { if (!CheckCurse(pTarget) && CastSpell(CURSE_OF_AGONY, pTarget)) { return; } }
+
+    if (SEED_OF_CORRUPTION && isUnderAttack(m_tank,4)) { if (CastSpell(SEED_OF_CORRUPTION,pTarget)) { return;} }
+    else if (CastSpell(CORRUPTION,pTarget)) { return; }
+
+    if (CastSpell(CHAOS_BOLT,pTarget)) { return; }
+
+    if (UNSTABLE_AFFLICTION) { if (CastSpell(UNSTABLE_AFFLICTION,pTarget)) { return; } }
+    else if (CastSpell(IMMOLATE,pTarget)) { return; }
+
+    if (CastSpell(SHADOW_BOLT,pTarget)) { return; }
+
+
+
+
+    //Use healthstone??
+    // drink poition
+    if(ai->GetManaPercent() < 5 )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+} //end DoNextCombatManeuver
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot,30,0,0,0,0,1)) { return; }
+
+    //Own Buffs
+    if (CastSpell (FEL_ARMOR, m_bot)) { return; }
+    if (!FEL_ARMOR && CastSpell(DEMON_ARMOR, m_bot)) { return; }
+    if (SOUL_LINK && m_bot->GetPet() && !m_bot->HasAuraType(SPELL_AURA_SPLIT_DAMAGE_PCT) && CastSpell(SOUL_LINK,m_bot)) { return; }
+
+    if(m_bot->GetPet() == NULL) {
+        if (SUMMON_FELGUARD)
+            CastSpell(SUMMON_FELGUARD, m_bot);
+        else
+            CastSpell(SUMMON_IMP, m_bot);
+    } else {
+    m_bot->GetPet()->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+    m_bot->GetPet()->GetCharmInfo()->SetIsCommandAttack(false);
+    }
+
+    //Create Healthstone?
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 && ai->GetHealthPercent() > 60 && CastSpell (LIFE_TAP, m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 || ai->GetHealthPercent() < 50) { ai->Feast(); }
+
+
+} //end DoNonCombatActions
+
+bool PlayerbotWarlockAI::BuffPlayer(Unit *target)
+{
+    if (!target || target->isDead()) return false;
+
+    if (!HasAuraName(target, DETECT_INVISIBILITY) && CastSpell(DETECT_INVISIBILITY, target)) { return true; }
+    if (!HasAuraName(target, UNENDING_BREATH) && CastSpell(UNENDING_BREATH, target)) { return true; }
+    return false;
+}
+
+uint32 PlayerbotWarlockAI::CheckCurse(Unit *target)
+{
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead() || !target || target->isDead() ) { return 0; }
+    uint64 mGuid = m_bot->GetGUID();
+
+    if (CURSE_OF_ELEMENTS && target->HasAura(CURSE_OF_ELEMENTS,mGuid)) { return CURSE_OF_ELEMENTS; }
+    if (CURSE_OF_AGONY && target->HasAura(CURSE_OF_AGONY,mGuid)) { return CURSE_OF_AGONY; }
+    if (CURSE_OF_TONGUES && target->HasAura(CURSE_OF_TONGUES,mGuid)) { return CURSE_OF_TONGUES; }
+    if (CURSE_OF_WEAKNESS && target->HasAura(CURSE_OF_WEAKNESS,mGuid)) { return CURSE_OF_WEAKNESS; }
+    if (CURSE_OF_DOOM && target->HasAura(CURSE_OF_DOOM,mGuid)) { return CURSE_OF_DOOM; }
+    if (CURSE_OF_RECKLESSNESS && target->HasAura(CURSE_OF_RECKLESSNESS,mGuid)) { return CURSE_OF_RECKLESSNESS; }
+    if (CURSE_OF_EXHAUSTION && target->HasAura(CURSE_OF_EXHAUSTION,mGuid)) { return CURSE_OF_EXHAUSTION; }
+    return 0;
+}
+
+//void PlayerbotWarlockAI::BuffPlayer(Player *target){}
+
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
new file mode 100644
index 0000000..6904261
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
@@ -0,0 +1,57 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotWarlockAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotWarlockAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotWarlockAI();
+
+        virtual void LoadSpells();
+
+    //all combat actions go here
+    void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Unit *target);
+
+    uint32 CheckCurse(Unit *target);
+
+  private:
+    //CURSES
+    uint32 CURSE_OF_ELEMENTS, CURSE_OF_WEAKNESS, CURSE_OF_AGONY, CURSE_OF_RECKLESSNESS, CURSE_OF_TONGUES, CURSE_OF_DOOM, CURSE_OF_EXHAUSTION;
+
+    //AFFLICTION
+    uint32 CORRUPTION, DRAIN_SOUL, DRAIN_LIFE, DRAIN_MANA, SIPHON_LIFE, UNSTABLE_AFFLICTION, HAUNT, SEED_OF_CORRUPTION, DEATH_COIL;
+
+    //DESTRUCTION
+    uint32 SHADOW_BOLT, IMMOLATE, INCINERATE, SEARING_PAIN, CONFLAGRATE, SOUL_FIRE, SHADOWBURN, SHADOWFURY, CHAOS_BOLT, SHADOWFLAME, RAIN_OF_FIRE, HELLFIRE;
+
+    //DEMONOLOGY
+    uint32 DEMON_ARMOR, FEL_ARMOR, SOULSHATTER, HEALTH_FUNNEL, DARK_PACT, SOUL_LINK, DEMONIC_EMPOWERMENT, METAMORPHOSIS, SUMMON_IMP, SUMMON_VOIDWALKER, SUMMON_SUCCUBUS, SUMMON_FELHUNTER, SUMMON_FELGUARD;
+
+    //CC
+    uint32 FEAR, HOWL_OF_TERROR, BANISH, ENSLAVE_DEMON;
+
+    //Buff
+    uint32 UNENDING_BREATH, DETECT_INVISIBILITY, SHADOW_WARD;
+
+    //Other
+    uint32 LIFE_TAP, CREATE_SOULSTONE;
+
+    //Special
+    uint32 SOUL_SHARD, P_BACKLASH, P_NIGHTFALL, SHOOT;
+
+    uint32 TALENT_DEMONOLOGY, TALENT_AFFLICTION, TALENT_DESTRUCTION;
+};
+
+#endif
+
+
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
new file mode 100644
index 0000000..29ad3ad
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
@@ -0,0 +1,400 @@
+/*
+Name : PlayerbotWarrior.cpp
+Complete: maybe around 75%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is Blood dps/offtank type
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Situations needing Intervene casting : limited / non-existant..
+                - Intervene / Piercing Howl / Hamstring are not used..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotWarriorAI.h"
+
+class PlayerbotAI;
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI(){}
+
+void PlayerbotWarriorAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+   #pragma region SpellId Fill
+    //Defensive Stance
+    SHIELD_WALL = ai->getSpellIdExact("Shield Wall");
+    REVENGE = ai->getSpellIdExact("Revenge");
+    SHIELD_BLOCK = ai->getSpellIdExact("Shield Block");
+    DISARM = ai->getSpellIdExact("Disarm");
+    INTERVENE = ai->getSpellIdExact("Intervene");
+
+    //Berserker Stance
+    RECKLESSNESS = ai->getSpellIdExact("Recklessness");
+    WHIRLWIND = ai->getSpellIdExact("Whirlwind");
+    PUMMEL = ai->getSpellIdExact("Pummel");
+    INTERCEPT = ai->getSpellIdExact("Intercept");
+
+    //Battle Stance
+    RETALIATION = ai->getSpellIdExact("Retaliation");
+    CHARGE = ai->getSpellIdExact("Charge");
+    OVERPOWER = ai->getSpellIdExact("Overpower");
+    SHATTERING_THROW = ai->getSpellIdExact("Shattering Throw");
+
+    //Mixed Attacks
+    REND = ai->getSpellIdExact("Rend");                                // 1 2
+    THUNDER_CLAP = ai->getSpellIdExact("Thunder Clap");
+    SPELL_REFLECTION = ai->getSpellIdExact("Spell Reflection");
+    SHIELD_BASH = ai->getSpellIdExact("Shield Bash");
+    EXECUTE = ai->getSpellIdExact("Execute");                        // 1 3
+    HAMSTRING = ai->getSpellIdExact("Hamstring");
+    SWEEPING_STRIKES = ai->getSpellIdExact("Sweeping Strikes");
+    VICTORY_RUSH = ai->getSpellIdExact("Victory Rush");
+
+
+    //General attacks
+    HEROIC_STRIKE = ai->getSpellIdExact("Heroic Strike");
+    MORTAL_STRIKE = ai->getSpellIdExact("Mortal Strike");
+    BLOODTHIRST = ai->getSpellIdExact("Bloodthirst");
+    SHIELD_SLAM = ai->getSpellIdExact("Shield Slam");
+    SHOCKWAVE = ai->getSpellIdExact("Shockwave");
+    SLAM = ai->getSpellIdExact("Slam");
+    CLEAVE = ai->getSpellIdExact("Cleave");
+    BLADESTORM = ai->getSpellIdExact("Bladestorm");
+    HEROIC_THROW = ai->getSpellIdExact("Heroic Throw");
+    CONCUSSION_BLOW = ai->getSpellIdExact("Concussion Blow");
+    SUNDER_ARMOR = ai->getSpellIdExact("Sunder Armor");
+    DEMORALIZING_SHOUT = ai->getSpellIdExact("Demoralizing Shout");
+    INTIMIDATING_SHOUT = ai->getSpellIdExact("Intimidating Shout");
+    PIERCING_HOWL = ai->getSpellIdExact("Piercing Howl");
+    DEVASTATE = ai->getSpellIdExact("Devastate");
+
+
+    //buffs
+    COMMANDING_SHOUT = ai->getSpellIdExact("Commanding Shout");
+    BATTLE_SHOUT = ai->getSpellIdExact("Battle Shout");
+    VIGILANCE = ai->getSpellIdExact("Vigilance");
+    BERSERKER_RAGE = ai->getSpellIdExact("Berserker Rage");
+    ENRAGED_REGENERATION = ai->getSpellIdExact("Enraged Regeneration");
+    BLOODRAGE = ai->getSpellIdExact("Bloodrage");
+    LAST_STAND = ai->getSpellIdExact("Last Stand");
+    HEROIC_FURY = ai->getSpellIdExact("Heroic Fury");
+    DEATH_WISH = ai->getSpellIdExact("Death Wish");
+
+
+    //Stances
+    DEFENSIVE_STANCE = ai->getSpellIdExact("Defensive Stance");
+    BATTLE_STANCE = ai->getSpellIdExact("Battle Stance");
+    BERSERKER_STANCE = ai->getSpellIdExact("Berserker Stance");
+
+
+    //Taunts
+    TAUNT = ai->getSpellIdExact("Taunt");
+    CHALLENGING_SHOUT = ai->getSpellIdExact("Challenging Shout");
+    MOCKING_BLOW = ai->getSpellIdExact("Mocking Blow");
+
+    //Special
+    SLAMM = 46916; //Instant Slam (Blood Surge)
+
+    TALENT_ARMS = MORTAL_STRIKE;
+    TALENT_FURY = BLOODTHIRST;
+    TALENT_PROT = DEVASTATE;
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    uint8 talentCounter = 0;
+    if (TALENT_ARMS) talentCounter++;
+    if (TALENT_FURY) talentCounter++;
+    if (TALENT_PROT) talentCounter++;
+    if (talentCounter > 1) { TALENT_ARMS = 0; TALENT_FURY = 0; TALENT_PROT = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    if (!m_pulling){
+        #pragma region Choose Role / Stance
+
+        m_role = BOT_ROLE_DPS_MELEE;
+
+        // Choose Stance
+        if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+        {
+            if (ChangeStance(DEFENSIVE_STANCE)) { m_role = BOT_ROLE_TANK; return; }  //m_bot->GetShield(true)
+        }
+        else if (isUnderAttack()) // I am under attack
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2)  {} // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CanCast(R_SHADOWMELD,m_bot) && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+            if (m_bot->GetShield(true)) { if (ChangeStance(DEFENSIVE_STANCE)) { m_role = BOT_ROLE_OFFTANK; return; } }
+            else if (ChangeStance(BATTLE_STANCE)) { return; }
+        }
+        else if (ai->GetHealthPercent() > 90)
+        {
+            if (ChangeStance(BERSERKER_STANCE)) { return; }
+        }
+        else if (ai->GetForm() != FORM_BERSERKERSTANCE || ai->GetHealthPercent() < 70 ) { if (ChangeStance(BATTLE_STANCE)) { return; } }
+        #pragma endregion
+    }
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[7] = { HEROIC_FURY, BERSERKER_RAGE, BLADESTORM, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    TakePosition(pTarget);
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    if (m_pulling) {
+        if (GetAI()->CastSpell(SHOOT,pTarget)) {
+            m_pulling = false;
+            GetAI()->SetCombatOrder(ORDERS_NONE);
+            GetAI()->Follow(*GetMaster());
+            GetAI()->SetIgnoreUpdateTime(2);
+         }
+          return;
+    }
+
+    #pragma region Buff Heal Interrupt
+    //Buff UP
+    if (!m_bot->HasAura(BATTLE_SHOUT) && CastSpell(BATTLE_SHOUT,m_bot)) { return; }
+    if (!m_bot->HasAura(BATTLE_SHOUT,m_bot->GetGUID()) && !m_bot->HasAura(COMMANDING_SHOUT) && CastSpell(COMMANDING_SHOUT,m_bot)) { return; }
+
+
+    //HEAL UP && PROTECT UP
+    if (ai->GetHealthPercent() <= 85 && CastSpell(SHIELD_BLOCK, m_bot)) { } //no GCD
+    if (ai->GetHealthPercent() <= 45 && CastSpell(SHIELD_WALL, m_bot)) { return; }
+    if (ai->GetHealthPercent() < 55 &&
+        (m_bot->HasAura(BERSERKER_RAGE) || m_bot->HasAura(BLOODRAGE) || m_bot->HasAura(DEATH_WISH)) //There are other spells that count as enrage
+        && CastSpell(ENRAGED_REGENERATION,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 25 && CastSpell(INTIMIDATING_SHOUT, m_bot)) { return; }
+    if (ai->GetHealthPercent() <= 75 && CastSpell(LAST_STAND, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+
+    //Break spells being cast
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && CastSpell(SPELL_REFLECTION,pTarget)) { return; }
+        if (m_bot->HasAura(SPELL_REFLECTION))
+        {
+            if (CastSpell(SHIELD_BASH,pTarget)) {} // No GCD
+            else if (CastSpell(PUMMEL,pTarget)) { return; }
+            else if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+        }
+    }
+    #pragma endregion
+
+    #pragma region Taunt / Threat
+    // if i am main tank, protect master by taunt
+    if(m_tank->GetGUID() == m_bot->GetGUID())
+    {
+        // Taunt if needed (Only for master)
+        Unit *curAtt = GetAttackerOf(GetMaster());
+        if (curAtt)
+        {
+            if (isUnderAttack(GetMaster(),2) && CastSpell(CHALLENGING_SHOUT, curAtt)) { return; }
+            if (CastSpell(TAUNT, curAtt,true,true))  { return; }
+            if (CastSpell(VIGILANCE, GetMaster())) { return; }
+            if (CastSpell(TAUNT, curAtt))  { return; }
+            if (CastSpell(MOCKING_BLOW, curAtt)) { return; }
+        }
+        // My target is not attacking me, taunt..
+        if (pVictim && pVictim->GetGUID() != m_bot->GetGUID())
+        {
+            if (CastSpell(VIGILANCE, pVictim)) { return; }
+            if (CastSpell(TAUNT, pTarget))  { return; }
+            if (CastSpell(MOCKING_BLOW, pTarget)) { return; }
+        }
+    }
+
+    // If not in Defensive Stance slow down due to threat
+    if (pThreat > threatThreshold && ai->GetForm() != FORM_DEFENSIVESTANCE && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else { return; } //Warrior has no threat reducing spells, just slow down
+    }
+    #pragma endregion
+
+    #pragma region Dps
+
+    //Ranged Stuff (Openers)
+    if (CastSpell(CHARGE,pTarget)) { } //no GCD
+    else if (CastSpell(INTERCEPT,pTarget)) { } //no GCD
+    if (pDist > MELEE_RANGE && ai->GetForm() == FORM_DEFENSIVESTANCE && CastSpell(HEROIC_THROW,pTarget)) { return; } //High threat
+    if (pDist > MELEE_RANGE && CastSpell(SHATTERING_THROW,pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(HAMSTRING,pTarget)) return;
+        if (CastSpell(PIERCING_HOWL,pTarget)) return;
+    }
+
+
+    //Dps up
+    if (ai->GetHealthPercent() > 90 && ai->GetRageAmount() < 20 && CastSpell(BLOODRAGE,m_bot))  { return; }
+    if (isUnderAttack() && CastSpell(RETALIATION,m_bot)) { return; }
+    if (ai->GetHealthPercent() > 90 && CastSpell(DEATH_WISH,m_bot)) { return; }
+    if (ai->GetHealthPercent() > 80 && CastSpell(RECKLESSNESS,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    //Tank only stuff
+    if ((ai->GetForm() == FORM_DEFENSIVESTANCE || ai->GetRageAmount() > 85) && CastSpell(THUNDER_CLAP)) { return; } //High threat
+    if ((ai->GetForm() == FORM_DEFENSIVESTANCE || ai->GetRageAmount() > 75) && CastSpell(HEROIC_STRIKE)) {} //nogcd high threat
+
+    //Finishing Move / Timed moves
+    if (ai->GetHealthPercent(*pTarget) < 20 && CastSpell(EXECUTE,pTarget)) { return; }
+    if (CastSpell(VICTORY_RUSH,pTarget)) { return; }
+
+    //AOE
+    if (CastSpell(SHOCKWAVE,pTarget)) { return; }
+    if ((isUnderAttack(m_tank,3) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(CLEAVE,pTarget)) {} //no GCD
+    if (isUnderAttack(m_tank,3) && CastSpell(SWEEPING_STRIKES,m_bot)) {} //no GCD
+    if (isUnderAttack(m_tank,4) && CastSpell(BLADESTORM,m_bot)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(WHIRLWIND,pTarget)) { return; }
+
+    //Main dps
+    if (m_bot->HasAura(SLAMM) && CastSpell(SLAM,pTarget)) { return; }  //instant slam only
+    if (CastSpell(REVENGE,pTarget)) { return; } //Def stance only
+    if (CastSpell(OVERPOWER,pTarget)) { return; }
+    if (CastSpell(SHIELD_SLAM,pTarget)) { return; }
+    if (CastSpell(BLOODTHIRST,pTarget)) { return; }
+    if (CastSpell(MORTAL_STRIKE,pTarget)) { return; }
+
+
+    //Support/Debuff
+    if (CastSpell(DEMORALIZING_SHOUT,pTarget)) { return; }
+    if (DEVASTATE) { if (CastSpell(DEVASTATE,pTarget,1,1)) { return; } }  //High threat
+    else if (CastSpell(SUNDER_ARMOR)) { return; } //Only 1 - High threat
+    if (CastSpell(CONCUSSION_BLOW,pTarget)) { return; }
+    if (CastSpell(REND,pTarget)) { return; }
+    if (CastSpell(DISARM,pTarget)) { return; }
+    #pragma endregion
+
+} //end DoNextCombatManeuver
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff Up
+    if (!m_bot->HasAura(BATTLE_SHOUT) && CastSpell(BATTLE_SHOUT,m_bot)) { return; }
+    if (!m_bot->HasAura(BATTLE_SHOUT,m_bot->GetGUID()) && !m_bot->HasAura(COMMANDING_SHOUT) && CastSpell(COMMANDING_SHOUT,m_bot)) { return; }
+
+    if (GetMaster()->isAlive() && CastSpell(VIGILANCE, GetMaster())) { return; }
+
+    //want to start off in battle stance so we can CHARGE
+    //if(ai->GetRageAmount() < 20 && ai->GetForm() != FORM_BATTLESTANCE && ChangeStance(BATTLE_STANCE)) { return; }
+
+    //mana/hp check
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 75) { ai->Feast(); }
+} //end DoNonCombatActions
+
+bool PlayerbotWarriorAI::ChangeStance(uint32 stance)
+{
+    if (stance == 0) return false;
+    if (CastSpell(stance, GetPlayerBot())) { return true; }
+    return false;
+}
+
+void PlayerbotWarriorAI::Pull()
+{
+    if (!SHOOT) return;
+
+    // check ammo
+    uint32 ammo_id = GetPlayerBot()->GetUInt32Value(PLAYER_AMMO_ID);
+    if (!ammo_id) {
+        GetPlayerBot()->Say("I'm out of ammo.", LANG_UNIVERSAL);
+        return;
+    }
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        m_pulling = false;
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+}
+
+/*
+void PlayerbotWarriorAI::BreakCC(const uint32 diff)
+{
+    if(pvpTrinket_cd < diff && GCD < diff)
+    {
+        if(m_creature->HasAuraType(SPELL_AURA_MOD_ROOT) ||
+        m_creature->HasAuraType(SPELL_AURA_MOD_CONFUSE) || //dragons breath/blind/poly
+        m_creature->HasAura(8983)                       || //Druid bash rank 3
+        m_creature->HasAura(27006)                      || //Druid pounce rank 4
+        m_creature->HasAura(33786)                      || //Druid cyclone
+        m_creature->HasAura(22570, 1)                   || //Druid maim
+        m_creature->HasAura(10308)                      || //Paladin hammer of justice rank 4
+        m_creature->HasAura(30414, 1)                   || //Warlock shadowfury rank 3
+        m_creature->HasAura(6215)                       || //Warlock fear rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(17928)                      || //Warlock howlofterror rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(10890)                      || //Priest psychic scream rank 4 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(14902)                      || //Rogue Cheap shot
+        m_creature->HasAura(8643)                       || //Rogue Kidney shot Rank 2
+        m_creature->HasAura(38764, 2)                   || //Rogue Gouge Rank 6 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(12809))                        //Warrior concussion blow
+        {
+            doCast(m_creature, PVPTRINKET); //I think it would be better to instead of applying individual spells that apply the
+            pvpTrinket_cd = PVPTRINKET_CD;  //effect SPELL_AURA_MOD_STUN, just add that type and start removing bad choices e.g. impact.
+        }
+
+        if(m_creature->HasAura(11297) && m_creature->GetDistance(m_creature->getVictim()) < 10)
+        {      //if warrior sapped and creature is less then 10 yards from war, cast pvp trinket and attempt to demo shout him out of stealth
+            doCast(m_creature, PVPTRINKET);
+            pvpTrinket_cd = PVPTRINKET_CD;
+            castDemoralizingShout = true;
+        }
+    }
+} //BreakCC
+*/
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
new file mode 100644
index 0000000..87ab4a8
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
@@ -0,0 +1,57 @@
+#ifndef _PLAYERBOTWARRIORAI_H
+#define _PLAYERBOTWARRIORAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotWarriorAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotWarriorAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotWarriorAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        virtual void Pull();
+
+    private:
+        //Defensive Stance
+        uint32 SHIELD_WALL, REVENGE, SHIELD_BLOCK, DISARM, INTERVENE;
+
+        //Berserker Stance
+        uint32 RECKLESSNESS, WHIRLWIND, PUMMEL, INTERCEPT;
+
+        //Battle Stance
+        uint32 RETALIATION, CHARGE, OVERPOWER, SHATTERING_THROW;
+
+        //Mixed Attacks                                              //1 3
+        uint32 REND, THUNDER_CLAP, SPELL_REFLECTION, SHIELD_BASH, EXECUTE, HAMSTRING, SWEEPING_STRIKES, VICTORY_RUSH;
+
+        //General attacks
+        uint32 HEROIC_STRIKE, MORTAL_STRIKE, BLOODTHIRST, SHIELD_SLAM, SHOCKWAVE, SLAM, CLEAVE, BLADESTORM, HEROIC_THROW, CONCUSSION_BLOW, SUNDER_ARMOR, DEMORALIZING_SHOUT, INTIMIDATING_SHOUT, PIERCING_HOWL, DEVASTATE;
+
+        //buffs
+        uint32 COMMANDING_SHOUT, BATTLE_SHOUT, VIGILANCE, BERSERKER_RAGE, ENRAGED_REGENERATION, BLOODRAGE, LAST_STAND, HEROIC_FURY, DEATH_WISH;
+
+        //Stances
+        uint32 DEFENSIVE_STANCE, BATTLE_STANCE, BERSERKER_STANCE;
+
+        //Taunts
+        uint32 TAUNT, CHALLENGING_SHOUT, MOCKING_BLOW;
+
+        //Special
+        uint32 SLAMM;
+
+        uint32 TALENT_ARMS, TALENT_FURY, TALENT_PROT;
+
+        bool ChangeStance(uint32 stance);
+
+
+};
+
+#endif
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 65ba160..29f1f10 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -107,6 +107,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/dep/zlib
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/AI/PlayerBots
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
   ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
@@ -129,6 +130,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/EventAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/PlayerBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index be43862..53d256f 100755
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -217,6 +217,14 @@ ChatCommand* ChatHandler::getCommandTable()
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
+    static ChatCommand questCommandTable[] =
+    {
+        { "add",            SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestAdd>,                   "", NULL },
+        { "complete",       SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestComplete>,              "", NULL },
+        { "remove",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestRemove>,                "", NULL },
+        { NULL,             0,                  false, NULL,                                           "", NULL }
+    };
+
     static ChatCommand resetCommandTable[] =
     {
         { "achievements",   SEC_ADMINISTRATOR,  true,  OldHandler<&ChatHandler::HandleResetAchievementsCommand>,   "", NULL },
@@ -414,6 +422,9 @@ ChatCommand* ChatHandler::getCommandTable()
         { "bindsight",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBindSightCommand>,           "", NULL },
         { "unbindsight",    SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnbindSightCommand>,         "", NULL },
         { "playall",        SEC_GAMEMASTER,  false, OldHandler<&ChatHandler::HandlePlayAllCommand>,             "", NULL },
+        // Playerbot mod
+        { "bot",            SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandlePlayerbotCommand>,           "", NULL },
+        { "maintank",       SEC_PLAYER,  false, OldHandler<&ChatHandler::HandlePlayerbotMainTankCommand>,          "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index 24652fc..01c76c3 100755
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -174,6 +174,9 @@ class ChatHandler
         bool HandleBindSightCommand(const char* args);
         bool HandleUnbindSightCommand(const char* args);
 
+        bool HandlePlayerbotCommand(const char *args);
+        bool HandlePlayerbotMainTankCommand(const char *args);
+
         bool HandleGuildCreateCommand(const char* args);
         bool HandleGuildInviteCommand(const char* args);
         bool HandleGuildUninviteCommand(const char* args);
@@ -211,6 +214,10 @@ class ChatHandler
         bool HandlePDumpLoadCommand(const char *args);
         bool HandlePDumpWriteCommand(const char *args);
 
+        bool HandleQuestAdd(const char * args);
+        bool HandleQuestRemove(const char * args);
+        bool HandleQuestComplete(const char * args);
+
         bool HandleResetAchievementsCommand(const char * args);
         bool HandleResetAllCommand(const char * args);
         bool HandleResetHonorCommand(const char * args);
diff --git a/src/server/game/Chat/Commands/Level0.cpp b/src/server/game/Chat/Commands/Level0.cpp
index 338ad49..0457f1e 100755
--- a/src/server/game/Chat/Commands/Level0.cpp
+++ b/src/server/game/Chat/Commands/Level0.cpp
@@ -21,6 +21,7 @@
 #include "World.h"
 #include "Player.h"
 #include "Opcodes.h"
+#include "ObjectMgr.h"
 #include "Chat.h"
 #include "ObjectAccessor.h"
 #include "Language.h"
@@ -28,6 +29,7 @@
 #include "SystemConfig.h"
 #include "revision.h"
 #include "Util.h"
+#include "Group.h"
 
 bool ChatHandler::HandleHelpCommand(const char* args)
 {
@@ -147,6 +149,184 @@ bool ChatHandler::HandleSaveCommand(const char* /*args*/)
     return true;
 }
 
+//Playerbot mod
+bool ChatHandler::HandlePlayerbotCommand(const char *args)
+{
+    if(!m_session)
+    {
+        PSendSysMessage("You may only add bots from an active session");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if(!*args)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if(!cmd || !charname)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+    uint64 guid;
+
+   if (charnameStr.compare("all") != 0)
+   {
+       if (!normalizePlayerName(charnameStr))
+           return false;
+
+       guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+       if (guid == 0 || (guid == m_session->GetPlayer()->GetGUID()))
+       {
+           SendSysMessage(LANG_PLAYER_NOT_FOUND);
+           SetSentErrorMessage(true);
+           return false;
+       }
+
+       uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+       if (accountId != m_session->GetAccountId())
+       {
+           PSendSysMessage("You may only add bots from the same account.");
+           SetSentErrorMessage(true);
+           return false;
+       }
+   }
+
+    if (cmdStr.compare("add") == 0 || cmdStr.compare("login") == 0)
+    {
+        if (charnameStr.compare("all") == 0)
+        {
+            std::list<std::string> *names;
+            names=m_session->GetPlayer()->GetCharacterList();
+            std::list<std::string>::iterator iter,next;
+            for (iter = names->begin(); iter != names->end(); iter++)
+            {
+                std::stringstream arg;
+                arg << "add " << (*iter).c_str();
+                HandlePlayerbotCommand(arg.str().c_str());
+            }
+            PSendSysMessage("Bots added successfully.");
+            return true;
+        }
+        else
+        {
+            if(m_session->GetPlayerBot(guid) != NULL)
+            {
+                PSendSysMessage("Bot already exists in world.");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            m_session->AddPlayerBot(guid);
+        }
+
+    }
+    else if (cmdStr.compare("remove") == 0 || cmdStr.compare("logout") == 0)
+    {
+        if (charnameStr.compare("all") == 0)
+        {
+            std::list<std::string> *names = new std::list<std::string>;
+            for (PlayerBotMap::const_iterator iter = m_session->GetPlayerBotsBegin(); iter != m_session->GetPlayerBotsEnd(); ++iter)
+            {
+                names->push_back(iter->second->GetName());
+            }
+            std::list<std::string>::iterator iter,next;
+            for (iter = names->begin(); iter != names->end(); iter++)
+            {
+                std::stringstream arg;
+                arg << "remove " << (*iter).c_str();
+                HandlePlayerbotCommand(arg.str().c_str());
+            }
+            return true;
+        }
+        else
+        {
+            if (m_session->GetPlayerBot(guid) == NULL)
+            {
+                PSendSysMessage("Bot can not be removed because bot does not exist in world.");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            m_session->LogoutPlayerBot(guid, true);
+            PSendSysMessage("Bot removed successfully.");
+            return true;
+        }
+    }
+    return true;
+}
+
+bool ChatHandler::HandlePlayerbotMainTankCommand(const char *args)
+{
+    uint64 guid = 0;
+    uint64 pGuid = 0;
+    char *charname ;
+    Group *group = m_session->GetPlayer()->GetGroup();
+
+    if (group == NULL) {
+        PSendSysMessage("Must be in a group to set a main tank.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINTANK, group->GetGUID());
+    if(result)
+    {
+        pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+    }
+
+    // if no arguments are passed in, just say who the current main tank is
+    if(!*args) {
+
+        if (pGuid>0) {
+            Player *pPlayer = ObjectAccessor::FindPlayer(pGuid);
+
+            if (pPlayer  && pPlayer->isAlive()){
+                PSendSysMessage("Main tank is %s.", pPlayer->GetName());
+                return true;
+            }
+        }
+
+        PSendSysMessage("Currently there is no main tank. ");
+        return true;
+    } else {
+        charname = strtok ((char*)args, " ");
+        std::string charnameStr = charname;
+        guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+
+        // clear if same player
+        if (pGuid==guid) {
+            group->SetGroupMemberFlag(guid, false, MEMBER_FLAG_MAINTANK);
+            PSendSysMessage("Main tank has been cleared. ");
+            return true;
+        }
+
+        if (m_session->GetPlayer()->GetGroup()->IsMember(guid)) {
+            group->SetGroupMemberFlag(pGuid,false, MEMBER_FLAG_MAINTANK); // clear old one
+            group->SetGroupMemberFlag(guid, true, MEMBER_FLAG_MAINTANK);  // set new one
+            Player *pPlayer = ObjectAccessor::FindPlayer(guid);
+            if (pPlayer->IsInWorld())
+                PSendSysMessage("Main tank is %s.", pPlayer->GetName());
+            else
+                PSendSysMessage("Player is not online.");
+
+        } else {
+            PSendSysMessage("Player is not in your group.");
+        }
+
+    }
+
+
+    return true;
+}
+
 /// Display the 'Message of the day' for the realm
 bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
 {
diff --git a/src/server/game/Chat/Commands/Level1.cpp b/src/server/game/Chat/Commands/Level1.cpp
index f06f8a7..c441e52 100755
--- a/src/server/game/Chat/Commands/Level1.cpp
+++ b/src/server/game/Chat/Commands/Level1.cpp
@@ -183,9 +183,10 @@ bool ChatHandler::HandleSummonCommand(const char* args)
                 target->UnbindInstance(map->GetInstanceId(), target->GetDungeonDifficulty(), true);
 
             // we are in instance, and can summon only player in our group with us as lead
-            if (!m_session->GetPlayer()->GetGroup() || !target->GetGroup() ||
+            if(!target->IsPlayerbot() &&
+                (!m_session->GetPlayer()->GetGroup() || !target->GetGroup() ||
                 (target->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID()) ||
-                (m_session->GetPlayer()->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID()))
+                (m_session->GetPlayer()->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID())))
                 // the last check is a bit excessive, but let it be, just in case
             {
                 PSendSysMessage(LANG_CANNOT_SUMMON_TO_INST, nameLink.c_str());
diff --git a/src/server/game/Chat/Commands/Level3.cpp b/src/server/game/Chat/Commands/Level3.cpp
index f4f5892..a2d191f 100755
--- a/src/server/game/Chat/Commands/Level3.cpp
+++ b/src/server/game/Chat/Commands/Level3.cpp
@@ -263,8 +263,8 @@ bool ChatHandler::HandleAddItemCommand(const char *args)
 
     sLog->outDetail(GetTrinityString(LANG_ADDITEM), itemId, count);
 
-    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(itemId);
-    if (!pProto)
+    ItemTemplate const *pTemplate = sObjectMgr->GetItemTemplate(itemId);
+    if (!pTemplate)
     {
         PSendSysMessage(LANG_COMMAND_ITEMIDINVALID, itemId);
         SetSentErrorMessage(true);
@@ -2831,6 +2831,207 @@ bool ChatHandler::HandleServerIdleShutDownCommand(const char *args)
     return true;
 }
 
+bool ChatHandler::HandleQuestAdd(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .addquest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND,entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // check item starting quest (it can work incorrectly if added without item in inventory)
+    ItemTemplateContainer const* its = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator itr = its->begin(); itr != its->end(); ++itr)
+    {
+        if (itr->second.StartQuest == entry)
+        {
+            PSendSysMessage(LANG_COMMAND_QUEST_STARTFROMITEM, entry, itr->second.ItemId);
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+
+    // ok, normal (creature/GO starting) quest
+    if (player->CanAddQuest(pQuest, true))
+    {
+        player->AddQuest(pQuest, NULL);
+
+        if (player->CanCompleteQuest(entry))
+            player->CompleteQuest(entry);
+    }
+
+    return true;
+}
+
+bool ChatHandler::HandleQuestRemove(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .removequest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 quest = player->GetQuestSlotQuestId(slot);
+        if (quest == entry)
+        {
+            player->SetQuestSlot(slot,0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            player->TakeQuestSourceItem(quest, false);
+        }
+    }
+
+    // set quest status to not started (will updated in DB at next save)
+    player->SetQuestStatus(entry, QUEST_STATUS_NONE);
+
+    // reset rewarded for restart repeatable quest
+   // player->getQuestStatusMap()[entry].m_rewarded = false;
+
+    SendSysMessage(LANG_COMMAND_QUEST_REMOVED);
+    return true;
+}
+
+bool ChatHandler::HandleQuestComplete(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .quest complete #entry
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    // If player doesn't have the quest
+    if (!pQuest || player->GetQuestStatus(entry) == QUEST_STATUS_NONE)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // Add quest items for quests that require items
+    for (uint8 x = 0; x < QUEST_ITEM_OBJECTIVES_COUNT; ++x)
+    {
+        uint32 id = pQuest->ReqItemId[x];
+        uint32 count = pQuest->ReqItemCount[x];
+        if (!id || !count)
+            continue;
+
+        uint32 curItemCount = player->GetItemCount(id,true);
+
+        ItemPosCountVec dest;
+        uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count-curItemCount);
+        if (msg == EQUIP_ERR_OK)
+        {
+            Item* item = player->StoreNewItem(dest, id, true);
+            player->SendNewItem(item,count-curItemCount,true,false);
+        }
+    }
+
+    // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
+    for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+    {
+        uint32 creature = pQuest->ReqCreatureOrGOId[i];
+        uint32 creaturecount = pQuest->ReqCreatureOrGOCount[i];
+
+        if (uint32 spell_id = pQuest->ReqSpell[i])
+        {
+            for (uint16 z = 0; z < creaturecount; ++z)
+                player->CastedCreatureOrGO(creature,0,spell_id);
+        }
+        else if (creature > 0)
+        {
+            if (CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(creature))
+                for (uint16 z = 0; z < creaturecount; ++z)
+                    player->KilledMonster(creatureInfo,0);
+        }
+        else if (creature < 0)
+        {
+            for (uint16 z = 0; z < creaturecount; ++z)
+                player->CastedCreatureOrGO(creature,0,0);
+        }
+    }
+
+    // If the quest requires reputation to complete
+    if (uint32 repFaction = pQuest->GetRepObjectiveFaction())
+    {
+        uint32 repValue = pQuest->GetRepObjectiveValue();
+        uint32 curRep = player->GetReputationMgr().GetReputation(repFaction);
+        if (curRep < repValue)
+            if (FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction))
+                player->GetReputationMgr().SetReputation(factionEntry,repValue);
+    }
+
+    // If the quest requires a SECOND reputation to complete
+    if (uint32 repFaction = pQuest->GetRepObjectiveFaction2())
+    {
+        uint32 repValue2 = pQuest->GetRepObjectiveValue2();
+        uint32 curRep = player->GetReputationMgr().GetReputation(repFaction);
+        if (curRep < repValue2)
+            if (FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction))
+                player->GetReputationMgr().SetReputation(factionEntry,repValue2);
+    }
+
+    // If the quest requires money
+    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+    if (ReqOrRewMoney < 0)
+        player->ModifyMoney(-ReqOrRewMoney);
+
+    player->CompleteQuest(entry);
+    return true;
+}
+
 bool ChatHandler::HandleBanAccountCommand(const char *args)
 {
     return HandleBanHelper(BAN_ACCOUNT, args);
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 922db88..2afb6c3 100755
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -151,6 +151,9 @@ m_creatureInfo(NULL), m_creatureData(NULL), m_formation(NULL)
     for (uint8 i = 0; i < CREATURE_MAX_SPELLS; ++i)
         m_spells[i] = 0;
 
+    is_a_bot = false;
+    bot_AI = NULL;
+
     m_CreatureSpellCooldowns.clear();
     m_CreatureCategoryCooldowns.clear();
     DisableReputationGain = false;
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 665942e..a3188d6 100755
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -520,6 +520,15 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         void AI_SendMoveToPacket(float x, float y, float z, uint32 time, uint32 MovementFlags, uint8 type);
         CreatureAI* AI() const { return (CreatureAI*)i_AI; }
 
+        //Bot commands
+        void SetBotAI(CreatureAI *newAI)
+        {
+            bot_AI = newAI;
+        }
+        CreatureAI *GetBotAI(){ return bot_AI; }
+        void SetIAmABot(bool bot){ is_a_bot = bot; }
+        bool GetIAmABot(){ return is_a_bot; }
+
         uint32 GetShieldBlockValue() const                  //dunno mob block value
         {
             return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
@@ -755,6 +764,10 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         bool IsInvisibleDueToDespawn() const;
         bool CanAlwaysSee(WorldObject const* obj) const;
     private:
+
+        bool is_a_bot;
+        CreatureAI *bot_AI;
+
         //WaypointMovementGenerator vars
         uint32 m_waypointID;
         uint32 m_path_id;
diff --git a/src/server/game/Entities/Creature/GossipDef.h b/src/server/game/Entities/Creature/GossipDef.h
index 5173955..f9dee41 100755
--- a/src/server/game/Entities/Creature/GossipDef.h
+++ b/src/server/game/Entities/Creature/GossipDef.h
@@ -50,6 +50,7 @@ enum Gossip_Option
     GOSSIP_OPTION_UNLEARNPETTALENTS = 17,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_LEARNDUALSPEC     = 18,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_OUTDOORPVP        = 19,                   //added by code (option for outdoor pvp creatures)
+	GOSSIP_OPTION_BOT               = 20,
     GOSSIP_OPTION_MAX
 };
 
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index b17606b..c5fb6f5 100755
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -246,6 +246,14 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    if (owner &&
+        owner->GetTypeId() == TYPEID_PLAYER &&
+       ((Player*)owner)->HaveBot() &&
+       ((Player*)owner)->GetBot()->GetGUID()==this->GetGUID() &&
+       this->isDead()) {    // dont unsummon corpse if a bot
+        return;
+    }
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index 978d9ac..3ac9432 100755
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -1579,9 +1579,16 @@ void WorldObject::GetRandomPoint(const Position &pos, float distance, float &ran
 
 void WorldObject::UpdateGroundPositionZ(float x, float y, float &z) const
 {
-    float new_z = GetBaseMap()->GetHeight(x, y, z, true);
-    if (new_z > INVALID_HEIGHT)
-        z = new_z+ 0.05f;                                   // just to be sure that we are not a few pixel under the surface
+    float map_z = GetBaseMap()->GetHeight(x,y,z,false);
+    float vmap_z = GetBaseMap()->GetHeight(x,y,z,true);
+
+    if(vmap_z > INVALID_HEIGHT)
+       z = vmap_z;    // add or subtract say 0.05f, to adjust bot hover height
+
+    if((map_z > vmap_z) && (map_z > z))
+       z = map_z;
+
+    Trinity::NormalizeMapCoord(z);
 }
 
 bool Position::IsPositionValid() const
@@ -2159,8 +2166,18 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
-            summon = new Totem(properties, summoner);
-            break;
+        {
+            if(summoner->isCharmed())
+            {
+                //If the caster is charmed, assume it is a Bot.  This might not always be
+                //the case, but oh well.  This will allow the affects of the totem
+                //(ex healing, stoneskin, etc, to affect the bot owner insteadof the
+                //bot. Thats ok, the bot is expendable  :-)
+                summon = new Totem      (properties, summoner->GetCharmer());  break;
+            } else {
+                summon = new Totem      (properties, summoner);  break;
+            }
+        }
         case UNIT_MASK_MINION:
             summon = new Minion(properties, summoner);
             break;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 9b1b2c3..37278c1 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -72,6 +72,11 @@
 #include "LFGMgr.h"
 #include "CharacterDatabaseCleaner.h"
 #include "InstanceScript.h"
+// Playerbot mod
+#include "CreatureAIFactory.h"
+#include "Config.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
 #include <cmath>
 #include "AccountMgr.h"
 
@@ -631,8 +636,11 @@ UpdateMask Player::updateVisualBits;
 #ifdef _MSC_VER
 #pragma warning(disable:4355)
 #endif
-Player::Player (WorldSession* session): Unit(), m_achievementMgr(this), m_reputationMgr(this)
-{
+Player::Player (WorldSession *session): Unit(), m_achievementMgr(this), m_reputationMgr(this), m_MaxPlayerbots(9), m_bot_died(false)
+ {
+    // Playerbot mod
+    m_playerbotAI = NULL;
+
 #ifdef _MSC_VER
 #pragma warning(default:4355)
 #endif
@@ -847,6 +855,22 @@ Player::Player (WorldSession* session): Unit(), m_achievementMgr(this), m_reputa
 
     m_ChampioningFaction = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    m_botTimer = 0;
+    m_bot = NULL;
+    m_bot_form = 0;
+    m_bot_race = 0;
+    m_bot_class = 0;
+    m_bot_must_wait_for_spell_1 = 0;
+    m_bot_must_wait_for_spell_2 = 0;
+    m_bot_must_wait_for_spell_3 = 0;
+    m_bot_must_be_created = false;
+    m_bot_must_die = false;
+    m_bot_entry_must_be_created = 0;
+    m_bot_class_must_be_created = 0;
+    m_bot_race_must_be_created = 0;
+    m_bot_entry = 0;
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -890,6 +914,12 @@ Player::~Player ()
 
     delete m_declinedname;
     delete m_runes;
+    //Playerbot mod: remove AI if exists
+    if(m_playerbotAI != NULL)
+    {
+        delete m_playerbotAI;
+        m_playerbotAI = NULL;
+    }
 
     sWorld->DecreasePlayerCount();
 }
@@ -904,6 +934,15 @@ void Player::CleanupsBeforeDelete(bool finalCleanup)
     if (m_transport)
         m_transport->RemovePassenger(this);
 
+    if(GetGroup() && HaveBot())
+    {
+         Creature *m_bot = GetBot();
+         Group *m_group = GetGroup();
+         m_bot->SetCharmerGUID(0);
+         m_bot->RemoveFromWorld();
+         RemoveBot();
+    }
+
     // clean up player-instance binds, may unload some instance saves
     for (uint8 i = 0; i < MAX_DIFFICULTY; ++i)
         for (BoundInstancesMap::iterator itr = m_boundInstances[i].begin(); itr != m_boundInstances[i].end(); ++itr)
@@ -1713,6 +1752,16 @@ void Player::Update(uint32 p_time)
         m_regenTimer += p_time;
         RegenerateAll();
     }
+    //want to refresh bot even if we're dead so
+    //it can rez me
+
+    if(m_botTimer > 0)
+    {
+        if(p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
 
     if (m_deathState == JUST_DIED)
         KillPlayer();
@@ -1801,6 +1850,10 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && isAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //Playerbot mod: this was added as part of the Playerbot mod,
+    if(m_playerbotAI != NULL) m_playerbotAI->UpdateAI(p_time);
+
 }
 
 void Player::setDeathState(DeathState s)
@@ -2041,7 +2094,7 @@ void Player::SendTeleportPacket(Position &oldPos)
     WorldPacket data2(MSG_MOVE_TELEPORT, 38);
     data2.append(GetPackGUID());
     BuildMovementPacket(&data2);
-    Relocate(&oldPos);
+    if (!this->IsPlayerbot()) Relocate(&oldPos);
     SendMessageToSet(&data2, false);
 }
 
@@ -2092,6 +2145,14 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         return false;
     }
 
+    //Playerbot mod: if this user has bots, tell them to stop following master
+    //so they don't try to follow the master after the master teleports
+    for(PlayerBotMap::const_iterator itr = GetSession()->GetPlayerBotsBegin(); itr != GetSession()->GetPlayerBotsEnd(); ++itr)
+    {
+            Player *botPlayer = itr->second;
+            botPlayer->GetMotionMaster()->Clear();
+    }
+
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
@@ -2141,6 +2202,19 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         }
     }
 
+     //HACK ELSE CLIENT CRASH WHEN PLAYER IS TELEPORTED
+     if(GetGroup() && HaveBot())
+     {
+         //sLog->outError("Player::teleporting.. removing from group");
+
+         Group *m_group = GetGroup();
+         Creature *m_bot = GetBot();
+         m_bot->SetCharmerGUID(0);
+         m_bot->RemoveFromWorld();
+         RemoveBot();
+         SetBotMustBeCreated(m_bot_entry, newbotrace, newbotclass);
+     }
+
     // The player was ported to another map and loses the duel immediately.
     // We have to perform this check before the teleport, otherwise the
     // ObjectAccessor won't find the flag.
@@ -2318,6 +2392,20 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         else
             return false;
     }
+
+    //if I'm dead than need to remove bot manually
+    //This means I'm at the graveyard, but the bot or rest of the group
+    //finished off the mob
+    if(HaveBot() && m_bot->isAlive() && !isAlive())
+    {
+        m_bot->SetCharmerGUID(0);
+        m_bot->RemoveFromWorld();
+        RemoveBot();
+
+        //recreate it when you are alive again
+        SetBotMustBeCreated(m_bot_entry, newbotrace, newbotclass);
+    } //end if bot is alive and I'm not
+
     return true;
 }
 
@@ -2442,6 +2530,166 @@ void Player::RemoveFromWorld()
     }
 }
 
+Player *Player::GetObjPlayer(uint64 guid)
+{
+    return ObjectAccessor::FindPlayer(guid);
+}
+
+void Player::RemoveBot()
+{
+    if(m_botHasPet && m_botsPet != NULL)
+    {
+        m_botsPet->SetCharmerGUID(0);
+        m_botsPet->CombatStop();
+        m_botsPet->DeleteFromDB();
+        m_botsPet->CleanupsBeforeDelete();
+        m_botsPet->AddObjectToRemoveList();
+    }
+    m_botsPet = NULL;
+    m_botHasPet = false;
+
+    m_bot->CombatStop();
+    m_bot->DeleteFromDB();
+    m_bot->CleanupsBeforeDelete();
+    m_bot->SetIAmABot(false); //this HAS to come after CleanupsBeforeDelete
+    m_bot->AddObjectToRemoveList();
+
+    m_bot = NULL; m_bot_class = 0; m_bot_race = 0; m_bot_form = 0;
+    m_bot_must_wait_for_spell_1 = 0; m_bot_must_wait_for_spell_2 = 0;
+    m_bot_must_wait_for_spell_3 = 0; m_bot_must_be_created = false;
+
+    if(m_bot_ai)
+    {
+        //delete m_bot_ai;
+        m_bot_ai = NULL;
+    }
+    m_bot_must_die = false;
+
+
+} //end RemoveBot
+
+Creature *Player::GetBotsPet(uint32 entry)
+{
+    Creature *pet = this->SummonCreature(entry, GetPositionX() + 10, GetPositionY() + 10, GetPositionZ(), 0, TEMPSUMMON_DEAD_DESPAWN, 0);
+
+    QueryResult result;
+
+    result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi FROM pet_levelstats WHERE creature_entry = 1860 AND level=%u", this->getLevel());
+
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt32();
+        uint32 mana = fields[1].GetUInt32();
+        uint32 armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt32();
+        uint32 agi = fields[4].GetUInt32();
+        //sLog->outError("hp = %u", hp);
+        //sLog->outError("mana = %u", mana);
+        //sLog->outError("str = %u", str);
+        //sLog->outError("agi = %u", agi);
+
+        pet->SetMaxHealth(hp);
+        pet->SetMaxPower(POWER_MANA, mana);
+        pet->SetArmor(armor);
+        pet->SetStat(STAT_STRENGTH, str);
+        pet->SetStat(STAT_AGILITY, agi);
+
+        //delete result;
+    }
+    pet->SetLevel(getLevel());
+
+    m_botHasPet = true;
+    m_botsPet = pet;
+
+    return pet;
+} //end GetBotsPet
+
+void Player::SetBotsPetDied()
+{
+    if(m_botHasPet && m_botsPet != NULL)
+    {
+        m_botsPet->SetCharmerGUID(0);
+        m_botsPet->CombatStop();
+        m_botsPet->DeleteFromDB();
+        m_botsPet->CleanupsBeforeDelete();
+        m_botsPet->AddObjectToRemoveList();
+    }
+
+    m_botsPet = NULL;
+    m_botHasPet = false;
+}
+
+//
+//This is called from script_bot_giver.cpp
+//
+uint8 Player::GetMaxPlayerBot()
+{
+    //load config variables
+    if(m_MaxPlayerbots > 9) m_MaxPlayerbots = ConfigMgr::GetIntDefault("Bot.MaxPlayerbots", 9);
+
+    return m_MaxPlayerbots;
+
+}
+
+//
+//This is called from script_bot_giver.cpp
+//
+void Player::CreatePlayerBot(std::string name)
+{
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(name.c_str());
+    if(m_session->GetPlayerBot(guid) != NULL) return;
+    m_session->AddPlayerBot(guid);
+}
+
+//
+//This is called from script_bot_giver.cpp
+//
+std::list<std::string> *Player::GetCharacterList()
+{
+    std::string plName;
+    QueryResult results;
+
+    results = CharacterDatabase.PQuery("SELECT name FROM characters WHERE account='%u' AND online=0", m_session->GetAccountId());
+
+    if(!results) return NULL;
+
+    plName = (*results)[0].GetString();
+
+    std::list<std::string> *names = new std::list<std::string>;
+    do {
+        Field *fields = results->Fetch();
+        plName = fields[0].GetString();
+        if(plName.compare(GetName()) == 0) continue;
+        names->insert(names->end(), fields[0].GetString());
+    } while(results->NextRow());
+    return names;
+} //end GetCharacterList
+
+//Playerbot mod:
+void Player::SetPlayerbotAI(PlayerbotAI *ai)
+{
+    if(ai == NULL)
+    {
+        sLog->outError("Tried to assign playerbot AI to NULL; this is not supported!");
+        return;
+    }
+    if(GetPlayerbotAI() != NULL)
+    {
+        sLog->outError("Tried to reassign playerbot AI; this is not yet supported!");
+        return;
+    }
+    //assigning bot AI to normal players is not currently supported
+    if(!IsPlayerbot())
+    {
+        sLog->outError("Tried to set playerbot AI for a player that was not a bot.");
+        return;
+    }
+    m_playerbotAI = ai;
+
+    m_SaveOrgLocation = ConfigMgr::GetIntDefault("Bot.SaveOrgLocation", 0);
+}
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2728,7 +2976,7 @@ Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
                     return NULL;
 
     // not too far
-    if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+    if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE) && !IsPlayerbot())
         return NULL;
 
     return creature;
@@ -2917,6 +3165,30 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+        Player *_player = ObjectAccessor::FindPlayer(guid);
+
+        if(_player!=NULL) {
+            WorldSession *session= _player->GetSession();
+            // Playerbot mod: if you remove yourself from a group, log out all playerbots
+
+            //save the map of playerbots first because if the map gets altered when
+            //a playerbot logs out which will corrupt the for loop
+            PlayerBotMap m_playerBots;
+            for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+            {
+                Player *bot = itr->second;
+                (m_playerBots)[itr->first] = bot;
+            }
+            for(PlayerBotMap::const_iterator itr2 = m_playerBots.begin(); itr2 != m_playerBots.end(); ++itr2)
+           {
+                Player *botPlayer = itr2->second;
+                if (!botPlayer) continue;
+
+                session->LogoutPlayerBot(botPlayer->GetGUID(),true);
+            }
+
+			if (!ObjectAccessor::FindPlayer(guid)->GetGroup() || group->GetMembersCount()==0) return;
+        }
         group->RemoveMember(guid, method, kicker, reason);
         group = NULL;
     }
@@ -7129,6 +7401,10 @@ bool Player::RewardHonor(Unit* uVictim, uint32 groupsize, int32 honor, bool pvpt
         {
             Player* pVictim = uVictim->ToPlayer();
 
+            if(pVictim->IsPlayerbot() && (!sWorld->getBoolConfig(CONFIG_HONOR_FROM_PLAYERBOTS) ||
+                pVictim->GetPlayerbotAI()->GetClassAI()->GetMaster() == this)) //Killing your own playerbots is not honorable!
+                return false;
+
             if (GetTeam() == pVictim->GetTeam() && !sWorld->IsFFAPvPRealm())
                 return false;
 
@@ -15816,6 +16092,8 @@ void Player::KilledMonsterCredit(uint32 entry, uint64 guid)
             }
         }
     }
+    //Playerbot mod
+    if(m_playerbotAI != NULL) m_playerbotAI->KilledMonster(entry, guid);
 }
 
 void Player::KilledPlayerCredit()
@@ -15981,6 +16259,7 @@ void Player::TalkedToCreature(uint32 entry, uint64 guid)
                             m_QuestStatusSave[questid] = true;
 
                             SendQuestUpdateAddCreatureOrGo(qInfo, guid, j, curTalkCount, addTalkCount);
+							if (IsPlayerbot()) this->GetPlayerbotAI()->TellMaster("Talked to quest guy.");
                         }
                         if (CanCompleteQuest(questid))
                             CompleteQuest(questid);
@@ -18308,6 +18587,18 @@ void Player::SaveToDB()
 
     if (!IsBeingTeleported())
     {
+        if (IsPlayerbot() && m_SaveOrgLocation == 1)
+        {
+            ss << m_playerbotAI->GetStartMapID() << ", "
+            << (uint32)m_playerbotAI->GetStartInstanceID() << ", "
+            << (uint32)m_playerbotAI->GetStartDifficulty() << ", "
+            << finiteAlways(m_playerbotAI->GetStartX()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartY()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartZ()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartO()) << ", ";
+        }
+        else
+        {
         ss << GetMapId() << ','
         << (uint32)GetInstanceId() << ','
         << uint32(uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4) << ','
@@ -18315,9 +18606,22 @@ void Player::SaveToDB()
         << finiteAlways(GetPositionY()) << ','
         << finiteAlways(GetPositionZ()) << ','
         << finiteAlways(GetOrientation()) << ',';
+        }
     }
     else
     {
+        if (IsPlayerbot() && m_SaveOrgLocation == 1)
+        {
+            ss << m_playerbotAI->GetStartMapID() << ", "
+            << (uint32)m_playerbotAI->GetStartInstanceID() << ", "
+            << (uint32)m_playerbotAI->GetStartDifficulty() << ", "
+            << finiteAlways(m_playerbotAI->GetStartX()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartY()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartZ()) << ", "
+            << finiteAlways(m_playerbotAI->GetStartO()) << ", ";
+        }
+        else
+        {
         ss << GetTeleportDest().GetMapId() << ','
         << (uint32)0 << ','
         << uint32(uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4) << ','
@@ -18325,6 +18629,7 @@ void Player::SaveToDB()
         << finiteAlways(GetTeleportDest().GetPositionY()) << ','
         << finiteAlways(GetTeleportDest().GetPositionZ()) << ','
         << finiteAlways(GetTeleportDest().GetOrientation()) << ',';
+        }
     }
 
     ss << m_taxi << ',';                                    // string with TaxiMaskSize numbers
@@ -19330,7 +19635,7 @@ void Player::StopCastingCharm()
     }
 }
 
-inline void Player::BuildPlayerChat(WorldPacket* data, uint8 msgtype, const std::string& text, uint32 language) const
+void Player::BuildPlayerChat(WorldPacket* data, uint8 msgtype, const std::string& text, uint32 language) const
 {
     *data << uint8(msgtype);
     *data << uint32(language);
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index bb39d90..18477c7 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -55,6 +55,9 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+//Playerbot mod
+class PlayerbotAI;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -1555,7 +1558,13 @@ class Player : public Unit, public GridObject<Player>
         void RegenerateHealth();
         void setRegenTimerCount(uint32 time) {m_regenTimerCount = time;}
         void setWeaponChangeTimer(uint32 time) {m_weaponChangeTimer = time;}
-
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass);
+        void CreatePlayerBot(std::string name);
+        uint8 GetMaxPlayerBot();
+        //bool isTradeAccepted () {return getTradeData()->IsAccepted();}
+        void GetBotLevelInfo(uint32 race, uint32 class_,uint32 level, PlayerLevelInfo* info) const;
+        std::list<std::string> *GetCharacterList();
         uint32 GetMoney() const { return GetUInt32Value (PLAYER_FIELD_COINAGE); }
         void ModifyMoney(int32 d);
         bool HasEnoughMoney(uint32 amount) const { return (GetMoney() >= amount); }
@@ -2010,7 +2019,71 @@ class Player : public Unit, public GridObject<Player>
         uint16 GetSkillStep(uint16 skill) const;            // 0...6
         bool HasSkill(uint32 skill) const;
         void learnSkillRewardedSpells(uint32 id, uint32 value);
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        bool HaveBot(){ if(m_bot == NULL) return false; else return true; }
+        //CreatureInfo const *GetBotInfo();
+        Player *GetObjPlayer(uint64 guid);
+        Creature *GetBot(){ return m_bot; }
+        void SetBot(Creature *bot){ m_bot = bot; }
+        CommandStates GetBotCommandState() { return m_botCommandState; }
+        void SetBotCommandState(CommandStates st)
+        {
+            m_botCommandState = st;
+            switch(st)
+            {
+                case COMMAND_STAY:
+                    //m_bot->MonsterSay("Standing still.", LANG_UNIVERSAL, NULL);
+                    m_bot->StopMoving();
+                    m_bot->GetMotionMaster()->Clear();
+                    m_bot->GetMotionMaster()->MoveIdle();
+                    m_bot->GetCharmInfo()->SetCommandState (COMMAND_STAY);
+                    break;
+                case COMMAND_FOLLOW:
+                    //m_bot->MonsterSay("Following.", LANG_UNIVERSAL, NULL);
+                    m_bot->GetMotionMaster()->MoveFollow(this, PET_FOLLOW_DIST*urand(1, 2), PET_FOLLOW_ANGLE);
+                    m_bot->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+                    m_bot->RemoveFlag (UNIT_FIELD_FLAGS, UNIT_FLAG_IN_COMBAT);
+                    break;
+            }
 
+        }
+        void SetBotReactState(ReactStates st){ m_bot->SetReactState(st); }
+        void RemoveBot();
+        void SetBotAI(CreatureAI *ai){ m_bot_ai = ai; }
+        Creature *GetBotsPet (uint32 entry);
+        void SetBotsPetDied();
+        bool m_botHasPet;
+        Creature *m_botsPet;
+        CreatureAI *GetBotAI(){ return m_bot_ai; }
+        //void SetAmIABot(){m_bot_am_i = true; }
+        //bool AmIABot(){ return (m_bot_ai != NULL); }
+        uint8 GetBotClass(){ return m_bot_class; }
+        uint8 GetBotRace(){ return m_bot_race; }
+        bool GetBotMustBeCreated(){ return m_bot_must_be_created; }
+        bool GetBotMustDie(){ return m_bot_must_die; }
+        uint32 GetBotForm(){ return m_bot_form; }
+
+        void SetBotClass(uint8 botclass){ m_bot_class = botclass; }
+        void SetBotRace(uint8 botrace){ m_bot_race = botrace; }
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class)
+        {
+            m_bot_must_be_created = true;
+            m_bot_entry_must_be_created = m_entry;
+            m_bot_class_must_be_created = m_class;
+            m_bot_race_must_be_created = m_race;
+            m_bot_ai = NULL;
+        }
+        void SetBotMustDie(){ m_bot_must_die = true; }
+        void SetBotForm(uint32 form){ m_bot_form = form; }
+        void SetBotMustWaitForSpell1(uint32 wait){ m_bot_must_wait_for_spell_1 = wait; }
+        uint32 GetBotMustWaitForSpell1(){ return m_bot_must_wait_for_spell_1; }
+        void SetBotMustWaitForSpell2(uint32 wait){ m_bot_must_wait_for_spell_2 = wait; }
+        uint32 GetBotMustWaitForSpell2(){ return m_bot_must_wait_for_spell_2; }
+        void SetBotMustWaitForSpell3(uint32 wait){ m_bot_must_wait_for_spell_3 = wait; }
+        uint32 GetBotMustWaitForSpell3(){ return m_bot_must_wait_for_spell_3; }
+// end Bot System
         WorldLocation& GetTeleportDest() { return m_teleport_dest; }
         bool IsBeingTeleported() const { return mSemaphoreTeleport_Near || mSemaphoreTeleport_Far; }
         bool IsBeingTeleportedNear() const { return mSemaphoreTeleport_Near; }
@@ -2479,6 +2552,11 @@ class Player : public Unit, public GridObject<Player>
         bool HasTitle(CharTitlesEntry const* title) { return HasTitle(title->bit_index); }
         void SetTitle(CharTitlesEntry const* title, bool lost = false);
 
+        //Playerbot mod:
+        void SetPlayerbotAI(PlayerbotAI *ai);
+        PlayerbotAI *GetPlayerbotAI(){ return m_playerbotAI; }
+        bool IsPlayerbot(){ return(GetSession()->GetRemoteAddress() == "bot"); }
+
         //bool isActiveObject() const { return true; }
         bool canSeeSpellClickOn(Creature const* creature) const;
 
@@ -2751,6 +2829,35 @@ class Player : public Unit, public GridObject<Player>
         uint8 m_grantableLevels;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+
+        Creature *m_bot;
+        uint8 m_bot_class;
+        uint8 m_bot_race;
+        uint8 m_MaxPlayerbots;
+        uint8 m_SaveOrgLocation;
+        CommandStates m_botCommandState;
+
+        //bool m_bot_am_I; //am I a bot?
+        bool m_bot_must_be_created;
+        bool m_bot_must_die;
+        uint32 m_bot_entry_must_be_created;
+        uint8 m_bot_class_must_be_created;
+        uint8 m_bot_race_must_be_created;
+        CreatureAI *m_bot_ai;
+
+        uint32 m_bot_form; //Only for Druid
+        uint32 m_bot_must_wait_for_spell_1; //in ms
+        uint32 m_bot_must_wait_for_spell_2; //in ms
+        uint32 m_bot_must_wait_for_spell_3; //in ms
+        uint32 m_botTimer;
+        uint32 m_bot_entry;
+        uint8 newbotclass;
+        uint8 newbotrace;
+        bool m_bot_died;
+// end Bot System
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
@@ -2783,6 +2890,9 @@ class Player : public Unit, public GridObject<Player>
 
         void UpdateCharmedAI();
 
+        // Playerbot mod
+        PlayerbotAI *m_playerbotAI;
+
         uint32 m_lastFallTime;
         float  m_lastFallZ;
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index f6798d0..5d2f281 100755
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -15974,7 +15974,9 @@ bool Unit::SetCharmedBy(Unit* charmer, CharmType type, AuraApplication const* au
             case CHARM_TYPE_CONVERT:
                 break;
         }
+
     }
+
     return true;
 }
 
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 6311066..d296f18 100755
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -34,6 +34,10 @@
 #include "MapInstanced.h"
 #include "Util.h"
 #include "LFGMgr.h"
+//Playerbot mod
+#include "Config.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
 
 Roll::Roll(uint64 _guid, LootItem const& li) : itemGUID(_guid), itemid(li.itemid),
 itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
@@ -107,7 +111,7 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
-    m_lootMethod = GROUP_LOOT;
+    m_lootMethod = (LootMethod)ConfigMgr::GetIntDefault("Bot.LootMethod", 2);
     m_lootThreshold = ITEM_QUALITY_UNCOMMON;
     m_looterGuid = leaderGuid;
 
@@ -389,6 +393,31 @@ bool Group::AddMember(Player* player)
 bool Group::RemoveMember(uint64 guid, const RemoveMethod &method /*= GROUP_REMOVEMETHOD_DEFAULT*/, uint64 kicker /*= 0*/, const char* reason /*= NULL*/)
 {
     BroadcastGroupUpdate();
+    {
+        Player *player = ObjectAccessor::FindPlayer(guid);
+
+        if(player)
+        {
+            //Log out any Playerbots by the player
+            WorldSession *session = player->GetSession();
+
+            //save the map of playerbots first because if the map gets altered when
+            //a playerbot logs out which will corrupt the for loop
+            PlayerBotMap m_playerBots;
+            for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+            {
+                Player *bot = itr->second;
+                (m_playerBots)[itr->first] = bot;
+            }
+
+            //now log out any playerbots it may have
+            for(PlayerBotMap::const_iterator itr2 = m_playerBots.begin(); itr2 != m_playerBots.end(); ++itr2)
+            {
+                Player *bot = itr2->second;
+                session->LogoutPlayerBot(bot->GetGUID(),true);
+            }
+        }
+    }
 
     sScriptMgr->OnGroupRemoveMember(this, guid, method, kicker, reason);
 
@@ -440,6 +469,8 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod &method /*= GROUP_REMOV
         // Reevaluate group enchanter if the leaving player had enchanting skill or the player is offline
         if ((player && player->GetSkillValue(SKILL_ENCHANTING)) || !player)
             ResetMaxEnchantingLevel();
+        if (ObjectAccessor::FindPlayer(guid)) SendUpdate();
+		    ResetMaxEnchantingLevel();
 
         // Remove player from loot rolls
         for (Rolls::iterator it = RollId.begin(); it != RollId.end(); ++it)
@@ -504,7 +535,7 @@ void Group::ChangeLeader(uint64 guid)
     if (slot == m_memberSlots.end())
         return;
 
-    Player* player = ObjectAccessor::FindPlayer(slot->guid);
+    Player* player = ObjectAccessor::FindPlayer(guid);
 
     // Don't allow switching leader to offline players
     if (!player)
@@ -1139,6 +1170,33 @@ void Group::CountTheRoll(Rolls::iterator rollI, uint32 NumberOfPlayers)
     delete roll;
 }
 
+//
+// Bot changes
+//
+uint64 Group::GetTargetWithIconByGroup(uint64 guid)
+{
+  //  if (icon >= TARGETICONCOUNT) return 0;
+
+    uint64 targetGUID = 0;
+
+    switch(GetMemberGroup(guid))
+    {
+    case 0: targetGUID = m_targetIcons[STAR]; break;
+    case 1: targetGUID = m_targetIcons[CIRCLE]; break;
+    case 2: targetGUID = m_targetIcons[DIAMOND]; break;
+    case 3: targetGUID = m_targetIcons[TRIANGLE]; break;
+    case 4: targetGUID = m_targetIcons[MOON]; break;
+    case 5: targetGUID = m_targetIcons[SQUARE]; break;
+    case 6: targetGUID = m_targetIcons[CROSS]; break;
+    default: break;
+    }
+
+    // if no target icon, default to star
+    if (targetGUID==0) m_targetIcons[STAR];
+
+   return targetGUID;
+} // end getTargetWithIcon
+
 void Group::SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid)
 {
     if (id >= TARGETICONCOUNT)
@@ -1965,6 +2023,25 @@ void Group::SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag)
     // Preserve the new setting in the db
     CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
+    Player *pPlayer = ObjectAccessor::FindPlayer(guid);
+    if (pPlayer->GetPlayerbotAI()!=NULL) {
+        if (apply) {
+            pPlayer->HandleEmoteCommand(EMOTE_ONESHOT_ROAR);        // if pBot is maintank, acknowledge it
+        } else {
+            pPlayer->HandleEmoteCommand(EMOTE_ONESHOT_CRY);
+        }
+    }
+    // tell all the bots who is the main tank now
+    if (apply)
+        for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->getSource();
+            PlayerbotAI *ai = tPlayer->GetPlayerbotAI();
+            ai->GetClassAI();
+            if (tPlayer->IsPlayerbot())
+                tPlayer->GetPlayerbotAI()->GetClassAI()->SetMainTank(ObjectAccessor::FindPlayer(guid));
+        }
+
     // Broadcast the changes to the group
     SendUpdate();
 }
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index c51aa6d..40e60d1 100755
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -44,6 +44,21 @@ struct MapEntry;
 #define MAX_RAID_SUBGROUPS MAXRAIDSIZE/MAXGROUPSIZE
 #define TARGETICONCOUNT 8
 
+class PlayerbotAI;
+class PlayerbotClassAI;
+
+enum TARGETICON
+{
+    STAR            = 0,
+    CIRCLE          = 1,
+    DIAMOND         = 2,
+    TRIANGLE        = 3,
+    MOON            = 4,
+    SQUARE          = 5,
+    CROSS           = 6,
+    SKULL           = 7
+};
+
 enum RollVote
 {
     PASS              = 0,
@@ -243,6 +258,7 @@ class Group
 
         void ChangeMembersGroup(uint64 guid, uint8 group);
         void ChangeMembersGroup(Player* player, uint8 group);
+        uint64 GetTargetWithIconByGroup(uint64 guid);
         void SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid);
         void SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag);
         void RemoveUniqueGroupMemberFlag(GroupMemberFlags flag);
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 9c395a2..ef65d3e 100755
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2180,7 +2180,9 @@ void InstanceMap::InitVisibilityDistance()
 */
 bool InstanceMap::CanEnter(Player* player)
 {
-    if (player->GetMapRef().getTarget() == this)
+    //playerbots calls this twice, first by TeleportTo and again by WorldSession
+    //Don't want to error since we know we are already here.
+   if(player->GetMapRef().getTarget() == this && !player->IsPlayerbot())
     {
         sLog->outError("InstanceMap::CanEnter - player %s(%u) already in map %d, %d, %d!", player->GetName(), player->GetGUIDLow(), GetId(), GetInstanceId(), GetSpawnMode());
         ASSERT(false);
@@ -2284,10 +2286,21 @@ bool InstanceMap::AddPlayerToMap(Player* player)
             {
                 if (group)
                 {
+                    bool isBot = player->IsPlayerbot();
                     // solo saves should be reset when entering a group
                     InstanceGroupBind* groupBind = group->GetBoundInstance(this);
                     if (playerBind)
                     {
+                        if (isBot)
+                        {
+                            player->UnbindInstance(mapSave->GetMapId(),mapSave->GetDifficulty(),true);
+                        }
+                        else {
+                            sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d,%d,%d,%d,%d,%d but he is in group %d and is bound to instance %d,%d,%d,%d,%d,%d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset(), GUID_LOPART(group->GetLeaderGUID()), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset());
+                            if (groupBind) sLog->outError("InstanceMap::Add: the group is bound to the instance %d,%d,%d,%d,%d,%d", groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty(), groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount(), groupBind->save->CanReset());
+                            //ASSERT(false);
+                            return false;
+                        }
                         sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d, %d, %d, %d, %d, %d but he is in group %d and is bound to instance %d, %d, %d, %d, %d, %d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset(), GUID_LOPART(group->GetLeaderGUID()), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset());
                         if (groupBind)
                             sLog->outError("InstanceMap::Add: the group is bound to the instance %d, %d, %d, %d, %d, %d", groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty(), groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount(), groupBind->save->CanReset());
diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
index 90e5266..a611d75 100755
--- a/src/server/game/Quests/QuestDef.h
+++ b/src/server/game/Quests/QuestDef.h
@@ -97,9 +97,9 @@ enum QuestStatus
 {
     QUEST_STATUS_NONE           = 0,
     QUEST_STATUS_COMPLETE       = 1,
-    //QUEST_STATUS_UNAVAILABLE    = 2,
+    QUEST_STATUS_UNAVAILABLE    = 2,
     QUEST_STATUS_INCOMPLETE     = 3,
-    //QUEST_STATUS_AVAILABLE      = 4,
+    QUEST_STATUS_AVAILABLE      = 4,
     QUEST_STATUS_FAILED         = 5,
     QUEST_STATUS_REWARDED       = 6,        // Not used in DB
     MAX_QUEST_STATUS
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 26d7034..09d2013 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -75,6 +75,7 @@ void AddSC_npc_innkeeper();
 void AddSC_npcs_special();
 void AddSC_npc_taxi();
 void AddSC_achievement_scripts();
+void AddSC_script_bot_giver();
 
 //eastern kingdoms
 void AddSC_alterac_valley();                 //Alterac Valley
@@ -679,6 +680,7 @@ void AddWorldScripts()
     AddSC_npcs_special();
     AddSC_npc_taxi();
     AddSC_achievement_scripts();
+	AddSC_script_bot_giver();
     AddSC_chat_log();
 #endif
 }
diff --git a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
index 512cccb..6d3bb35 100755
--- a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
@@ -43,6 +43,9 @@
 #include "ScriptMgr.h"
 #include "Battleground.h"
 #include "AccountMgr.h"
+// Playerbot mod
+#include "Config.h"
+#include "PlayerbotAI.h"
 
 class LoginQueryHolder : public SQLQueryHolder
 {
@@ -196,6 +199,34 @@ bool LoginQueryHolder::Initialize()
     return res;
 }
 
+// don't call WorldSession directly
+// it may get deleted before the query callbacks get executed
+// instead pass an account id to this handler
+class CharacterHandler
+{
+
+    public:
+        void HandleCharEnumCallback(QueryResult result, uint32 account)
+        {
+            WorldSession * session = sWorld->FindSession(account);
+            if (!session)
+                return;
+            session->HandleCharEnum(result);
+        }
+        void HandlePlayerLoginCallback(QueryResult /*dummy*/, SQLQueryHolder * holder)
+        {
+            if (!holder) return;
+            WorldSession *session = sWorld->FindSession(((LoginQueryHolder*)holder)->GetAccountId());
+            if (!session)
+            {
+                delete holder;
+                return;
+            }
+            session->HandlePlayerLogin((LoginQueryHolder*)holder);
+        }
+
+} chrHandler;
+
 void WorldSession::HandleCharEnum(QueryResult result)
 {
     WorldPacket data(SMSG_CHAR_ENUM, 100);                  // we guess size
@@ -1019,6 +1050,104 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder * holder)
     delete holder;
 }
 
+//Playerbot mod: is different from the normal
+//HandlePlayerLoginCallback in that it sets up the bot's
+//world session and also stores the pointer to the bot player
+//in the master's world session m_playerBots map
+void WorldSession::HandlePlayerBotLogin(SQLQueryHolder *holder)
+{
+    if(!holder) return;
+
+    LoginQueryHolder *lqh = (LoginQueryHolder *)holder;
+
+    if(!lqh || !lqh->GetAccountId()) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #1 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        return;
+    }
+
+    WorldSession *masterSession = sWorld->FindSession(lqh->GetAccountId());
+
+    if(!masterSession) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #2 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        return;
+    }
+
+    //This WorldSession is owned by the bot player object
+    //it will deleted in the Player class constructor for Playerbots
+    //only
+    WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, SEC_PLAYER, true, 0, LOCALE_enUS, 0, 0);
+
+    if(!botSession) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #3 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    botSession->m_Address = "bot";
+    botSession->m_expansion = 2;
+
+    uint64 guid = lqh->GetGuid();
+     if(!guid) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #4 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    Group * group = masterSession->GetPlayer()->GetGroup() ;
+    if(group && group->IsFull() &&
+        !group->IsMember(guid) )
+    {
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        ChatHandler chH = ChatHandler( masterSession->GetPlayer());
+        chH.PSendSysMessage("Bot removed because group is full.");
+        return;
+    }
+
+    botSession->HandlePlayerLogin(lqh);
+    Player *botPlayer = botSession->GetPlayer();
+
+    if(!botPlayer) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #5 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    //give the bot some AI, object is owned by the player class
+    PlayerbotAI *ai = new PlayerbotAI(masterSession->GetPlayer(), botPlayer);
+    botPlayer->SetPlayerbotAI(ai);
+
+    ai->SetStartDifficulty(botPlayer->GetDungeonDifficulty());
+    ai->SetStartInstanceID(botPlayer->GetInstanceId());
+    ai->SetStartMapID(botPlayer->GetMapId());
+    ai->SetStartZoneID(botPlayer->GetZoneId());
+    ai->SetStartAreaID(botPlayer->GetAreaId());
+    ai->SetStartO(botPlayer->GetOrientation());
+    ai->SetStartX(botPlayer->GetPositionX());
+    ai->SetStartY(botPlayer->GetPositionY());
+    ai->SetStartZ(botPlayer->GetPositionZ());
+
+    //tell the world session that they now manage this new bot
+    (masterSession->m_playerBots)[guid] = botPlayer;
+
+    //if bot is in a group and master is not in group then
+    //have bot leave their group
+    if(botPlayer->GetGroup() &&
+        (masterSession->GetPlayer()->GetGroup() == NULL ||
+        masterSession->GetPlayer()->GetGroup()->IsMember(guid) == false))
+        botPlayer->RemoveFromGroup();
+}
+
 void WorldSession::HandleSetFactionAtWar(WorldPacket & recv_data)
 {
     sLog->outStaticDebug("WORLD: Received CMSG_SET_FACTION_ATWAR");
@@ -1172,6 +1301,40 @@ void WorldSession::HandleChangePlayerNameOpcodeCallBack(QueryResult result, std:
     SendPacket(&data);
 }
 
+//Playerbot mod - add new player bot for this master. This definition must
+//appear in this file because it utilizes the CharacterHandler class
+//which isn't accessible outside this file
+void WorldSession::AddPlayerBot(uint64 playerGuid)
+{
+    //has bot already been added?
+    if(GetPlayerBot(playerGuid) != 0) return;
+
+    ChatHandler chH = ChatHandler(GetPlayer());
+
+    //check if max playerbots are exceeded
+   uint8 count = 0;
+    uint8 m_MaxPlayerbots = ConfigMgr::GetFloatDefault("Bot.MaxPlayerbots", 9);
+    for(PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr) ++count;
+
+    if(count >= m_MaxPlayerbots)
+    {
+        chH.PSendSysMessage("You have reached the maximum number (%d) of Player Bots allowed.", m_MaxPlayerbots);
+        return;
+    }
+
+    LoginQueryHolder *holder = new LoginQueryHolder(GetAccountId(), playerGuid);
+
+    if(!holder->Initialize())
+    {
+        delete holder; //delete all unprocessed queries
+        return;
+    }
+    //CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerBotLoginCallback, holder);
+	_charBotLoginCallback = CharacterDatabase.DelayQueryHolder(holder);
+
+    chH.PSendSysMessage("Bot added successfully.");
+}
+
 void WorldSession::HandleSetPlayerDeclinedNames(WorldPacket& recv_data)
 {
     uint64 guid;
diff --git a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
index 852549b..f4e8d43 100755
--- a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
@@ -40,6 +40,8 @@
 #include "Util.h"
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
+//Playerbot mod
+#include "PlayerbotAI.h"
 
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
@@ -143,6 +145,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
             {
                 switch (type)
                 {
+
                     case CHAT_MSG_PARTY:
                     case CHAT_MSG_PARTY_LEADER:
                     case CHAT_MSG_RAID:
@@ -295,7 +298,17 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
             if (!senderIsPlayer && !sender->isAcceptWhispers() && !sender->IsInWhisperWhiteList(receiver->GetGUID()))
                 sender->AddWhisperWhiteList(receiver->GetGUID());
 
-            GetPlayer()->Whisper(msg, lang, receiver->GetGUID());
+            //Playerbot mod: handle whispered command to bot
+            if(sender->GetPlayerbotAI())
+            {
+                sender->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else {
+            //end Playerbot mod
+                GetPlayer()->Whisper(msg, lang, receiver->GetGUID());
+            }
         } break;
         case CHAT_MSG_PARTY:
         case CHAT_MSG_PARTY_LEADER:
@@ -314,6 +327,20 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
+            //Playerbot mod: broadcast message to bot members
+            Player *player;
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                player = itr->getSource();
+                if(player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+//end Playerbot mod
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, uint8(type), lang, NULL, 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
diff --git a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
index 6586528..ca4efe9 100755
--- a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
@@ -303,6 +303,15 @@ void WorldSession::HandleGroupUninviteGuidOpcode(WorldPacket & recv_data)
     if (grp->IsMember(guid))
     {
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID(), reason.c_str());
+
+        //remove any npcbots it has
+        //Creature *bot = GetPlayer()->GetBot();
+        //if(bot && bot->GetGUID() == guid) GetPlayer()->SetBotMustDie();
+
+        //check that player is not a playerbot
+        Player *player = ObjectAccessor::FindPlayer(guid);
+        if(player && player->IsPlayerbot()) GetPlayer()->GetSession()->LogoutPlayerBot(guid, true);
+
         return;
     }
 
@@ -322,10 +331,19 @@ void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
     std::string membername;
     recv_data >> membername;
 
+    Player *player = GetPlayer();
+
     // player not found
     if (!normalizePlayerName(membername))
+    {
+        if(player->HaveBot() &&  !membername.compare(player->GetBot()->GetName()))
+        {
+            Group *grp = GetPlayer()->GetGroup();
+            player->SetBotMustDie();
+            Player::RemoveFromGroup(grp, player->GetBot()->GetGUID());
+        }
         return;
-
+    }
     // can't uninvite yourself
     if (GetPlayer()->GetName() == membername)
     {
@@ -346,10 +364,21 @@ void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
 
     if (uint64 guid = grp->GetMemberGUID(membername))
     {
+        if(player->HaveBot() &&  !membername.compare(player->GetBot()->GetName())) player->SetBotMustDie();
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID());
         return;
     }
-
+    else
+    {
+        //check if it is a bot
+        if(player->HaveBot())
+        {
+            Group *grp = GetPlayer()->GetGroup();
+            player->SetBotMustDie();
+            Player::RemoveFromGroup(grp, player->GetBot()->GetGUID(), GROUP_REMOVEMETHOD_KICK);
+            return;
+        }
+    }
     if (Player* player = grp->GetInvited(membername))
     {
         player->UninviteFromGroup();
diff --git a/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp b/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
index a675214..3c05a98 100755
--- a/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
@@ -338,8 +338,9 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket & recv_data)
     {
 //        _player->TalkedToCreature(unit->GetEntry(), unit->GetGUID());
         _player->PrepareGossipMenu(unit, unit->GetCreatureInfo()->GossipMenuId, true);
-        _player->SendPreparedGossip(unit);
     }
+
+     _player->SendPreparedGossip(unit);
     unit->AI()->sGossipHello(_player);
 }
 
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 14c8628..3d80b8e 100755
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -42,6 +42,9 @@
 #include "zlib.h"
 #include "ScriptMgr.h"
 #include "Transport.h"
+//Playerbot mod
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
 
 bool MapSessionFilter::Process(WorldPacket* packet)
 {
@@ -110,7 +113,11 @@ isRecruiter(isARecruiter)
 /// WorldSession destructor
 WorldSession::~WorldSession()
 {
-    ///- unload player if not unloaded
+    //Playerbot mod: log out any PlayerBots owned in this WorldSession
+    while(!m_playerBots.empty())
+    LogoutPlayerBot(m_playerBots.begin()->first, true);
+
+	///- unload player if not unloaded
     if (_player)
         LogoutPlayer (true);
 
@@ -145,6 +152,13 @@ char const* WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
+    //Playerbot mod: send packet to bot AI
+    if(GetPlayer() && GetPlayer()->GetPlayerbotAI()) {
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+    } else if(!m_playerBots.empty()) {
+            PlayerbotAI::HandleMasterOutgoingPacket(*packet, *this);
+    }
+
     if (!m_Socket)
         return;
 
@@ -216,8 +230,8 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 
     ///- Before we process anything:
     /// If necessary, kick the player from the character select screen
-    if (IsConnectionIdle())
-        m_Socket->CloseSocket();
+    /*if (IsConnectionIdle())
+        m_Socket->CloseSocket();*/
 
     ///- Retrieve packets from the receive queue and call the appropriate handlers
     /// not process packets if socket already closed
@@ -249,6 +263,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                             (this->*opHandle.handler)(*packet);
                             if (sLog->IsOutDebug() && packet->rpos() < packet->wpos())
                                 LogUnprocessedTail(packet);
+
+                            // Playerbot mod: if this player has bots let the
+                            // botAI see the masters packet
+                            if(!m_playerBots.empty())
+                                PlayerbotAI::HandleMasterIncomingPacket(*packet, *this);
                         }
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                         break;
@@ -333,7 +352,28 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
         ///- If necessary, log the player out
         if (ShouldLogOut(currTime) && !m_playerLoading)
             LogoutPlayer(true);
-
+    //Playerbot mod - Process player bot packets
+    //The PlayerbotAI class adds to the packet queue to simulate a real player
+    //since Playerbots are known to the World obj only its master's
+    //WorldSession object we need to process all master's bot's packets.
+        for(PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+        {
+            Player *const botPlayer = itr->second;
+            WorldSession *const pBotWorldSession = botPlayer->GetSession();
+            if(botPlayer->IsBeingTeleportedFar())
+            {
+              pBotWorldSession->HandleMoveWorldportAckOpcode();
+          } else if(botPlayer->IsInWorld())
+          {
+              WorldPacket *packet;
+              while(pBotWorldSession->_recvQueue.next(packet))
+              {
+                  OpcodeHandler &opHandle = opcodeTable[packet->GetOpcode()];
+                  (pBotWorldSession->*opHandle.handler)(*packet);
+                  delete packet;
+              }
+          }
+        }
         ///- Cleanup socket pointer if need
         if (m_Socket && m_Socket->IsClosed())
         {
@@ -350,6 +390,25 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool Save)
 {
+    if (!_player)
+    {
+        return;
+    }
+
+    if (_player->IsMounted()) _player->Unmount();
+
+     // in case it has a minion, kill it
+    if(_player->HaveBot())
+    {
+         _player->GetBot()->SetCharmerGUID(0);
+         _player->GetBot()->RemoveFromWorld();
+         _player->RemoveBot();
+    }
+
+     //Playerbot mod: log out all player bots owned by this toon
+     while(!m_playerBots.empty())
+     LogoutPlayerBot(m_playerBots.begin()->first, Save);
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -470,7 +529,7 @@ void WorldSession::LogoutPlayer(bool Save)
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
-        if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+        if ((_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket) || (_player->IsPlayerbot() && _player->GetGroup()))
             _player->RemoveFromGroup();
 
         ///- Send update to group and reset stored max enchanting level
@@ -494,6 +553,7 @@ void WorldSession::LogoutPlayer(bool Save)
         _player->CleanupsBeforeDelete();
         sLog->outChar("Account: %d (IP: %s) Logout Character:[%s] (GUID: %u)", GetAccountId(), GetRemoteAddress().c_str(), _player->GetName(), _player->GetGUIDLow());
         Map* _map = _player->GetMap();
+        uint32 guid = _player->GetGUIDLow();
         _map->RemovePlayerFromMap(_player, true);
         SetPlayer(NULL);                                    // deleted in Remove call
 
@@ -503,7 +563,7 @@ void WorldSession::LogoutPlayer(bool Save)
 
         ///- Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
         //No SQL injection as AccountId is uint32
-        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE account = '%u'", GetAccountId());
+        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
         sLog->outDebug(LOG_FILTER_NETWORKIO, "SESSION: Sent SMSG_LOGOUT_COMPLETE Message");
     }
 
@@ -605,6 +665,40 @@ void WorldSession::LoadGlobalAccountData()
     LoadAccountData(CharacterDatabase.Query(stmt), GLOBAL_CACHE_MASK);
 }
 
+//Playerbot mod: logs out a Playerbot.
+void WorldSession::LogoutPlayerBot(uint64 guid, bool Save)
+{
+    Player *pPlayerBot = GetPlayerBot(guid);
+
+    if(pPlayerBot) //log out any playbots I have
+    {
+        //if (pPlayerBot->IsMounted()) pPlayerBot->GetPlayerbotAI()->GetClassAI()->Unmount();
+
+        pPlayerBot->CombatStop();
+        if(pPlayerBot->HaveBot())
+            pPlayerBot->SetBotMustDie();
+
+        // remove from group
+        Group* m_group = pPlayerBot->GetGroup();
+        if (m_group) {
+            if (m_group->RemoveMember(pPlayerBot->GetGUID(),GROUP_REMOVEMETHOD_DEFAULT) <= 1) {
+            }
+        }
+
+        WorldSession *pPlayerBotWorldSession = pPlayerBot->m_session;
+        m_playerBots.erase(guid); //deletes bot player ptr inside this WorldSession PlayerBotMap
+        pPlayerBotWorldSession->LogoutPlayer(Save); //this will delete the bot Player object and PlayerbotAI object
+        delete pPlayerBotWorldSession; //finally delete the bot's WorldSession
+    }
+}
+
+//Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player *WorldSession::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return(it == m_playerBots.end()) ? 0 : it->second;
+}
+
 void WorldSession::LoadAccountData(PreparedQueryResult result, uint32 mask)
 {
     for (uint32 i = 0; i < NUM_ACCOUNT_DATA_TYPES; ++i)
@@ -1009,6 +1103,15 @@ void WorldSession::ProcessQueryCallbacks()
         _charLoginCallback.cancel();
     }
 
+    //! HandlePlayerBotLogin
+    if (_charBotLoginCallback.ready())
+    {
+        SQLQueryHolder* param;
+        _charBotLoginCallback.get(param);
+        HandlePlayerBotLogin((SQLQueryHolder*)param);
+        _charBotLoginCallback.cancel();
+    }
+
     //! HandleAddFriendOpcode
     if (_addFriendCallback.IsReady())
     {
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 4a83c2d..7a57f28 100755
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -209,6 +209,8 @@ class CharacterCreateInfo
     private:
         virtual ~CharacterCreateInfo(){};
 };
+//Playerbot mod
+typedef UNORDERED_MAP<uint64, Player*> PlayerBotMap;
 
 /// Player session in the World
 class WorldSession
@@ -216,7 +218,13 @@ class WorldSession
     public:
         WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter);
         ~WorldSession();
-
+        //Playerbot mod
+        void AddPlayerBot(uint64 guid);
+        void LogoutPlayerBot(uint64 guid, bool Save);
+        Player *GetPlayerBot (uint64 guid) const;
+        PlayerBotMap m_playerBots;
+        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
         bool PlayerLogoutWithSave() const { return m_playerLogout && m_playerSave; }
@@ -402,6 +410,7 @@ class WorldSession
         void HandlePlayerLoginOpcode(WorldPacket& recvPacket);
         void HandleCharEnum(QueryResult result);
         void HandlePlayerLogin(LoginQueryHolder * holder);
+		void HandlePlayerBotLogin(SQLQueryHolder * holder);
         void HandleCharFactionOrRaceChange(WorldPacket& recv_data);
 
         // played time
@@ -907,6 +916,7 @@ class WorldSession
         QueryCallback<QueryResult, uint64> _sendStabledPetCallback;
         QueryCallback<PreparedQueryResult, CharacterCreateInfo*> _charCreateCallback;
         QueryResultHolderFuture _charLoginCallback;
+ 		QueryResultHolderFuture _charBotLoginCallback;
 
     private:
         // private trade methods
diff --git a/src/server/game/Weather/Weather.cpp b/src/server/game/Weather/Weather.cpp
index 590e691..5ea41b2 100755
--- a/src/server/game/Weather/Weather.cpp
+++ b/src/server/game/Weather/Weather.cpp
@@ -33,7 +33,7 @@
 Weather::Weather(uint32 zone, WeatherData const* weatherChances)
     : m_zone(zone), m_weatherChances(weatherChances)
 {
-    m_timer.SetInterval(sWorld->getIntConfig(CONFIG_INTERVAL_CHANGEWEATHER));
+    m_timer.SetInterval(150000);
     m_type = WEATHER_TYPE_FINE;
     m_grade = 0;
 
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 408db18..e3a7c50 100755
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1054,6 +1054,8 @@ void World::LoadConfigSettings(bool reload)
     if (m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] > GUILD_BANKLOG_MAX_RECORDS)
         m_int_configs[CONFIG_GUILD_BANK_EVENT_LOG_COUNT] = GUILD_BANKLOG_MAX_RECORDS;
 
+    m_int_configs[CONFIG_HONOR_FROM_PLAYERBOTS] = ConfigMgr::GetBoolDefault("Bot.HonorFromPlayerbots", false);
+
     //visibility on continents
     m_MaxVisibleDistanceOnContinents = ConfigMgr::GetFloatDefault("Visibility.Distance.Continents", DEFAULT_VISIBILITY_DISTANCE);
     if (m_MaxVisibleDistanceOnContinents < 45*sWorld->getRate(RATE_CREATURE_AGGRO))
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index b493b8b..fd2c20a 100755
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -87,6 +87,7 @@ enum WorldBoolConfigs
     CONFIG_ADDON_CHANNEL,
     CONFIG_ALLOW_PLAYER_COMMANDS,
     CONFIG_CLEAN_CHARACTER_DB,
+	CONFIG_HONOR_FROM_PLAYERBOTS,
     CONFIG_GRID_UNLOAD,
     CONFIG_STATS_SAVE_ONLY_ON_LOGOUT,
     CONFIG_ALLOW_TWO_SIDE_ACCOUNTS,
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 1570ca1..ce76fd4 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -10,6 +10,7 @@
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/script_bot_giver.cpp
 )
 
 message("  -> Prepared: Custom")
diff --git a/src/server/scripts/Custom/script_bot_giver.cpp b/src/server/scripts/Custom/script_bot_giver.cpp
new file mode 100644
index 0000000..5c61c39
--- /dev/null
+++ b/src/server/scripts/Custom/script_bot_giver.cpp
@@ -0,0 +1,162 @@
+#include "ScriptPCH.h"
+#include <cstring>
+#include "Group.h"
+
+//This function is called when the player opens the gossip menubool
+class script_bot_giver : public CreatureScript
+{
+	public:
+
+		script_bot_giver()
+            : CreatureScript("script_bot_giver")
+        {
+        }
+
+bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 action)
+		{
+			switch(sender)
+			{
+				case 6002: SendCreatePlayerBotMenu(player, creature, action); break;
+				case 6003: SendCreatePlayerBot(player, creature, action); break;
+				case 6004: SendRemovePlayerBotMenu(player, creature, action); break;
+				case 6005: SendRemovePlayerBot(player, creature, action); break;
+			}
+			return true;
+		}
+
+bool OnGossipHello(Player *player, Creature *creature)
+		{
+			WorldSession *session = player->GetSession();
+			uint8 count = 0;
+
+			for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+			{
+				if(count == 0)
+					player->ADD_GOSSIP_ITEM(0, "Abandon Your Player?", 6004, GOSSIP_ACTION_INFO_DEF + 100);
+
+				++count;
+			}
+
+			if(count < player->GetMaxPlayerBot()) player->ADD_GOSSIP_ITEM(0, "Recruit a Player", 6002, GOSSIP_ACTION_INFO_DEF + 1);
+
+			player->PlayerTalkClass->SendGossipMenu(907, creature->GetGUID());
+			return true;
+		}
+
+void SendCreatePlayerBot(Player *player, Creature *creature, uint32 action)
+		{
+			std::list<std::string> *names;
+			names = player->GetCharacterList();
+			if(names == NULL || names->empty())
+			{
+				player->CLOSE_GOSSIP_MENU();
+				return;
+			}
+
+			int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+			std::list<std::string>::iterator iter, next;
+			for(iter = names->begin(); iter != names->end(); iter++)
+			{
+				if (x==0) player->CreatePlayerBot((*iter).c_str());
+				else {
+					if(x == 1)
+					{
+						player->CreatePlayerBot((*iter).c_str());
+						break;
+					}
+					--x;
+				}
+			}
+
+			player->CLOSE_GOSSIP_MENU();
+		} //end SendCreatePlayerBot
+
+void SendCreatePlayerBotMenu(Player *player, Creature *creature, uint32 action)
+		{
+			std::list<std::string> *names;
+			names = player->GetCharacterList();
+			if(names == NULL || names->empty())
+			{
+				player->CLOSE_GOSSIP_MENU();
+				return;
+			}
+
+            player->PlayerTalkClass->ClearMenus();
+			player->ADD_GOSSIP_ITEM(9, "ADD ALL" , 6003, GOSSIP_ACTION_INFO_DEF + 1);
+			int8 x = 2;
+
+			std::list<std::string>::iterator iter, next;
+			for(iter = names->begin(); iter != names->end(); iter++)
+			{
+				//sLog->outError("character : %s", (*iter).c_str());
+				player->ADD_GOSSIP_ITEM(9, (*iter).c_str() , 6003, GOSSIP_ACTION_INFO_DEF + x);
+				++x;
+			}
+			player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+		} //end SendCreatePlayerBotMenu
+
+void SendRemovePlayerBotAll(Player *player, Creature *creature) {
+			for (int8 x = 2; x<=10; x++ )
+			{
+				SendRemovePlayerBot (player, creature, GOSSIP_ACTION_INFO_DEF + 2);
+			}
+		}
+
+void SendRemovePlayerBot(Player *player, Creature *creature, uint32 action)
+		{
+			int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+			if (x == 0) {
+				SendRemovePlayerBotAll(player, creature);
+				return;
+			}
+
+			WorldSession *session = player->GetSession();
+			for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+			{
+				if(x == 1 && itr->second && itr->second->GetGroup())
+				{
+					Player *m_bot = itr->second;
+					Group *m_group = m_bot->GetGroup();
+
+					//removing bot from group
+					if(m_group->IsMember(m_bot->GetGUID()))
+					{
+						//deleting bot from group
+						if(m_group->RemoveMember(m_bot->GetGUID(), GROUP_REMOVEMETHOD_DEFAULT) < 1) // 99 means I'm a bot
+						{
+							//no one left in group so deleting group
+							//sObjectMgr.RemoveGroup(m_group);
+						}
+					}
+					session->LogoutPlayerBot(m_bot->GetGUID(), true);
+					break;
+				}
+				--x;
+			}
+			player->CLOSE_GOSSIP_MENU();
+		} //end SendRemovePlayerBot
+
+void SendRemovePlayerBotMenu(Player *player, Creature *creature, uint32 action)
+		{
+            player->PlayerTalkClass->ClearMenus();
+			player->ADD_GOSSIP_ITEM(9, "REMOVE ALL", 6005, GOSSIP_ACTION_INFO_DEF + 1);
+
+			uint8 x = 2;
+			WorldSession *session = player->GetSession();
+			for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+			{
+				Player *bot = itr->second;
+				player->ADD_GOSSIP_ITEM(9, bot->GetName(), 6005, GOSSIP_ACTION_INFO_DEF + x);
+				++x;
+			}
+			player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+		} //end SendRemovePlayerBotMenu
+};
+
+//This function is called when the player clicks an option on the gossip menu
+void AddSC_script_bot_giver()
+{
+    new script_bot_giver();
+}
diff --git a/src/server/shared/Common.h b/src/server/shared/Common.h
index bc9c0c6..e512615 100755
--- a/src/server/shared/Common.h
+++ b/src/server/shared/Common.h
@@ -19,6 +19,10 @@
 #ifndef TRINITYCORE_COMMON_H
 #define TRINITYCORE_COMMON_H
 
+#ifndef PLAYERBOT_EXISTS
+#define PLAYERBOT_EXISTS
+#endif
+
 // config.h needs to be included 1st
 // TODO this thingy looks like hack, but its not, need to
 // make separate header however, because It makes mess here.
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index a8c0d91..11321fb 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2785,3 +2785,55 @@ PlayerDump.DisallowOverwrite = 1
 
 #
 ###################################################################################################
+# BOT CONFIGURATION
+#
+#    Bot.FollowDistanceMin
+#    Bot.FollowDistanceMax
+#        Min. and max. follow distance for bots
+#        Default: 0.5 / 2.0
+
+Bot.FollowDistanceMin = 0.5
+Bot.FollowDistanceMax = 2.0
+
+#    Bot.MaxPlayerBots
+#        Maximum number of Player Bots allowed per account
+#        Default: 9
+
+Bot.MaxPlayerBots = 9
+
+#    Bot.PlayerBotsFly
+#        If PlayerBots fly with you when you use the flight master
+#        Default: 0
+#        0 = false
+#        1 = true
+
+Bot.PlayerBotsFly = 1
+
+#    Bot.LootMethod
+#        Type of loot method
+#        Default: 2
+#        0 = Free for all
+#        1 = Round robin
+#        2 = Master loot
+#        3 = Group loot
+#        4 = Need before greed
+
+Bot.LootMethod = 2
+
+#    Bot.SaveOrgLocation
+#        Puts playerbots back to their original location after use
+#        Default: 0
+#        0 = false - keep playerbots where they were camped out
+#        1 = true - puts playerbots back to where they were originally summoned
+
+Bot.SaveOrgLocation = 1
+
+#    Bot.HonorFromPlayerbots
+#        Gain honor if killing a bot
+#        Default = 0
+#        0 = false - Does not give honor when killing a bot
+#        1 = true - Gives honor when bot killed
+
+Bot.HonorFromPlayerbots = 0
+
+################################################################################
-- 
1.7.2.3

